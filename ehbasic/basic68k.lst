Sections:
00: "seg0" (0-5EC)
01: "segc000" (C000-F514)


Source: "basic68k.asm"
                            	     1: *************************************************************************************
                            	     2: *										    *
                            	     3: *	Enhanced BASIC for the Motorola MC680xx					    *
                            	     4: *										    *
                            	     5: *	This version is for the TS2 single board computer.		            *
                            	     6: *	Jeff Tranter (tranter@pobox.com)					    *
                            	     7: *										    *
                            	     8: *************************************************************************************
                            	     9: *										    *
                            	    10: *	Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed *
                            	    11: *	for personal use only. All commercial rights are reserved.		    *
                            	    12: *										    *
                            	    13: *	More 68000 and other projects can be found on my website at ..		    *
                            	    14: *										    *
                            	    15: *	 http://mycorner.no-ip.org/index.html					    *
                            	    16: *										    *
                            	    17: *	mail : leeedavison@googlemail.com					    *
                            	    18: *										    *
                            	    19: *************************************************************************************
                            	    20: 
                            	    21: * Ver 3.54
                            	    22: 
                            	    23: * Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
                            	    24: * USB Flash Drive Host Board
                            	    25: * Ver 3.53 fixes math error that affected exponentiation ("^") and
                            	    26: *  EXP() function. Thanks to joelang for fix.
                            	    27: * Ver 3.52 stops USING$() from reading beyond the end of the format string
                            	    28: * Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
                            	    29: * Ver 3.50 unary minus in concatenate generates a type mismatch error
                            	    30: * Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
                            	    31: * Ver 3.48 allows scientific notation underflow in the USING$() function
                            	    32: * Ver 3.47 traps the use of array elements as the FOR loop variable
                            	    33: * Ver 3.46 updates function and function variable handling
                            	    34: 
                            	    35: *************************************************************************************
                            	    36: *
                            	    37: * Ver 3.45 makes the handling of non existant variables consistent and gives the
                            	    38: * option of not returning an error for a non existant variable. If this is the
                            	    39: * behaviour you want just change novar to some non zero value
                            	    40: 
                            	    41: novar		EQU	0				* non existant variables cause errors
                            	    42: 
                            	    43: * Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
                            	    44: * support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
                            	    45: * Board.
                            	    46: 
                            	    47: FLASH_SUPPORT   EQU     0
                            	    48: 
                            	    49: *************************************************************************************
                            	    50: 
                            	    51: * Ver 3.44 adds overflow indication to the USING$() function
                            	    52: * Ver 3.43 removes an undocumented feature of concatenating null strings
                            	    53: * Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
                            	    54: * Ver 3.41 removes undocumented features of the USING$() function
                            	    55: * Ver 3.40 adds the USING$() function
                            	    56: * Ver 3.33 adds the file requester to LOAD and SAVE
                            	    57: * Ver 3.32 adds the optional ELSE clause to IF .. THEN
                            	    58: 
                            	    59: *************************************************************************************
                            	    60: *
                            	    61: * Version 3.25 adds the option to change the behaviour of INPUT so that a null
                            	    62: * response does not cause a program break. If this is the behaviour you want just
                            	    63: * change nobrk to some non zero value.
                            	    64: 
                            	    65: nobrk		EQU	0				* null response to INPUT causes a break
                            	    66: 
                            	    67: 
                            	    68: *************************************************************************************
                            	    69: *
                            	    70: * Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
                            	    71: * pointer in a3. this means that this could now be run as a task on a multitasking
                            	    72: * system where memory resources may change.
                            	    73: 
                            	    74: 
                            	    75: *************************************************************************************
                            	    76: 
                            	    77: 
                            	    78: 	INCLUDE	"basic68k.inc"

Source: "basic68k.inc"
                            	     1: 
                            	     2: * This lot is in RAM
                            	     3: 
                            	     4:         ORG     0			* start of RAM
                            	     5:  
00:00000000 00000000        	     6: ram_strt	ds.l	$100			* allow 1K for the stack, this should be plenty
00:00000004 *
                            	     7: 						* for any BASIC program that doesn't do something
                            	     8: 						* silly, it could even be much less.
                            	     9: ram_base
00:00000400 0000            	    10: LAB_WARM	ds.w	1			* BASIC warm start entry point
00:00000402 00000000        	    11: Wrmjpv	ds.l	1			* BASIC warm start jump vector
                            	    12: 
00:00000406 0000            	    13: Usrjmp	ds.w	1			* USR function JMP address
00:00000408 00000000        	    14: Usrjpv	ds.l	1			* USR function JMP vector
                            	    15: 
                            	    16: * system dependant i/o vectors
                            	    17: * these are in RAM and are set at start-up
                            	    18: 
00:0000040C 0000            	    19: V_INPT	ds.w	1			* non halting scan input device entry point
00:0000040E 00000000        	    20: V_INPTv	ds.l	1			* non halting scan input device jump vector
                            	    21: 
00:00000412 0000            	    22: V_OUTP	ds.w	1			* send byte to output device entry point
00:00000414 00000000        	    23: V_OUTPv	ds.l	1			* send byte to output device jump vector
                            	    24: 
00:00000418 0000            	    25: V_LOAD	ds.w	1			* load BASIC program entry point
00:0000041A 00000000        	    26: V_LOADv	ds.l	1			* load BASIC program jump vector
                            	    27: 
00:0000041E 0000            	    28: V_SAVE	ds.w	1			* save BASIC program entry point
00:00000420 00000000        	    29: V_SAVEv	ds.l	1			* save BASIC program jump vector
                            	    30: 
00:00000424 0000            	    31: V_CTLC	ds.w	1			* save CTRL-C check entry point
00:00000426 00000000        	    32: V_CTLCv	ds.l	1			* save CTRL-C check jump vector
                            	    33: 
00:0000042A 00000000        	    34: Itemp		ds.l	1			* temporary integer	(for GOTO etc)
                            	    35: 
00:0000042E 00000000        	    36: Smeml		ds.l	1			* start of memory		(start of program)
                            	    37: 
                            	    38: * the program is stored as a series of lines each line having the following format
                            	    39: *
                            	    40: *		ds.l	1			* pointer to the next line or $00000000 if [EOT]
                            	    41: *		ds.l	1			* line number
                            	    42: *		ds.b	n			* program bytes
                            	    43: *		dc.b	$00			* [EOL] marker, there will be a second $00 byte, if
                            	    44: *						* needed, to pad the line to an even number of bytes
                            	    45: 
00:00000432 00000000        	    46: Sfncl		ds.l	1			* start of functions	(end of Program)
                            	    47: 
                            	    48: * the functions are stored as function name, function execute pointer and function
                            	    49: * variable name
                            	    50: *
                            	    51: *		ds.l	1			* name
                            	    52: *		ds.l	1			* execute pointer
                            	    53: *		ds.l	1			* function variable
                            	    54: 
00:00000436 00000000        	    55: Svarl		ds.l	1			* start of variables	(end of functions)
                            	    56: 
                            	    57: * the variables are stored as variable name, variable value
                            	    58: *
                            	    59: *		ds.l	1			* name
                            	    60: *		ds.l	1			* packed float or integer value
                            	    61: 
00:0000043A 00000000        	    62: Sstrl		ds.l	1			* start of strings	(end of variables)
                            	    63: 
                            	    64: * the strings are stored as string name, string pointer and string length
                            	    65: *
                            	    66: *		ds.l	1			* name
                            	    67: *		ds.l	1			* string pointer
                            	    68: *		ds.w	1			* string length
                            	    69: 
00:0000043E 00000000        	    70: Sarryl	ds.l	1			* start of arrays		(end of strings)
                            	    71: 
                            	    72: * the arrays are stored as array name, array size, array dimensions count, array
                            	    73: * dimensions upper bounds and array elements
                            	    74: *
                            	    75: *		ds.l	1			* name
                            	    76: *		ds.l	1			* size including this header
                            	    77: *		ds.w	1			* dimensions count
                            	    78: *		ds.w	1			* 1st dimension upper bound
                            	    79: *		ds.w	1			* 2nd dimension upper bound
                            	    80: *		...				* ...
                            	    81: *		ds.w	1			* nth dimension upper bound
                            	    82: *
                            	    83: * then (i1+1)*(i2+1)...*(in+1) of either ..
                            	    84: *
                            	    85: *		ds.l	1			* packed float or integer value
                            	    86: *
                            	    87: * .. if float or integer, or ..
                            	    88: *
                            	    89: *		ds.l	1			* string pointer
                            	    90: *		ds.w	1			* string length
                            	    91: *
                            	    92: * .. if string
                            	    93: 
00:00000442 00000000        	    94: Earryl	ds.l	1			* end of arrays		(start of free mem)
00:00000446 00000000        	    95: Sstorl	ds.l	1			* string storage		(moving down)
00:0000044A 00000000        	    96: Ememl		ds.l	1			* end of memory		(upper bound of RAM)
00:0000044E 00000000        	    97: Sutill	ds.l	1			* string utility ptr
00:00000452 00000000        	    98: Clinel	ds.l	1			* current line		(Basic line number)
00:00000456 00000000        	    99: Blinel	ds.l	1			* break line		(Basic line number)
                            	   100: 
00:0000045A 00000000        	   101: Cpntrl	ds.l	1			* continue pointer
00:0000045E 00000000        	   102: Dlinel	ds.l	1			* current DATA line
00:00000462 00000000        	   103: Dptrl		ds.l	1			* DATA pointer
00:00000466 00000000        	   104: Rdptrl	ds.l	1			* read pointer
00:0000046A 00000000        	   105: Varname	ds.l	1			* current var name
00:0000046E 00000000        	   106: Cvaral	ds.l	1			* current var address
00:00000472 00000000        	   107: Lvarpl	ds.l	1			* variable pointer for LET and FOR/NEXT
                            	   108: 
00:00000476 00000000        	   109: des_sk_e	ds.l	6			* descriptor stack end address
00:0000047A *
                            	   110: des_sk					* descriptor stack start address
                            	   111: 						* use a4 for the descriptor pointer
00:0000048E 0000            	   112: 		ds.w	1			
00:00000490 00000000        	   113: Ibuffs	ds.l	$40			* start of input buffer
00:00000494 *
                            	   114: Ibuffe
                            	   115: 						* end of input buffer
                            	   116: 
00:00000590 00000000        	   117: FAC1_m	ds.l	1			* FAC1 mantissa1
00:00000594 0000            	   118: FAC1_e	ds.w	1			* FAC1 exponent
                            	   119: FAC1_s	EQU	FAC1_e+1		* FAC1 sign (b7)
00:00000596 0000            	   120: 		ds.w	1			
                            	   121: 
00:00000598 00000000        	   122: FAC2_m	ds.l	1			* FAC2 mantissa1
00:0000059C 00000000        	   123: FAC2_e	ds.l	1			* FAC2 exponent
                            	   124: FAC2_s	EQU	FAC2_e+1		* FAC2 sign (b7)
                            	   125: FAC_sc	EQU	FAC2_e+2		* FAC sign comparison, Acc#1 vs #2
                            	   126: flag		EQU	FAC2_e+3		* flag byte for divide routine
                            	   127: 
00:000005A0 00000000        	   128: PRNlword	ds.l	1			* PRNG seed long word
                            	   129: 
00:000005A4 00000000        	   130: ut1_pl	ds.l	1			* utility pointer 1
                            	   131: 
00:000005A8 00000000        	   132: Asptl		ds.l	1			* array size/pointer
00:000005AC 00000000        	   133: Astrtl	ds.l	1			* array start pointer
                            	   134: 
                            	   135: numexp	EQU	Astrtl		* string to float number exponent count
                            	   136: expcnt	EQU	Astrtl+1		* string to float exponent count
                            	   137: 
                            	   138: expneg	EQU	Astrtl+3		* string to float eval exponent -ve flag
                            	   139: 
00:000005B0 00000000        	   140: func_l	ds.l	1			* function pointer
                            	   141: 
                            	   142: 
                            	   143: 						* these two need to be a word aligned pair !
00:000005B4 0000            	   144: Defdim	ds.w	1			* default DIM flag
                            	   145: cosout	EQU	Defdim		* flag which CORDIC output (re-use byte)
                            	   146: Dtypef	EQU	Defdim+1		* data type flag, $80=string, $40=integer, $00=float
                            	   147: 
                            	   148: 
00:000005B6 00000000        	   149: Binss		ds.l	4			* number to bin string start (32 chrs)
00:000005BA *
                            	   150: 
00:000005C6 00000000        	   151: Decss		ds.l	1			* number to decimal string start (16 chrs)
00:000005CA 0000            	   152: 		ds.w	1			*
00:000005CC 0000            	   153: Usdss		ds.w	1			* unsigned decimal string start (10 chrs)
                            	   154: 
00:000005CE 00000000        	   155: Hexss		ds.l	2			* number to hex string start (8 chrs)
00:000005D2 *
                            	   156: 
00:000005D6 0000            	   157: BHsend	ds.w	1			* bin/decimal/hex string end
                            	   158: 
                            	   159: 
00:000005D8 00              	   160: prstk		ds.b	1			* stacked function index
                            	   161: 
00:000005D9 00              	   162: tpower	ds.b	1			* remember CORDIC power
                            	   163: 
00:000005DA 00              	   164: Asrch		ds.b	1			* scan-between-quotes flag, alt search character
                            	   165: 
00:000005DB 00              	   166: Dimcnt	ds.b	1			* # of dimensions
                            	   167: 
00:000005DC 00              	   168: Breakf	ds.b	1			* break flag, $00=END else=break
00:000005DD 00              	   169: Oquote	ds.b	1			* open quote flag (Flag: DATA; LIST; memory)
00:000005DE 00              	   170: Gclctd	ds.b	1			* garbage collected flag
00:000005DF 00              	   171: Sufnxf	ds.b	1			* subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00:000005E0 00              	   172: Imode		ds.b	1			* input mode flag, $00=INPUT, $98=READ
                            	   173: 
00:000005E1 00              	   174: Cflag		ds.b	1			* comparison evaluation flag
                            	   175: 
00:000005E2 00              	   176: TabSiz	ds.b	1			* TAB step size
                            	   177: 
00:000005E3 00              	   178: comp_f	ds.b	1			* compare function flag, bits 0,1 and 2 used
                            	   179: 						* bit 2 set if >
                            	   180: 						* bit 1 set if =
                            	   181: 						* bit 0 set if <
                            	   182: 
00:000005E4 00              	   183: Nullct	ds.b	1			* nulls output after each line
00:000005E5 00              	   184: TPos		ds.b	1			* BASIC terminal position byte
00:000005E6 00              	   185: TWidth	ds.b	1			* BASIC terminal width byte
00:000005E7 00              	   186: Iclim		ds.b	1			* input column limit
00:000005E8 00              	   187: ccflag	ds.b	1			* CTRL-C check flag
00:000005E9 00              	   188: ccbyte	ds.b	1			* CTRL-C last received byte
00:000005EA 00              	   189: ccnull	ds.b	1			* CTRL-C last received byte 'life' timer
                            	   190: 
                            	   191: * these variables for load/save routines
                            	   192: 
                            	   193:  ifne   FLASH_SUPPORT
                            	   194: 
                            	   195: load_first      ds.b    1               * Boolean indicating if first byte read
                            	   196: load_filename   ds.b    13              * Hold LOAD/SAVE filename (DOS 8.3 format plus terminating null)
                            	   197: 
                            	   198:  endc
                            	   199: 
                            	   200: 		even			* dummy even value and zero pad byte
                            	   201: 
                            	   202: prg_strt
                            	   203: 
                            	   204: * Use these two lines when running from ROM
                            	   205: ram_addr	EQU	$02000		* RAM start address
                            	   206: ram_size	EQU	$06000		* RAM size
                            	   207: 
                            	   208: * Use these two lines when running from RAM
                            	   209: *ram_addr	EQU	$04000		* RAM start address
                            	   210: *ram_size	EQU	$04000		* RAM size
                            	   211: 

Source: "basic68k.asm"
                            	    79: 							* RAM offset definitions
                            	    80: 
                            	    81: * Use this value to run out of ROM
                            	    82: 	ORG		$00C000			* past the vectors in a real system
                            	    83: * Use this value to run out of RAM
                            	    84: *	ORG		$000800			* past the vectors in a real system
                            	    85: 
                            	    86: ACIA_1   =      $00010040        * Console ACIA base address
                            	    87: ACIA_2   =      $00010041        * Auxiliary ACIA base address
                            	    88: 
01:0000C000 604E            	    89:          BRA    code_start       * For convenience, so you can start from first address
                            	    90: 
                            	    91: *************************************************************************************
                            	    92: *
                            	    93: * the following code is simulator specific, change to suit your system
                            	    94: 
                            	    95: * Output character to the console from register d0.b
                            	    96: 
                            	    97: VEC_OUT
01:0000C002 48E74080        	    98:         MOVEM.L  A0/D1,-(A7)    * Save working registers
01:0000C006 41FA4038        	    99:         LEA.L    ACIA_1,A0      * A0 points to console ACIA
                            	   100: TXNOTREADY
01:0000C00A 1210            	   101:         MOVE.B   (A0),D1        * Read ACIA status
01:0000C00C 08010001        	   102:         BTST     #1,D1          * Test TDRE bit
01:0000C010 67F8            	   103:         BEQ.S    TXNOTREADY     * Until ACIA Tx ready
01:0000C012 11400002        	   104:         MOVE.B   D0,2(A0)       * Write character to send
01:0000C016 4CDF0102        	   105:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
01:0000C01A 4E75            	   106:         RTS
                            	   107: 
                            	   108: * Output character to the second (aux) serial port from register d0.b
                            	   109: 
                            	   110:  ifne   FLASH_SUPPORT
                            	   111: 
                            	   112: VEC_OUT2
                            	   113:         MOVEM.L  A0/D1,-(A7)    * Save working registers
                            	   114:         LEA.L    ACIA_2,A0      * A0 points to console ACIA
                            	   115: TXNOTREADY1
                            	   116:         MOVE.B   (A0),D1        * Read ACIA status
                            	   117:         BTST     #1,D1          * Test TDRE bit
                            	   118:         BEQ.s    TXNOTREADY1    * Until ACIA Tx ready
                            	   119:         MOVE.B   D0,2(A0)       * Write character to send
                            	   120:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
                            	   121:         RTS
                            	   122: 
                            	   123: * Output null terminated string pointed to by A0 to first serial port.
                            	   124: 
                            	   125: PRINTSTRING1
                            	   126:         MOVEM.L  A0/D0,-(A7)    * Save working registers
                            	   127: LP1     CMP.B    #0,(A0)        * Is it null?
                            	   128:         BEQ      RET1           * If so, return
                            	   129:         MOVE.B   (A0)+,D0       * Get character and advance pointer
                            	   130:         JSR      VEC_OUT        * Output it
                            	   131:         BRA      LP1            * Continue for rest of string
                            	   132: 
                            	   133: RET1    MOVEM.L  (A7)+,A0/D0    * Restore working registers
                            	   134:         RTS                     * Return
                            	   135: 
                            	   136: * Output null terminated string pointed to by A0 to second serial port.
                            	   137: 
                            	   138: PRINTSTRING2
                            	   139:         MOVEM.L  A0/D0,-(A7)    * Save working registers
                            	   140: LP2     CMP.B    #0,(A0)        * Is it null?
                            	   141:         BEQ      RET2           * If so, return
                            	   142:         MOVE.B   (A0)+,D0       * Get character and advance pointer
                            	   143:         JSR      VEC_OUT2       * Output it
                            	   144:         BRA      LP2            * Continue for rest of string
                            	   145: 
                            	   146: RET2    MOVEM.L  (A7)+,A0/D0    * Restore working registers
                            	   147:         RTS                     * Return
                            	   148: 
                            	   149:  endc
                            	   150: 
                            	   151: *************************************************************************************
                            	   152: *
                            	   153: * input a character from the console into register d0
                            	   154: * else return Cb=0 if there's no character available
                            	   155: 
                            	   156: VEC_IN
01:0000C01C 48E74080        	   157:         MOVEM.L  A0/D1,-(A7)    * Save working registers
01:0000C020 41FA401E        	   158:         LEA.L    ACIA_1,A0      * A0 points to console ACIA
01:0000C024 1210            	   159:         MOVE.B   (A0),D1        * Read ACIA status
01:0000C026 08010000        	   160:         BTST     #0,D1          * Test RDRF bit
01:0000C02A 670E            	   161:         BEQ.S    RXNOTREADY     * Branch if ACIA Rx not ready
01:0000C02C 10280002        	   162:         MOVE.B   2(A0),D0       * Read character received
01:0000C030 4CDF0102        	   163:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
01:0000C034 003C0001        	   164:         ORI.B    #1,CCR         * Set the carry, flag we got a byte
01:0000C038 4E75            	   165:         RTS                     * Return
                            	   166: RXNOTREADY
01:0000C03A 4CDF0102        	   167:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
01:0000C03E 023C00FE        	   168:         ANDI.B   #$FE,CCR       * Clear the carry, flag character not available
01:0000C042 4E75            	   169:         RTS
                            	   170: 
                            	   171: * Input routine used in LOAD mode to read file from USB flash storage.
                            	   172: 
                            	   173:  ifne   FLASH_SUPPORT
                            	   174: 
                            	   175: VEC_IN2
                            	   176:         MOVEM.L  A0/D1,-(A7)    * Save working registers
                            	   177:         LEA.L    VEC_OUT2,A0    * Redirect output to aux. port.
                            	   178:         MOVE.L   A0,V_OUTPv(a3)
                            	   179: 
                            	   180: * The first time, send READ <filename> 1 1
                            	   181: * Subsequent times, send READ <filename> n 1
                            	   182: 
                            	   183:         LEA      LAB_READN(pc),A0 * Send READ command string
                            	   184:         BSR      PRINTSTRING2   * Print null terminated string
                            	   185: 
                            	   186:         LEA      load_filename(A3),A0 * Send filename string
                            	   187:         BSR      PRINTSTRING2   * Print null terminated string
                            	   188: 
                            	   189:         MOVE.B   #' ',D0       * Send space
                            	   190:         JSR      VEC_OUT2
                            	   191: 
                            	   192:         CMP.B    #1,load_first(A3) * First time?
                            	   193:         BNE      NOTFIRST1
                            	   194:         MOVE.B   #'1',D0        * Send '1'
                            	   195:         CLR.B    load_first(A3) * Clear first flag
                            	   196:         BRA      SENDCMD1
                            	   197: NOTFIRST1
                            	   198:         MOVE.B   #'n',D0        * Send 'n'
                            	   199: SENDCMD1
                            	   200:         JSR      VEC_OUT2
                            	   201:         MOVE.B   #' ',D0        * Send space
                            	   202:         JSR      VEC_OUT2
                            	   203:         MOVE.B   #'1',D0        * Send '1'
                            	   204:         JSR      VEC_OUT2
                            	   205:         MOVE.B   #$0D,D0        * Send <Return>
                            	   206:         JSR      VEC_OUT2
                            	   207: 
                            	   208:         LEA.L    VEC_OUT,A0     * Redirect output back to console port.
                            	   209:         MOVE.L   A0,V_OUTPv(a3)
                            	   210: 
                            	   211: * Read one byte from USB host
                            	   212: 
                            	   213:         LEA.L    ACIA_2,A0      * A0 points to console ACIA
                            	   214: RXNOTREADY2
                            	   215:         MOVE.B   (A0),D1        * Read ACIA status
                            	   216:         BTST     #0,D1          * Test RDRF bit
                            	   217:         BEQ.S    RXNOTREADY2    * Branch if ACIA Rx not ready
                            	   218:         MOVE.B   2(A0),D0       * Read character received
                            	   219: 
                            	   220: * Check for end of file character ('~') and if found, redirect
                            	   221: * input back to console port.
                            	   222: 
                            	   223:         CMP.B    #'~',D0        * End of file marker?
                            	   224:         BNE      NOTEOF
                            	   225:         MOVE.B   #$0D,D0        * Convert '~' to a Return
                            	   226:         LEA.L    VEC_IN,A0      * Redirect input back to console port.
                            	   227:         MOVE.L   A0,V_INPTv(a3)
                            	   228: NOTEOF
                            	   229:         MOVEM.L  (A7)+,A0/D1    * Restore working registers
                            	   230:         ORI.b    #1,CCR         * Set the carry, flag we got a byte
                            	   231:         RTS                     * Return
                            	   232: 
                            	   233:  endc
                            	   234: 
                            	   235: *************************************************************************************
                            	   236: *
                            	   237: * LOAD routine for the TS2 computer (not implemented)
                            	   238: 
                            	   239:  ifeq   FLASH_SUPPORT
                            	   240: 
                            	   241: VEC_LD
01:0000C044 7E2E            	   242:        MOVEQ           #$2E,d7                         * error code $2E "Not implemented" error
01:0000C046 6000013E        	   243:        BRA             LAB_XERR                        * do error #d7, then warm start
                            	   244: 
                            	   245:  endc
                            	   246: 
                            	   247: * LOAD routine for the TS2 computer. Supports a Hobbytronics USB Flash
                            	   248: * Drive Host Board connected to the auxiliary serial port.
                            	   249: 
                            	   250:  ifne   FLASH_SUPPORT
                            	   251: 
                            	   252: VEC_LD  LEA             LAB_FILENAME(PC),A0             * Prompt for filename.
                            	   253:         BSR             PRINTSTRING1                    * Print null terminated string
                            	   254:         MOVE.L          A3,A2                           * Save pointer to RAM variables
                            	   255: GETFN1  JSR             VEC_IN                          * Get character
                            	   256:         BCC             GETFN1                          * Go back if carry clear, indicating no key pressed
                            	   257:         JSR             VEC_OUT                         * Echo the character
                            	   258:         CMP.B           #$0D,D0                         * Was it <Return>?
                            	   259:         BEQ             ENDLN1                          * If so, branch
                            	   260:         CMP.B           #$7F,D0                         * Was it <Delete>?
                            	   261:         BEQ             DELETE1                         * If so, handle delete
                            	   262:         CMP.B           #$08,D0                         * Was it <Backspace?
                            	   263:         BEQ             DELETE1                         * If so, handle as delete
                            	   264:         MOVE.B          D0,load_filename(A2)            * Save in buffer
                            	   265:         ADDQ.L          #1,A2                           * Advance string pointer
                            	   266:         BRA             GETFN1                          * Go back and get next character
                            	   267: DELETE1 SUBQ.L          #1,A2                           * Delete last character entered
                            	   268:         BRA             GETFN1                          * Go back and get next character
                            	   269: 
                            	   270: ENDLN1  MOVE.B          #0,load_filename(A2)            * Add terminating null to filename
                            	   271:         LEA.L           VEC_IN2,A0                      * Redirect input from aux. port.
                            	   272:         MOVE.L          A0,V_INPTv(a3)
                            	   273:         MOVE.B          #1,load_first(A3)               * Set load_first flag
                            	   274: 
                            	   275: * Input routine will detect end of file and redirect input back to
                            	   276: * console port.
                            	   277: 
                            	   278:         RTS
                            	   279: 
                            	   280:  endc
                            	   281: 
                            	   282: *************************************************************************************
                            	   283: *
                            	   284: * SAVE routine for the TS2 computer (not implemented)
                            	   285: 
                            	   286:  ifeq   FLASH_SUPPORT
                            	   287: VEC_SV
01:0000C04A 7E2E            	   288:        MOVEQ           #$2E,d7                         * error code $2E "Not implemented" error
01:0000C04C 60000138        	   289:        BRA             LAB_XERR                        * do error #d7, then warm start
                            	   290:  endc
                            	   291: 
                            	   292:  ifne   FLASH_SUPPORT
                            	   293: 
                            	   294: * SAVE routine for the TS2 computer. Supports a Hobbytronics USB Flash
                            	   295: * Drive Host Board connected to the auxiliary serial port.
                            	   296: 
                            	   297: * TODO: Make configurable at build time
                            	   298: 
                            	   299: VEC_SV  LEA             LAB_FILENAME(PC),A0             * Prompt for filename.
                            	   300:         BSR             PRINTSTRING1                    * Print null terminated string
                            	   301:         MOVE.L          A3,A2                           * Save pointer to RAM variables
                            	   302: GETFN   JSR             VEC_IN                          * Get character
                            	   303:         BCC             GETFN                           * Go back if carry clear, indicating no key pressed
                            	   304:         JSR             VEC_OUT                         * Echo the character
                            	   305:         CMP.B           #$0D,D0                         * Was it <Return>?
                            	   306:         BEQ             ENDLN                           * If so, branch
                            	   307:         CMP.B           #$7F,D0                         * Was it <Delete>?
                            	   308:         BEQ             DELETE                          * If so, handle delete
                            	   309:         CMP.B           #$08,D0                         * Was it <Backspace?
                            	   310:         BEQ             DELETE                          * If so, handle as delete
                            	   311:         MOVE.B          D0,load_filename(A2)            * Save in buffer
                            	   312:         ADDQ.L          #1,A2                           * Advance string pointer
                            	   313:         BRA             GETFN                           * Go back and get next character
                            	   314: DELETE  SUBQ.L          #1,A2                           * Delete last character entered
                            	   315:         BRA             GETFN                           * Go back and get next character
                            	   316: 
                            	   317: ENDLN   MOVE.B          #0,load_filename(A2)            * Add terminating null to filename
                            	   318: 
                            	   319:         LEA.L           VEC_OUT2,A0                     * Redirect output to aux. port.
                            	   320:         MOVE.L          A0,V_OUTPv(a3)
                            	   321: 
                            	   322:         LEA             LAB_WRITE(pc),A0                * Send WRITE command string
                            	   323:         BSR             PRINTSTRING2                    * Print null terminated string
                            	   324: 
                            	   325:         LEA             load_filename(A3),A0            * Send filename string
                            	   326:         BSR             PRINTSTRING2                    * Print null terminated string
                            	   327: 
                            	   328:         MOVE.B          #$0D,D0                         * Send <Return>
                            	   329:         JSR             VEC_OUT2
                            	   330: 
                            	   331:         MOVE.l          #356000,d0                      * Delay approx. 1 second to allow USB to create file
                            	   332: DELAY   SUBQ.l          #1,d0
                            	   333:         BNE             DELAY
                            	   334: 
                            	   335:         MOVEQ           #0,d0                           * Tells LIST no arguments
                            	   336:         ANDI.b          #$FE,CCR                        * Clear carry
                            	   337:         BSR             LAB_LIST                        * Call LIST routine
                            	   338: 
                            	   339:         MOVEQ           #'~',d0                         * Send tilde symbol indicate end of file (used when loading)
                            	   340:         BSR             LAB_PRNA
                            	   341: 
                            	   342:         MOVEQ           #26,d0                          * Send Control-Z to indicate end of file save operation
                            	   343:         BSR             LAB_PRNA
                            	   344: 
                            	   345:         LEA.L           VEC_OUT,A0                      * Redirect output back to console port.
                            	   346:         MOVE.L          A0,V_OUTPv(a3)
                            	   347:         RTS                                             * Return
                            	   348: 
                            	   349: LAB_WRITE
                            	   350:         dc.b            '$WRITE ',$00
                            	   351: 
                            	   352: LAB_READN
                            	   353:         dc.b            '$READ ',$00
                            	   354: 
                            	   355: LAB_FILENAME
                            	   356:         dc.b            'Filename? ',$00
                            	   357: 
                            	   358:  endc
                            	   359:         even
                            	   360: 
                            	   361: *************************************************************************************
                            	   362: 
                            	   363: code_start
                            	   364:                                 * Set up ACIA parameters
01:0000C050 41FA3FEE        	   365:         LEA.L   ACIA_1,A0       * A0 points to console ACIA
01:0000C054 10BC0015        	   366:         MOVE.B  #$15,(A0)       * Set up ACIA1 constants (no IRQ,
                            	   367:                                 * RTS* low, 8 bit, no parity, 1 stop)
01:0000C058 41FA3FE7        	   368:         LEA.L   ACIA_2,A0       * A0 points to aux. ACIA
01:0000C05C 10BC0015        	   369:         MOVE.B  #$15,(A0)       * Set up ACIA2 constants (no IRQ,
                            	   370:                                 * RTS* low, 8 bit, no parity, 1 stop)
                            	   371: 
                            	   372: * to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
                            	   373: * in d0. these values are at the end of the .inc file
                            	   374: 
01:0000C060 307C2000        	   375: 	MOVEA.l	#ram_addr,a0		* tell BASIC where RAM starts
01:0000C064 203C00006000    	   376: 	MOVE.l	#ram_size,d0		* tell BASIC how big RAM is
                            	   377: 
                            	   378: * end of simulator specific code
                            	   379: 
                            	   380: 
                            	   381: ****************************************************************************************
                            	   382: ****************************************************************************************
                            	   383: ****************************************************************************************
                            	   384: ****************************************************************************************
                            	   385: *
                            	   386: * Register use :- (must improve this !!)
                            	   387: *
                            	   388: *	a6 -	temp Bpntr				* temporary BASIC execute pointer
                            	   389: *	a5 -	Bpntr					* BASIC execute (get byte) pointer
                            	   390: *	a4 -	des_sk				        * descriptor stack pointer
                            	   391: *	a3 -	ram_strt				* start of RAM. all RAM references are offsets
                            	   392: *							* from this value
                            	   393: *
                            	   394: 
                            	   395: *************************************************************************************
                            	   396: *
                            	   397: * BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
                            	   398: * in d0
                            	   399: 
                            	   400: LAB_COLD
01:0000C06A B0BC00004000    	   401: 	CMP.l		#$4000,d0			* compare size with 16k
01:0000C070 6C08            	   402: 	BGE.s		LAB_sizok			* branch if >= 16k
                            	   403: 
01:0000C072 7005            	   404: 	MOVEQ		#5,d0				* error 5 - not enough RAM
01:0000C074 1E3C00E4        	   405:         move.b          #228,D7                         * Go to TUTOR function
01:0000C078 4E4E            	   406:         trap            #14                             * Call TRAP14 handler
                            	   407: 
                            	   408: LAB_sizok
01:0000C07A 2648            	   409: 	MOVEA.l	a0,a3				* copy RAM base to a3
01:0000C07C D1C0            	   410: 	ADDA.l	d0,a0				* a0 is top of RAM
01:0000C07E 2748044A        	   411: 	MOVE.l	a0,Ememl(a3)		* set end of mem
01:0000C082 4FEB0400        	   412: 	LEA		ram_base(a3),sp		* set stack to RAM start + 1k
                            	   413: 
01:0000C086 303C4EF9        	   414: 	MOVE.w	#$4EF9,d0			* JMP opcode
01:0000C08A 204F            	   415: 	MOVEA.l	sp,a0				* point to start of vector table
                            	   416: 
01:0000C08C 30C0            	   417: 	MOVE.w	d0,(a0)+			* LAB_WARM
01:0000C08E 43FAFFDA        	   418: 	LEA		LAB_COLD(pc),a1		* initial warm start vector
01:0000C092 20C9            	   419: 	MOVE.l	a1,(a0)+			* set vector
                            	   420: 
01:0000C094 30C0            	   421: 	MOVE.w	d0,(a0)+			* Usrjmp
01:0000C096 43FA00DC        	   422: 	LEA		LAB_FCER(pc),a1		* initial user function vector
                            	   423: 							* "Function call" error
01:0000C09A 20C9            	   424: 	MOVE.l	a1,(a0)+			* set vector
                            	   425: 
01:0000C09C 30C0            	   426: 	MOVE.w	d0,(a0)+			* V_INPT JMP opcode
01:0000C09E 43FAFF7C        	   427: 	LEA		VEC_IN(pc),a1		* get byte from input device vector
01:0000C0A2 20C9            	   428: 	MOVE.l	a1,(a0)+			* set vector
                            	   429: 
01:0000C0A4 30C0            	   430: 	MOVE.w	d0,(a0)+			* V_OUTP JMP opcode
01:0000C0A6 43FAFF5A        	   431: 	LEA		VEC_OUT(pc),a1		* send byte to output device vector
01:0000C0AA 20C9            	   432: 	MOVE.l	a1,(a0)+			* set vector
                            	   433: 
01:0000C0AC 30C0            	   434: 	MOVE.w	d0,(a0)+			* V_LOAD JMP opcode
01:0000C0AE 43FAFF94        	   435: 	LEA		VEC_LD(pc),a1		* load BASIC program vector
01:0000C0B2 20C9            	   436: 	MOVE.l	a1,(a0)+			* set vector
                            	   437: 
01:0000C0B4 30C0            	   438: 	MOVE.w	d0,(a0)+			* V_SAVE JMP opcode
01:0000C0B6 43FAFF92        	   439: 	LEA		VEC_SV(pc),a1		* save BASIC program vector
01:0000C0BA 20C9            	   440: 	MOVE.l	a1,(a0)+			* set vector
                            	   441: 
01:0000C0BC 30C0            	   442: 	MOVE.w	d0,(a0)+			* V_CTLC JMP opcode
01:0000C0BE 43FA2608        	   443: 	LEA		VEC_CC(pc),a1		* save CTRL-C check vector
01:0000C0C2 20C9            	   444: 	MOVE.l	a1,(a0)+			* set vector
                            	   445: 
                            	   446: * set-up start values
                            	   447: 
                            	   448: *##LAB_GMEM
01:0000C0C4 7000            	   449: 	MOVEQ		#$00,d0			* clear d0
01:0000C0C6 174005E4        	   450: 	MOVE.b	d0,Nullct(a3)		* default NULL count
01:0000C0CA 174005E5        	   451: 	MOVE.b	d0,TPos(a3)			* clear terminal position
01:0000C0CE 174005E8        	   452: 	MOVE.b	d0,ccflag(a3)		* allow CTRL-C check
01:0000C0D2 374005EA        	   453: 	MOVE.w	d0,prg_strt-2(a3)		* clear start word
01:0000C0D6 374005D6        	   454: 	MOVE.w	d0,BHsend(a3)		* clear value to string end word
                            	   455: 
01:0000C0DA 177C005005E6    	   456: 	MOVE.b	#$50,TWidth(a3)		* default terminal width byte for simulator
01:0000C0E0 177C000E05E2    	   457: 	MOVE.b	#$0E,TabSiz(a3)		* save default tab size = 14
                            	   458: 
01:0000C0E6 177C003805E7    	   459: 	MOVE.b	#$38,Iclim(a3)		* default limit for TAB = 14 for simulator
                            	   460: 
01:0000C0EC 49EB048E        	   461: 	LEA		des_sk(a3),a4		* set descriptor stack start
                            	   462: 
01:0000C0F0 41EB05EC        	   463: 	LEA		prg_strt(a3),a0		* get start of mem
01:0000C0F4 2748042E        	   464: 	MOVE.l	a0,Smeml(a3)		* save start of mem
                            	   465: 
01:0000C0F8 61000322        	   466: 	BSR		LAB_1463			* do "NEW" and "CLEAR"
01:0000C0FC 61000896        	   467: 	BSR		LAB_CRLF			* print CR/LF
01:0000C100 202B044A        	   468: 	MOVE.l	Ememl(a3),d0		* get end of mem
01:0000C104 90AB042E        	   469: 	SUB.l		Smeml(a3),d0		* subtract start of mem
                            	   470: 
01:0000C108 61001BBE        	   471: 	BSR		LAB_295E			* print d0 as unsigned integer (bytes free)
01:0000C10C 41FA33D6        	   472: 	LEA		LAB_SMSG(pc),a0		* point to start message
01:0000C110 610008E0        	   473: 	BSR		LAB_18C3			* print null terminated string from memory
                            	   474: 
01:0000C114 41FA29BA        	   475: 	LEA		LAB_RSED(pc),a0		* get pointer to value
01:0000C118 61001A5A        	   476: 	BSR		LAB_UFAC			* unpack memory (a0) into FAC1
                            	   477: 
01:0000C11C 41FA0092        	   478: 	LEA		LAB_1274(pc),a0		* get warm start vector
01:0000C120 27480402        	   479: 	MOVE.l	a0,Wrmjpv(a3)		* set warm start vector
01:0000C124 61001FC4        	   480: 	BSR		LAB_RND			* initialise
01:0000C128 4EEB0400        	   481: 	JMP		LAB_WARM(a3)		* go do warm start
                            	   482: 
                            	   483: 
                            	   484: *************************************************************************************
                            	   485: *
                            	   486: * do format error
                            	   487: 
                            	   488: LAB_FOER
01:0000C12C 7E2C            	   489: 	MOVEQ		#$2C,d7			* error code $2C "Format" error
01:0000C12E 6056            	   490: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   491: 
                            	   492: 
                            	   493: *************************************************************************************
                            	   494: *
                            	   495: * do address error
                            	   496: 
                            	   497: LAB_ADER
01:0000C130 7E2A            	   498: 	MOVEQ		#$2A,d7			* error code $2A "Address" error
01:0000C132 6052            	   499: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   500: 
                            	   501: 
                            	   502: *************************************************************************************
                            	   503: *
                            	   504: * do wrong dimensions error
                            	   505: 
                            	   506: LAB_WDER
01:0000C134 7E28            	   507: 	MOVEQ		#$28,d7			* error code $28 "Wrong dimensions" error
01:0000C136 604E            	   508: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   509: 
                            	   510: 
                            	   511: *************************************************************************************
                            	   512: *
                            	   513: * do undimensioned array error
                            	   514: 
                            	   515: LAB_UDER
01:0000C138 7E26            	   516: 	MOVEQ		#$26,d7			* error code $26 "undimensioned array" error
01:0000C13A 604A            	   517: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   518: 
                            	   519: 
                            	   520: *************************************************************************************
                            	   521: *
                            	   522: * do undefined variable error
                            	   523: 
                            	   524: LAB_UVER
                            	   525: 
                            	   526: * if you do want a non existant variable to return an error then leave the novar
                            	   527: * value at the top of this file set to zero
                            	   528: 
                            	   529:  ifeq	novar
                            	   530: 
01:0000C13C 7E24            	   531: 	MOVEQ		#$24,d7			* error code $24 "undefined variable" error
01:0000C13E 6046            	   532: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   533: 
                            	   534:  endc
                            	   535: 
                            	   536: * if you want a non existant variable to return a null value then set the novar
                            	   537: * value at the top of this file to some non zero value
                            	   538: 
                            	   539:  ifne	novar
                            	   540: 
                            	   541: 	ADD.l		d0,d0				* .......$ .......& ........ .......0
                            	   542: 	SWAP		d0				* ........ .......0 .......$ .......&
                            	   543: 	ROR.b		#1,d0				* ........ .......0 .......$ &.......
                            	   544: 	LSR.w		#1,d0				* ........ .......0 0....... $&......
                            	   545: 	AND.b		#$C0,d0			* mask the type bits
                            	   546: 	MOVE.b	d0,Dtypef(a3)		* save the data type
                            	   547: 
                            	   548: 	MOVEQ		#0,d0				* clear d0 and set the zero flag
                            	   549: 	MOVEA.l	d0,a0				* return a null address
                            	   550: 	RTS
                            	   551: 
                            	   552:  endc
                            	   553: 
                            	   554: 
                            	   555: *************************************************************************************
                            	   556: *
                            	   557: * do loop without do error
                            	   558: 
                            	   559: LAB_LDER
01:0000C140 7E22            	   560: 	MOVEQ		#$22,d7			* error code $22 "LOOP without DO" error
01:0000C142 6042            	   561: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   562: 
                            	   563: 
                            	   564: *************************************************************************************
                            	   565: *
                            	   566: * do undefined function error
                            	   567: 
                            	   568: LAB_UFER
01:0000C144 7E20            	   569: 	MOVEQ		#$20,d7			* error code $20 "Undefined function" error
01:0000C146 603E            	   570: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   571: 
                            	   572: 
                            	   573: *************************************************************************************
                            	   574: *
                            	   575: * do can't continue error
                            	   576: 
                            	   577: LAB_CCER
01:0000C148 7E1E            	   578: 	MOVEQ		#$1E,d7			* error code $1E "Can't continue" error
01:0000C14A 603A            	   579: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   580: 
                            	   581: 
                            	   582: *************************************************************************************
                            	   583: *
                            	   584: * do string too complex error
                            	   585: 
                            	   586: LAB_SCER
01:0000C14C 7E1C            	   587: 	MOVEQ		#$1C,d7			* error code $1C "String too complex" error
01:0000C14E 6036            	   588: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   589: 
                            	   590: 
                            	   591: *************************************************************************************
                            	   592: *
                            	   593: * do string too long error
                            	   594: 
                            	   595: LAB_SLER
01:0000C150 7E1A            	   596: 	MOVEQ		#$1A,d7			* error code $1A "String too long" error
01:0000C152 6032            	   597: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   598: 
                            	   599: 
                            	   600: *************************************************************************************
                            	   601: *
                            	   602: * do type missmatch error
                            	   603: 
                            	   604: LAB_TMER
01:0000C154 7E18            	   605: 	MOVEQ		#$18,d7			* error code $18 "Type mismatch" error
01:0000C156 602E            	   606: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   607: 
                            	   608: 
                            	   609: *************************************************************************************
                            	   610: *
                            	   611: * do illegal direct error
                            	   612: 
                            	   613: LAB_IDER
01:0000C158 7E16            	   614: 	MOVEQ		#$16,d7			* error code $16 "Illegal direct" error
01:0000C15A 602A            	   615: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   616: 
                            	   617: 
                            	   618: *************************************************************************************
                            	   619: *
                            	   620: * do divide by zero error
                            	   621: 
                            	   622: LAB_DZER
01:0000C15C 7E14            	   623: 	MOVEQ		#$14,d7			* error code $14 "Divide by zero" error
01:0000C15E 6026            	   624: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   625: 
                            	   626: 
                            	   627: *************************************************************************************
                            	   628: *
                            	   629: * do double dimension error
                            	   630: 
                            	   631: LAB_DDER
01:0000C160 7E12            	   632: 	MOVEQ		#$12,d7			* error code $12 "Double dimension" error
01:0000C162 6022            	   633: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   634: 
                            	   635: 
                            	   636: *************************************************************************************
                            	   637: *
                            	   638: * do array bounds error
                            	   639: 
                            	   640: LAB_ABER
01:0000C164 7E10            	   641: 	MOVEQ		#$10,d7			* error code $10 "Array bounds" error
01:0000C166 601E            	   642: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   643: 
                            	   644: 
                            	   645: *************************************************************************************
                            	   646: *
                            	   647: * do undefined satement error
                            	   648: 
                            	   649: LAB_USER
01:0000C168 7E0E            	   650: 	MOVEQ		#$0E,d7			* error code $0E "Undefined statement" error
01:0000C16A 601A            	   651: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   652: 
                            	   653: 
                            	   654: *************************************************************************************
                            	   655: *
                            	   656: * do out of memory error
                            	   657: 
                            	   658: LAB_OMER
01:0000C16C 7E0C            	   659: 	MOVEQ		#$0C,d7			* error code $0C "Out of memory" error
01:0000C16E 6016            	   660: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   661: 
                            	   662: 
                            	   663: *************************************************************************************
                            	   664: *
                            	   665: * do overflow error
                            	   666: 
                            	   667: LAB_OFER
01:0000C170 7E0A            	   668: 	MOVEQ		#$0A,d7			* error code $0A "Overflow" error
01:0000C172 6012            	   669: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   670: 
                            	   671: 
                            	   672: *************************************************************************************
                            	   673: *
                            	   674: * do function call error
                            	   675: 
                            	   676: LAB_FCER
01:0000C174 7E08            	   677: 	MOVEQ		#$08,d7			* error code $08 "Function call" error
01:0000C176 600E            	   678: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   679: 
                            	   680: 
                            	   681: *************************************************************************************
                            	   682: *
                            	   683: * do out of data error
                            	   684: 
                            	   685: LAB_ODER
01:0000C178 7E06            	   686: 	MOVEQ		#$06,d7			* error code $06 "Out of DATA" error
01:0000C17A 600A            	   687: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   688: 
                            	   689: 
                            	   690: *************************************************************************************
                            	   691: *
                            	   692: * do return without gosub error
                            	   693: 
                            	   694: LAB_RGER
01:0000C17C 7E04            	   695: 	MOVEQ		#$04,d7			* error code $04 "RETURN without GOSUB" error
01:0000C17E 6006            	   696: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   697: 
                            	   698: 
                            	   699: *************************************************************************************
                            	   700: *
                            	   701: * do syntax error
                            	   702: 
                            	   703: LAB_SNER
01:0000C180 7E02            	   704: 	MOVEQ		#$02,d7			* error code $02 "Syntax" error
01:0000C182 6002            	   705: 	BRA.s		LAB_XERR			* do error #d7, then warm start
                            	   706: 
                            	   707: 
                            	   708: *************************************************************************************
                            	   709: *
                            	   710: * do next without for error
                            	   711: 
                            	   712: LAB_NFER
01:0000C184 7E00            	   713: 	MOVEQ		#$00,d7			* error code $00 "NEXT without FOR" error
                            	   714: 
                            	   715: 
                            	   716: *************************************************************************************
                            	   717: *
                            	   718: * do error #d7, then warm start
                            	   719: 
                            	   720: LAB_XERR
01:0000C186 610002CA        	   721: 	BSR		LAB_1491			* flush stack & clear continue flag
01:0000C18A 61000808        	   722: 	BSR		LAB_CRLF			* print CR/LF
01:0000C18E 43FA2FCC        	   723: 	LEA		LAB_BAER(pc),a1		* start of error message pointer table
01:0000C192 3E317000        	   724: 	MOVE.w	(a1,d7.w),d7		* get error message offset
01:0000C196 41F17000        	   725: 	LEA		(a1,d7.w),a0		* get error message address
01:0000C19A 61000856        	   726: 	BSR		LAB_18C3			* print null terminated string from memory
01:0000C19E 41FA3307        	   727: 	LEA		LAB_EMSG(pc),a0		* point to " Error" message
                            	   728: LAB_1269
01:0000C1A2 6100084E        	   729: 	BSR		LAB_18C3			* print null terminated string from memory
01:0000C1A6 202B0452        	   730: 	MOVE.l	Clinel(a3),d0		* get current line
01:0000C1AA 6B04            	   731: 	BMI.s		LAB_1274			* go do warm start if -ve # (was immediate mode)
                            	   732: 
                            	   733: 							* else print line number
01:0000C1AC 61001B0E        	   734: 	BSR		LAB_2953			* print " in line [LINE #]"
                            	   735: 
                            	   736: * BASIC warm start entry point, wait for Basic command
                            	   737: 
                            	   738: LAB_1274
01:0000C1B0 41FA3328        	   739: 	LEA		LAB_RMSG(pc),a0		* point to "Ready" message
01:0000C1B4 6100083C        	   740: 	BSR		LAB_18C3			* go do print string
                            	   741: 
                            	   742: * wait for Basic command - no "Ready"
                            	   743: 
                            	   744: LAB_127D
01:0000C1B8 72FF            	   745: 	MOVEQ		#-1,d1			* set to -1
01:0000C1BA 27410452        	   746: 	MOVE.l	d1,Clinel(a3)		* set current line #
01:0000C1BE 174105DC        	   747: 	MOVE.b	d1,Breakf(a3)		* set break flag
01:0000C1C2 4BEB0490        	   748: 	LEA		Ibuffs(a3),a5		* set basic execute pointer ready for new line
                            	   749: LAB_127E
01:0000C1C6 610000EC        	   750: 	BSR		LAB_1357			* call for BASIC input
01:0000C1CA 61000BF2        	   751: 	BSR		LAB_GBYT			* scan memory
01:0000C1CE 67F6            	   752: 	BEQ.s		LAB_127E			* loop while null
                            	   753: 
                            	   754: * got to interpret input line now ....
                            	   755: 
01:0000C1D0 6508            	   756: 	BCS.s		LAB_1295			* branch if numeric character, handle new
                            	   757: 							* BASIC line
                            	   758: 
                            	   759: 							* no line number so do immediate mode, a5
                            	   760: 							* points to the buffer start
01:0000C1D2 61000156        	   761: 	BSR		LAB_13A6			* crunch keywords into Basic tokens
                            	   762: 							* crunch from (a5), output to (a0)
                            	   763: 							* returns ..
                            	   764: 							* d2 is length, d1 trashed, d0 trashed,
                            	   765: 							* a1 trashed
01:0000C1D6 600003C2        	   766: 	BRA		LAB_15F6			* go scan & interpret code
                            	   767: 
                            	   768: 
                            	   769: *************************************************************************************
                            	   770: *
                            	   771: * handle a new BASIC line
                            	   772: 
                            	   773: LAB_1295
01:0000C1DA 61000638        	   774: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
01:0000C1DE 6100014A        	   775: 	BSR		LAB_13A6			* crunch keywords into Basic tokens
                            	   776: 							* crunch from (a5), output to (a0)
                            	   777: 							* returns .. d2 is length,
                            	   778: 							* d1 trashed, d0 trashed, a1 trashed
01:0000C1E2 222B042A        	   779: 	MOVE.l	Itemp(a3),d1		* get required line #
01:0000C1E6 61000218        	   780: 	BSR		LAB_SSLN			* search BASIC for d1 line number
                            	   781: 							* returns pointer in a0
01:0000C1EA 6532            	   782: 	BCS.s		LAB_12E6			* branch if not found
                            	   783: 
                            	   784: 							* aroooogah! line # already exists! delete it
01:0000C1EC 2250            	   785: 	MOVEA.l	(a0),a1			* get start of block (next line pointer)
01:0000C1EE 202B0432        	   786: 	MOVE.l	Sfncl(a3),d0		* get end of block (start of functions)
01:0000C1F2 9089            	   787: 	SUB.l		a1,d0				* subtract start of block ( = bytes to move)
01:0000C1F4 E288            	   788: 	LSR.l		#1,d0				* /2 (word move)
01:0000C1F6 5380            	   789: 	SUBQ.l	#1,d0				* adjust for DBF loop
01:0000C1F8 4840            	   790: 	SWAP		d0				* swap high word to low word
01:0000C1FA 2448            	   791: 	MOVEA.l	a0,a2				* copy destination
                            	   792: LAB_12AE
01:0000C1FC 4840            	   793: 	SWAP		d0				* swap high word to low word
                            	   794: LAB_12B0
01:0000C1FE 34D9            	   795: 	MOVE.w	(a1)+,(a2)+			* copy word
01:0000C200 51C8FFFC        	   796: 	DBF		d0,LAB_12B0			* decrement low count and loop until done
                            	   797: 
01:0000C204 4840            	   798: 	SWAP		d0				* swap high word to low word
01:0000C206 51C8FFF4        	   799: 	DBF		d0,LAB_12AE			* decrement high count and loop until done
                            	   800: 
01:0000C20A 274A0432        	   801: 	MOVE.l	a2,Sfncl(a3)		* start of functions
01:0000C20E 274A0436        	   802: 	MOVE.l	a2,Svarl(a3)		* save start of variables
01:0000C212 274A043A        	   803: 	MOVE.l	a2,Sstrl(a3)		* start of strings
01:0000C216 274A043E        	   804: 	MOVE.l	a2,Sarryl(a3)		* save start of arrays
01:0000C21A 274A0442        	   805: 	MOVE.l	a2,Earryl(a3)		* save end of arrays
                            	   806: 
                            	   807: 							* got new line in buffer and no existing same #
                            	   808: LAB_12E6
01:0000C21E 102B0490        	   809: 	MOVE.b	Ibuffs(a3),d0		* get byte from start of input buffer
01:0000C222 6764            	   810: 	BEQ.s		LAB_1325			* if null line go do line chaining
                            	   811: 
                            	   812: 							* got new line and it isn't empty line
01:0000C224 226B0432        	   813: 	MOVEA.l	Sfncl(a3),a1		* get start of functions (end of block to move)
01:0000C228 45F12008        	   814: 	LEA		8(a1,d2),a2			* copy it, add line length and add room for
                            	   815: 							* pointer and line number
                            	   816: 
01:0000C22C 274A0432        	   817: 	MOVE.l	a2,Sfncl(a3)		* start of functions
01:0000C230 274A0436        	   818: 	MOVE.l	a2,Svarl(a3)		* save start of variables
01:0000C234 274A043A        	   819: 	MOVE.l	a2,Sstrl(a3)		* start of strings
01:0000C238 274A043E        	   820: 	MOVE.l	a2,Sarryl(a3)		* save start of arrays
01:0000C23C 274A0442        	   821: 	MOVE.l	a2,Earryl(a3)		* save end of arrays
01:0000C240 276B044A0446    	   822: 	MOVE.l	Ememl(a3),Sstorl(a3)	* copy end of mem to start of strings, clear
                            	   823: 							* strings
                            	   824: 
01:0000C246 2209            	   825: 	MOVE.l	a1,d1				* copy end of block to move
01:0000C248 9288            	   826: 	SUB.l		a0,d1				* subtract start of block to move
01:0000C24A E289            	   827: 	LSR.l		#1,d1				* /2 (word copy)
01:0000C24C 5381            	   828: 	SUBQ.l	#1,d1				* correct for loop end on -1
01:0000C24E 4841            	   829: 	SWAP		d1				* swap high word to low word
                            	   830: LAB_12FF
01:0000C250 4841            	   831: 	SWAP		d1				* swap high word to low word
                            	   832: LAB_1301
01:0000C252 3521            	   833: 	MOVE.w	-(a1),-(a2)			* decrement pointers and copy word
01:0000C254 51C9FFFC        	   834: 	DBF		d1,LAB_1301			* decrement & loop
                            	   835: 
01:0000C258 4841            	   836: 	SWAP		d1				* swap high word to low word
01:0000C25A 51C9FFF4        	   837: 	DBF		d1,LAB_12FF			* decrement high count and loop until done
                            	   838: 
                            	   839: * space is opened up, now copy the crunched line from the input buffer into the space
                            	   840: 
01:0000C25E 43EB0490        	   841: 	LEA		Ibuffs(a3),a1		* source is input buffer
01:0000C262 2448            	   842: 	MOVEA.l	a0,a2				* copy destination
01:0000C264 72FF            	   843: 	MOVEQ		#-1,d1			* set to allow re-chaining
01:0000C266 24C1            	   844: 	MOVE.l	d1,(a2)+			* set next line pointer (allow re-chaining)
01:0000C268 24EB042A        	   845: 	MOVE.l	Itemp(a3),(a2)+		* save line number
01:0000C26C E24A            	   846: 	LSR.w		#1,d2				* /2 (word copy)
01:0000C26E 5342            	   847: 	SUBQ.w	#1,d2				* correct for loop end on -1
                            	   848: LAB_1303
01:0000C270 34D9            	   849: 	MOVE.w	(a1)+,(a2)+			* copy word
01:0000C272 51CAFFFC        	   850: 	DBF		d2,LAB_1303			* decrement & loop
                            	   851: 
01:0000C276 6010            	   852: 	BRA.s		LAB_1325			* go test for end of prog
                            	   853: 
                            	   854: * rebuild chaining of BASIC lines
                            	   855: 
                            	   856: LAB_132E
01:0000C278 5048            	   857: 	ADDQ.w	#8,a0				* point to first code byte of line, there is
                            	   858: 							* always 1 byte + [EOL] as null entries are
                            	   859: 							* deleted
                            	   860: LAB_1330
01:0000C27A 4A18            	   861: 	TST.b		(a0)+				* test byte	
01:0000C27C 66FC            	   862: 	BNE.s		LAB_1330			* loop if not [EOL]
                            	   863: 
                            	   864: 							* was [EOL] so get next line start
01:0000C27E 3208            	   865: 	MOVE.w	a0,d1				* past pad byte(s)
01:0000C280 02410001        	   866: 	ANDI.w	#1,d1				* mask odd bit
01:0000C284 D0C1            	   867: 	ADD.w		d1,a0				* add back to ensure even
01:0000C286 2288            	   868: 	MOVE.l	a0,(a1)			* save next line pointer to current line
                            	   869: LAB_1325
01:0000C288 2248            	   870: 	MOVEA.l	a0,a1				* copy pointer for this line
01:0000C28A 4A90            	   871: 	TST.l		(a0)				* test pointer to next line
01:0000C28C 66EA            	   872: 	BNE.s		LAB_132E			* not end of program yet so we must
                            	   873: 							* go and fix the pointers
                            	   874: 
01:0000C28E 61000198        	   875: 	BSR		LAB_1477			* reset execution to start, clear variables
                            	   876: 							* and flush stack
01:0000C292 6000FF24        	   877: 	BRA		LAB_127D			* now we just wait for Basic command, no "Ready"
                            	   878: 
                            	   879: 
                            	   880: *************************************************************************************
                            	   881: *
                            	   882: * receive a line from the keyboard
                            	   883: 							* character $08 as delete key, BACKSPACE on
                            	   884: 							* standard keyboard
                            	   885: LAB_134B
01:0000C296 61000774        	   886: 	BSR		LAB_PRNA			* go print the character
01:0000C29A 7020            	   887: 	MOVEQ		#' ',d0			* load [SPACE]
01:0000C29C 6100076E        	   888: 	BSR		LAB_PRNA			* go print
01:0000C2A0 7008            	   889: 	MOVEQ		#$08,d0			* load [BACKSPACE]
01:0000C2A2 61000768        	   890: 	BSR		LAB_PRNA			* go print
01:0000C2A6 5341            	   891: 	SUBQ.w	#$01,d1			* decrement the buffer index (delete)
01:0000C2A8 6010            	   892: 	BRA.s		LAB_1359			* re-enter loop
                            	   893: 
                            	   894: * print "? " and get BASIC input
                            	   895: * return a0 pointing to the buffer start
                            	   896: 
                            	   897: LAB_INLN
01:0000C2AA 6100075E        	   898: 	BSR		LAB_18E3			* print "?" character
01:0000C2AE 7020            	   899: 	MOVEQ		#' ',d0			* load " "
01:0000C2B0 6100075A        	   900: 	BSR		LAB_PRNA			* go print
                            	   901: 
                            	   902: * call for BASIC input (main entry point)
                            	   903: * return a0 pointing to the buffer start
                            	   904: 
                            	   905: LAB_1357
01:0000C2B4 7200            	   906: 	MOVEQ		#$00,d1			* clear buffer index
01:0000C2B6 41EB0490        	   907: 	LEA		Ibuffs(a3),a0		* set buffer base pointer
                            	   908: LAB_1359
01:0000C2BA 4EAB040C        	   909: 	JSR		V_INPT(a3)			* call scan input device
01:0000C2BE 64FA            	   910: 	BCC.s		LAB_1359			* loop if no byte
                            	   911: 
01:0000C2C0 67F8            	   912: 	BEQ.s		LAB_1359			* loop if null byte
                            	   913: 
01:0000C2C2 B03C0007        	   914: 	CMP.b		#$07,d0			* compare with [BELL]
01:0000C2C6 6718            	   915: 	BEQ.s		LAB_1378			* branch if [BELL]
                            	   916: 
01:0000C2C8 B03C000D        	   917: 	CMP.b		#$0D,d0			* compare with [CR]
01:0000C2CC 670006C0        	   918: 	BEQ		LAB_1866			* do CR/LF exit if [CR]
                            	   919: 
01:0000C2D0 4A41            	   920: 	TST.w		d1				* set flags on buffer index
01:0000C2D2 6606            	   921: 	BNE.s		LAB_1374			* branch if not empty
                            	   922: 
                            	   923: * the next two lines ignore any non printing character and [SPACE] if the input buffer
                            	   924: * is empty
                            	   925: 
01:0000C2D4 B03C0020        	   926: 	CMP.b		#' ',d0			* compare with [SP]+1
01:0000C2D8 63E0            	   927: 	BLS.s		LAB_1359			* if < ignore character
                            	   928: 
                            	   929: *##	CMP.b		#' '+1,d0			* compare with [SP]+1
                            	   930: *##	BCS.s		LAB_1359			* if < ignore character
                            	   931: 
                            	   932: LAB_1374
01:0000C2DA B03C0008        	   933: 	CMP.b		#$08,d0			* compare with [BACKSPACE]
01:0000C2DE 67B6            	   934: 	BEQ.s		LAB_134B			* go delete last character
                            	   935: 
                            	   936: LAB_1378
01:0000C2E0 B27C00FF        	   937: 	CMP.w		#(Ibuffe-Ibuffs-1),d1	* compare character count with max-1
01:0000C2E4 640C            	   938: 	BCC.s		LAB_138E			* skip store & do [BELL] if buffer full
                            	   939: 
01:0000C2E6 11801000        	   940: 	MOVE.b	d0,(a0,d1.w)		* else store in buffer
01:0000C2EA 5241            	   941: 	ADDQ.w	#$01,d1			* increment index
                            	   942: LAB_137F
01:0000C2EC 6100071E        	   943: 	BSR		LAB_PRNA			* go print the character
01:0000C2F0 60C8            	   944: 	BRA.s		LAB_1359			* always loop for next character
                            	   945: 
                            	   946: * announce buffer full
                            	   947: 
                            	   948: LAB_138E
01:0000C2F2 7007            	   949: 	MOVEQ		#$07,d0			* [BELL] character into d0
01:0000C2F4 60F6            	   950: 	BRA.s		LAB_137F			* go print the [BELL] but ignore input character
                            	   951: 
                            	   952: 
                            	   953: *************************************************************************************
                            	   954: *
                            	   955: * copy a hex value without crunching
                            	   956: 
                            	   957: LAB_1392
01:0000C2F6 11802000        	   958: 	MOVE.b	d0,(a0,d2.w)		* save the byte to the output
01:0000C2FA 5242            	   959: 	ADDQ.w	#1,d2				* increment the buffer save index
                            	   960: 
01:0000C2FC 5241            	   961: 	ADDQ.w	#1,d1				* increment the buffer read index
01:0000C2FE 10351000        	   962: 	MOVE.b	(a5,d1.w),d0		* get a byte from the input buffer
01:0000C302 67000094        	   963: 	BEQ		LAB_13EC			* if [EOL] go save it without crunching
                            	   964: 
01:0000C306 B03C0020        	   965: 	CMP.b		#' ',d0			* compare the character with " "
01:0000C30A 67EA            	   966: 	BEQ.s		LAB_1392			* if [SPACE] just go save it and get another
                            	   967: 
01:0000C30C B03C0030        	   968: 	CMP.b		#'0',d0			* compare the character with "0"
01:0000C310 654A            	   969: 	BCS.s		LAB_13C6			* if < "0" quit the hex save loop
                            	   970: 
01:0000C312 B03C0039        	   971: 	CMP.b		#'9',d0			* compare with "9"
01:0000C316 63DE            	   972: 	BLS.s		LAB_1392			* if it is "0" to "9" save it and get another
                            	   973: 
01:0000C318 7ADF            	   974: 	MOVEQ		#-33,d5			* mask xx0x xxxx, ASCII upper case
01:0000C31A CA00            	   975: 	AND.b		d0,d5				* mask the character
                            	   976: 
01:0000C31C BA3C0041        	   977: 	CMP.b		#'A',d5			* compare with "A"
01:0000C320 6540            	   978: 	BCS.s		LAB_13CC			* if < "A" quit the hex save loop
                            	   979: 
01:0000C322 BA3C0046        	   980: 	CMP.b		#'F',d5			* compare with "F"
01:0000C326 63CE            	   981: 	BLS.s		LAB_1392			* if it is "A" to "F" save it and get another
                            	   982: 
01:0000C328 6038            	   983: 	BRA.s		LAB_13CC			* else continue crunching
                            	   984: 
                            	   985: * crunch keywords into Basic tokens
                            	   986: * crunch from (a5), output to (a0)
                            	   987: * returns ..
                            	   988: * d4 trashed
                            	   989: * d3 trashed
                            	   990: * d2 is length
                            	   991: * d1 trashed
                            	   992: * d0 trashed
                            	   993: * a1 trashed
                            	   994: 
                            	   995: * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
                            	   996: * old list search
                            	   997: 
                            	   998: LAB_13A6
01:0000C32A 7200            	   999: 	MOVEQ		#0,d1				* clear the read index
01:0000C32C 2401            	  1000: 	MOVE.l	d1,d2				* clear the save index
01:0000C32E 174105DD        	  1001: 	MOVE.b	d1,Oquote(a3)		* clear the open quote/DATA flag
                            	  1002: LAB_13AC
01:0000C332 7000            	  1003: 	MOVEQ		#0,d0				* clear word
01:0000C334 10351000        	  1004: 	MOVE.b	(a5,d1.w),d0		* get byte from input buffer
01:0000C338 675E            	  1005: 	BEQ.s		LAB_13EC			* if null save byte then continue crunching
                            	  1006: 
01:0000C33A B03C005F        	  1007: 	CMP.b		#'_',d0			* compare with "_"
01:0000C33E 6458            	  1008: 	BCC.s		LAB_13EC			* if >= "_" save byte then continue crunching
                            	  1009: 
01:0000C340 B03C003C        	  1010: 	CMP.b		#'<',d0			* compare with "<"
01:0000C344 641C            	  1011: 	BCC.s		LAB_13CC			* if >= "<" go crunch
                            	  1012: 
01:0000C346 B03C0030        	  1013: 	CMP.b		#'0',d0			* compare with "0"
01:0000C34A 644C            	  1014: 	BCC.s		LAB_13EC			* if >= "0" save byte then continue crunching
                            	  1015: 
01:0000C34C 174005DA        	  1016: 	MOVE.b	d0,Asrch(a3)		* save buffer byte as search character
01:0000C350 B03C0022        	  1017: 	CMP.b		#$22,d0			* is it quote character?
01:0000C354 6776            	  1018: 	BEQ.s		LAB_1410			* branch if so (copy quoted string)
                            	  1019: 
01:0000C356 B03C0024        	  1020: 	CMP.b		#'$',d0			* is it the hex value character?
01:0000C35A 679A            	  1021: 	BEQ.s		LAB_1392			* if so go copy a hex value
                            	  1022: 
                            	  1023: LAB_13C6
01:0000C35C B03C002A        	  1024: 	CMP.b		#'*',d0			* compare with "*"
01:0000C360 6536            	  1025: 	BCS.s		LAB_13EC			* if <= "*" save byte then continue crunching
                            	  1026: 
                            	  1027: 							* crunch rest
                            	  1028: LAB_13CC
01:0000C362 082B000605DD    	  1029: 	BTST.b	#6,Oquote(a3)		* test open quote/DATA token flag
01:0000C368 662E            	  1030: 	BNE.s		LAB_13EC			* branch if b6 of Oquote set (was DATA)
                            	  1031: 							* go save byte then continue crunching
                            	  1032: 
01:0000C36A 903C002A        	  1033: 	SUB.b		#$2A,d0			* normalise byte
01:0000C36E D040            	  1034: 	ADD.w		d0,d0				* *2 makes word offset (high byte=$00)
01:0000C370 43FA2BEC        	  1035: 	LEA		TAB_CHRT(pc),a1		* get keyword offset table address
01:0000C374 30310000        	  1036: 	MOVE.w	(a1,d0.w),d0		* get offset into keyword table
01:0000C378 6B6E            	  1037: 	BMI.s		LAB_141F			* branch if no keywords for character
                            	  1038: 
01:0000C37A 43FA2F78        	  1039: 	LEA		TAB_STAR(pc),a1		* get keyword table address
01:0000C37E D2C0            	  1040: 	ADDA.w	d0,a1				* add keyword offset
01:0000C380 76FF            	  1041: 	MOVEQ		#-1,d3			* clear index
01:0000C382 3801            	  1042: 	MOVE.w	d1,d4				* copy read index
                            	  1043: LAB_13D6
01:0000C384 5243            	  1044: 	ADDQ.w	#1,d3				* increment table index
01:0000C386 10313000        	  1045: 	MOVE.b	(a1,d3.w),d0		* get byte from table
                            	  1046: LAB_13D8
01:0000C38A 6B0A            	  1047: 	BMI.s		LAB_13EA			* branch if token, save token and continue
                            	  1048: 							* crunching
                            	  1049: 
01:0000C38C 5244            	  1050: 	ADDQ.w	#1,d4				* increment read index
01:0000C38E B0354000        	  1051: 	CMP.b		(a5,d4.w),d0		* compare byte from input buffer
01:0000C392 67F0            	  1052: 	BEQ.s		LAB_13D6			* loop if character match
                            	  1053: 
01:0000C394 6040            	  1054: 	BRA.s		LAB_1417			* branch if no match
                            	  1055: 
                            	  1056: LAB_13EA
01:0000C396 3204            	  1057: 	MOVE.w	d4,d1				* update read index
                            	  1058: LAB_13EC
01:0000C398 11802000        	  1059: 	MOVE.b	d0,(a0,d2.w)		* save byte to output
01:0000C39C 5242            	  1060: 	ADDQ.w	#1,d2				* increment buffer save index
01:0000C39E 5241            	  1061: 	ADDQ.w	#1,d1				* increment buffer read index
01:0000C3A0 4A00            	  1062: 	TST.b		d0				* set flags
01:0000C3A2 674A            	  1063: 	BEQ.s		LAB_142A			* branch if was null [EOL]
                            	  1064: 
                            	  1065: 							* d0 holds token or byte here
01:0000C3A4 903C003A        	  1066: 	SUB.b		#$3A,d0			* subtract ":"
01:0000C3A8 6706            	  1067: 	BEQ.s		LAB_13FF			* branch if it was ":" (is now $00)
                            	  1068: 
                            	  1069: 							* d0 now holds token-$3A
01:0000C3AA B03C0049        	  1070: 	CMP.b		#(TK_DATA-$3A),d0		* compare with DATA token - $3A
01:0000C3AE 6604            	  1071: 	BNE.s		LAB_1401			* branch if not DATA
                            	  1072: 
                            	  1073: 							* token was : or DATA
                            	  1074: LAB_13FF
01:0000C3B0 174005DD        	  1075: 	MOVE.b	d0,Oquote(a3)		* save token-$3A ($00 for ":", TK_DATA-$3A for
                            	  1076: 							* DATA)
                            	  1077: LAB_1401
01:0000C3B4 903C0055        	  1078: 	SUB.b		#(TK_REM-$3A),d0		* subtract REM token offset
01:0000C3B8 6600FF78        	  1079: 	BNE		LAB_13AC			* If wasn't REM then go crunch rest of line
                            	  1080: 
01:0000C3BC 174005DA        	  1081: 	MOVE.b	d0,Asrch(a3)		* else was REM so set search for [EOL]
                            	  1082: 
                            	  1083: 							* loop for REM, "..." etc.
                            	  1084: LAB_1408
01:0000C3C0 10351000        	  1085: 	MOVE.b	(a5,d1.w),d0		* get byte from input buffer
01:0000C3C4 67D2            	  1086: 	BEQ.s		LAB_13EC			* branch if null [EOL]
                            	  1087: 
01:0000C3C6 B02B05DA        	  1088: 	CMP.b		Asrch(a3),d0		* compare with stored character
01:0000C3CA 67CC            	  1089: 	BEQ.s		LAB_13EC			* branch if match (end quote, REM, :, or DATA)
                            	  1090: 
                            	  1091: 							* entry for copy string in quotes, don't crunch
                            	  1092: LAB_1410
01:0000C3CC 11802000        	  1093: 	MOVE.b	d0,(a0,d2.w)		* save byte to output
01:0000C3D0 5242            	  1094: 	ADDQ.w	#1,d2				* increment buffer save index
01:0000C3D2 5241            	  1095: 	ADDQ.w	#1,d1				* increment buffer read index
01:0000C3D4 60EA            	  1096: 	BRA.s		LAB_1408			* loop
                            	  1097: 
                            	  1098: * not found keyword this go so find the end of this word in the table
                            	  1099: 
                            	  1100: LAB_1417
01:0000C3D6 3801            	  1101: 	MOVE.w	d1,d4				* reset read pointer
                            	  1102: LAB_141B
01:0000C3D8 5243            	  1103: 	ADDQ.w	#1,d3				* increment keyword table pointer, flag
                            	  1104: 							* unchanged
01:0000C3DA 10313000        	  1105: 	MOVE.b	(a1,d3.w),d0		* get keyword table byte
01:0000C3DE 6AF8            	  1106: 	BPL.s		LAB_141B			* if not end of keyword go do next byte
                            	  1107: 
01:0000C3E0 5243            	  1108: 	ADDQ.w	#1,d3				* increment keyword table pointer flag
                            	  1109: 							* unchanged
01:0000C3E2 10313000        	  1110: 	MOVE.b	(a1,d3.w),d0		* get keyword table byte
01:0000C3E6 66A2            	  1111: 	BNE.s		LAB_13D8			* go test next word if not zero byte (table end)
                            	  1112: 
                            	  1113: 							* reached end of table with no match
                            	  1114: LAB_141F
01:0000C3E8 10351000        	  1115: 	MOVE.b	(a5,d1.w),d0		* restore byte from input buffer
01:0000C3EC 60AA            	  1116: 	BRA.s		LAB_13EC			* go save byte in output and continue crunching
                            	  1117: 
                            	  1118: 							* reached [EOL]
                            	  1119: LAB_142A
01:0000C3EE 7000            	  1120: 	MOVEQ		#0,d0				* ensure longword clear
01:0000C3F0 0102            	  1121: 	BTST		d0,d2				* test odd bit (fastest)
01:0000C3F2 6706            	  1122: 	BEQ.s		LAB_142C			* branch if no bytes to fill
                            	  1123: 
01:0000C3F4 11802000        	  1124: 	MOVE.b	d0,(a0,d2.w)		* clear next byte
01:0000C3F8 5242            	  1125: 	ADDQ.w	#1,d2				* increment buffer save index
                            	  1126: LAB_142C
01:0000C3FA 21802000        	  1127: 	MOVE.l	d0,(a0,d2.w)		* clear next line pointer, EOT in immediate mode
01:0000C3FE 4E75            	  1128: 	RTS
                            	  1129: 
                            	  1130: 
                            	  1131: *************************************************************************************
                            	  1132: *
                            	  1133: * search Basic for d1 line number from start of mem
                            	  1134: 
                            	  1135: LAB_SSLN
01:0000C400 206B042E        	  1136: 	MOVEA.l	Smeml(a3),a0		* get start of program mem
01:0000C404 6002            	  1137: 	BRA.s		LAB_SCLN			* go search for required line from a0
                            	  1138: 
                            	  1139: LAB_145F
01:0000C406 2040            	  1140: 	MOVEA.l	d0,a0				* copy next line pointer
                            	  1141: 
                            	  1142: * search Basic for d1 line number from a0
                            	  1143: * returns Cb=0 if found
                            	  1144: * returns a0 pointer to found or next higher (not found) line
                            	  1145: 
                            	  1146: LAB_SCLN
01:0000C408 2018            	  1147: 	MOVE.l	(a0)+,d0			* get next line pointer and point to line #
01:0000C40A 6708            	  1148: 	BEQ.s		LAB_145E			* is end marker so we're done, do 'no line' exit
                            	  1149: 
01:0000C40C B290            	  1150: 	CMP.l		(a0),d1			* compare this line # with required line #
01:0000C40E 6EF6            	  1151: 	BGT.s		LAB_145F			* loop if required # > this #
                            	  1152: 
01:0000C410 5948            	  1153: 	SUBQ.w	#4,a0				* adjust pointer, flags not changed
01:0000C412 4E75            	  1154: 	RTS
                            	  1155: 
                            	  1156: LAB_145E
01:0000C414 5948            	  1157: 	SUBQ.w	#4,a0				* adjust pointer, flags not changed
01:0000C416 5380            	  1158: 	SUBQ.l	#1,d0				* make end program found = -1, set carry
01:0000C418 4E75            	  1159: 	RTS
                            	  1160: 
                            	  1161: 
                            	  1162: *************************************************************************************
                            	  1163: *
                            	  1164: * perform NEW
                            	  1165: 
                            	  1166: LAB_NEW
01:0000C41A 664C            	  1167: 	BNE.s		RTS_005			* exit if not end of statement (do syntax error)
                            	  1168: 
                            	  1169: LAB_1463
01:0000C41C 206B042E        	  1170: 	MOVEA.l	Smeml(a3),a0		* point to start of program memory
01:0000C420 7000            	  1171: 	MOVEQ		#0,d0				* clear longword
01:0000C422 20C0            	  1172: 	MOVE.l	d0,(a0)+			* clear first line, next line pointer
01:0000C424 27480432        	  1173: 	MOVE.l	a0,Sfncl(a3)		* set start of functions
                            	  1174: 
                            	  1175: * reset execution to start, clear variables and flush stack
                            	  1176: 
                            	  1177: LAB_1477
01:0000C428 2A6B042E        	  1178: 	MOVEA.l	Smeml(a3),a5		* reset BASIC execute pointer
01:0000C42C 534D            	  1179: 	SUBQ.w	#1,a5				* -1 (as end of previous line)
                            	  1180: 
                            	  1181: * "CLEAR" command gets here
                            	  1182: 
                            	  1183: LAB_147A
01:0000C42E 276B044A0446    	  1184: 	MOVE.l	Ememl(a3),Sstorl(a3)	* save end of mem as bottom of string space
01:0000C434 202B0432        	  1185: 	MOVE.l	Sfncl(a3),d0		* get start of functions
01:0000C438 27400436        	  1186: 	MOVE.l	d0,Svarl(a3)		* start of variables
01:0000C43C 2740043A        	  1187: 	MOVE.l	d0,Sstrl(a3)		* start of strings
01:0000C440 2740043E        	  1188: 	MOVE.l	d0,Sarryl(a3)		* set start of arrays
01:0000C444 27400442        	  1189: 	MOVE.l	d0,Earryl(a3)		* set end of arrays
                            	  1190: LAB_1480
01:0000C448 7000            	  1191: 	MOVEQ		#0,d0				* set Zb
01:0000C44A 174005EA        	  1192: 	MOVE.b	d0,ccnull(a3)		* clear get byte countdown
01:0000C44E 610001CC        	  1193: 	BSR		LAB_RESTORE			* perform RESTORE command
                            	  1194: 
                            	  1195: * flush stack & clear continue flag
                            	  1196: 
                            	  1197: LAB_1491
01:0000C452 49EB048E        	  1198: 	LEA		des_sk(a3),a4		* reset descriptor stack pointer
                            	  1199: 
01:0000C456 201F            	  1200: 	MOVE.l	(sp)+,d0			* pull return address
01:0000C458 4FEB0400        	  1201: 	LEA		ram_base(a3),sp		* set stack to RAM start + 1k, flush stack
01:0000C45C 2F00            	  1202: 	MOVE.l	d0,-(sp)			* restore return address
                            	  1203: 
01:0000C45E 7000            	  1204: 	MOVEQ		#0,d0				* clear longword
01:0000C460 2740045A        	  1205: 	MOVE.l	d0,Cpntrl(a3)		* clear continue pointer
01:0000C464 174005DF        	  1206: 	MOVE.b	d0,Sufnxf(a3)		* clear subscript/FNX flag
                            	  1207: RTS_005
01:0000C468 4E75            	  1208: 	RTS
                            	  1209: 
                            	  1210: 
                            	  1211: *************************************************************************************
                            	  1212: *
                            	  1213: * perform CLEAR
                            	  1214: 
                            	  1215: LAB_CLEAR
01:0000C46A 67C2            	  1216: 	BEQ.s		LAB_147A			* if no following byte go do "CLEAR"
                            	  1217: 
01:0000C46C 4E75            	  1218: 	RTS						* was following byte (go do syntax error)
                            	  1219: 
                            	  1220: 
                            	  1221: *************************************************************************************
                            	  1222: *
                            	  1223: * perform LIST [n][-m]
                            	  1224: 
                            	  1225: LAB_LIST
01:0000C46E 6512            	  1226: 	BCS.s		LAB_14BD			* branch if next character numeric (LIST n...)
                            	  1227: 
01:0000C470 72FF            	  1228: 	MOVEQ		#-1,d1			* set end to $FFFFFFFF
01:0000C472 2741042A        	  1229: 	MOVE.l	d1,Itemp(a3)		* save to Itemp
                            	  1230: 
01:0000C476 7200            	  1231: 	MOVEQ		#0,d1				* set start to $00000000
01:0000C478 4A00            	  1232: 	TST.b		d0				* test next byte
01:0000C47A 670A            	  1233: 	BEQ.s		LAB_14C0			* branch if next character [NULL] (LIST)
                            	  1234: 
01:0000C47C B03C00B3        	  1235: 	CMP.b		#TK_MINUS,d0		* compare with token for -
01:0000C480 66E6            	  1236: 	BNE.s		RTS_005			* exit if not - (LIST -m)
                            	  1237: 
                            	  1238: 							* LIST [[n]-[m]] this sets the n, if present,
                            	  1239: 							* as the start and end
                            	  1240: LAB_14BD
01:0000C482 61000390        	  1241: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
                            	  1242: LAB_14C0
01:0000C486 6100FF78        	  1243: 	BSR		LAB_SSLN			* search BASIC for d1 line number
                            	  1244: 							* (pointer in a0)
01:0000C48A 61000932        	  1245: 	BSR		LAB_GBYT			* scan memory
01:0000C48E 6716            	  1246: 	BEQ.s		LAB_14D4			* branch if no more characters
                            	  1247: 
                            	  1248: 							* this bit checks the - is present
01:0000C490 B03C00B3        	  1249: 	CMP.b		#TK_MINUS,d0		* compare with token for -
01:0000C494 66D2            	  1250: 	BNE.s		RTS_005			* return if not "-" (will be Syntax error)
                            	  1251: 
01:0000C496 72FF            	  1252: 	MOVEQ		#-1,d1			* set end to $FFFFFFFF
01:0000C498 2741042A        	  1253: 	MOVE.l	d1,Itemp(a3)		* save Itemp
                            	  1254: 
                            	  1255: 							* LIST [n]-[m] the - was there so see if
                            	  1256: 							* there is an m to set as the end value
01:0000C49C 6100091E        	  1257: 	BSR		LAB_IGBY			* increment & scan memory
01:0000C4A0 6704            	  1258: 	BEQ.s		LAB_14D4			* branch if was [NULL] (LIST n-)
                            	  1259: 
01:0000C4A2 61000370        	  1260: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
                            	  1261: LAB_14D4
01:0000C4A6 177C000005DD    	  1262: 	MOVE.b	#$00,Oquote(a3)		* clear open quote flag
01:0000C4AC 610004E6        	  1263: 	BSR		LAB_CRLF			* print CR/LF
01:0000C4B0 2018            	  1264: 	MOVE.l	(a0)+,d0			* get next line pointer
01:0000C4B2 67B4            	  1265: 	BEQ.s		RTS_005			* if null all done so exit
                            	  1266: 
01:0000C4B4 2240            	  1267: 	MOVEA.l	d0,a1				* copy next line pointer
01:0000C4B6 6100012A        	  1268: 	BSR		LAB_1629			* do CRTL-C check vector
                            	  1269: 
01:0000C4BA 2018            	  1270: 	MOVE.l	(a0)+,d0			* get this line #
01:0000C4BC B0AB042A        	  1271: 	CMP.l		Itemp(a3),d0		* compare end line # with this line #
01:0000C4C0 62A6            	  1272: 	BHI.s		RTS_005			* if this line greater all done so exit
                            	  1273: 
                            	  1274: LAB_14E2
01:0000C4C2 48E700C0        	  1275: 	MOVEM.l	a0-a1,-(sp)			* save registers
01:0000C4C6 61001800        	  1276: 	BSR		LAB_295E			* print d0 as unsigned integer
01:0000C4CA 4CDF0300        	  1277: 	MOVEM.l	(sp)+,a0-a1			* restore registers
01:0000C4CE 7020            	  1278: 	MOVEQ		#$20,d0			* space is the next character
                            	  1279: LAB_150C
01:0000C4D0 6100053A        	  1280: 	BSR		LAB_PRNA			* go print the character
01:0000C4D4 B03C0022        	  1281: 	CMP.b		#$22,d0			* was it " character
01:0000C4D8 6604            	  1282: 	BNE.s		LAB_1519			* branch if not
                            	  1283: 
                            	  1284: 							* we're either entering or leaving quotes
01:0000C4DA 462B05DD        	  1285: 	EOR.b		#$FF,Oquote(a3)		* toggle open quote flag
                            	  1286: LAB_1519
01:0000C4DE 1018            	  1287: 	MOVE.b	(a0)+,d0			* get byte and increment pointer
01:0000C4E0 6608            	  1288: 	BNE.s		LAB_152E			* branch if not [EOL] (go print)
                            	  1289: 
                            	  1290: 							* was [EOL]
01:0000C4E2 2049            	  1291: 	MOVEA.l	a1,a0				* copy next line pointer
01:0000C4E4 2008            	  1292: 	MOVE.l	a0,d0				* copy to set flags
01:0000C4E6 66BE            	  1293: 	BNE.s		LAB_14D4			* go do next line if not [EOT]
                            	  1294: 
01:0000C4E8 4E75            	  1295: 	RTS
                            	  1296: 
                            	  1297: LAB_152E
01:0000C4EA 6AE4            	  1298: 	BPL.s		LAB_150C			* just go print it if not token byte
                            	  1299: 
                            	  1300: 							* else it was a token byte so maybe uncrunch it
01:0000C4EC 4A2B05DD        	  1301: 	TST.b		Oquote(a3)			* test the open quote flag
01:0000C4F0 6BDE            	  1302: 	BMI.s		LAB_150C			* just go print character if open quote set
                            	  1303: 
                            	  1304: 							* else uncrunch BASIC token
01:0000C4F2 45FA2AD4        	  1305: 	LEA		LAB_KEYT(pc),a2		* get keyword table address
01:0000C4F6 727F            	  1306: 	MOVEQ		#$7F,d1			* mask into d1
01:0000C4F8 C200            	  1307: 	AND.b		d0,d1				* copy and mask token
01:0000C4FA E549            	  1308: 	LSL.w		#2,d1				* *4
01:0000C4FC 45F21000        	  1309: 	LEA		(a2,d1.w),a2		* get keyword entry address
01:0000C500 101A            	  1310: 	MOVE.b	(a2)+,d0			* get byte from keyword table
01:0000C502 61000508        	  1311: 	BSR		LAB_PRNA			* go print the first character
01:0000C506 7200            	  1312: 	MOVEQ		#0,d1				* clear d1
01:0000C508 121A            	  1313: 	MOVE.b	(a2)+,d1			* get remaining length byte from keyword table
01:0000C50A 6BD2            	  1314: 	BMI.s		LAB_1519			* if -ve done so go get next byte
                            	  1315: 
01:0000C50C 3012            	  1316: 	MOVE.w	(a2),d0			* get offset to rest
01:0000C50E 45FA2DE4        	  1317: 	LEA		TAB_STAR(pc),a2		* get keyword table address
01:0000C512 45F20000        	  1318: 	LEA		(a2,d0.w),a2		* get address of rest
                            	  1319: LAB_1540
01:0000C516 101A            	  1320: 	MOVE.b	(a2)+,d0			* get byte from keyword table
01:0000C518 610004F2        	  1321: 	BSR		LAB_PRNA			* go print the character
01:0000C51C 51C9FFF8        	  1322: 	DBF		d1,LAB_1540			* decrement and loop if more to do
                            	  1323: 
01:0000C520 60BC            	  1324: 	BRA.s		LAB_1519			* go get next byte
                            	  1325: 
                            	  1326: 
                            	  1327: *************************************************************************************
                            	  1328: *
                            	  1329: * perform FOR
                            	  1330: 
                            	  1331: LAB_FOR
01:0000C522 61000390        	  1332: 	BSR		LAB_LET			* go do LET
                            	  1333: 
01:0000C526 202B0472        	  1334: 	MOVE.l	Lvarpl(a3),d0		* get the loop variable pointer
01:0000C52A B0AB043A        	  1335: 	CMP.l		Sstrl(a3),d0		* compare it with the end of vars memory
01:0000C52E 6C00FC24        	  1336: 	BGE		LAB_TMER			* if greater go do type mismatch error
                            	  1337: 
                            	  1338: * test for not less than the start of variables memory if needed
                            	  1339: *
                            	  1340: *	CMP.l		Svarl(a3),d0		* compare it with the start of variables memory
                            	  1341: *	BLT		LAB_TMER			* if not variables memory do type mismatch error
                            	  1342: 
                            	  1343: *	MOVEQ		#28,d0			* we need 28 bytes !
                            	  1344: *	BSR.s		LAB_1212			* check room on stack for d0 bytes
                            	  1345: 
01:0000C532 61000214        	  1346: 	BSR		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
                            	  1347: 							* returns a0 as pointer to [:] or [EOL]
01:0000C536 2E88            	  1348: 	MOVE.l	a0,(sp)			* push onto stack (and dump the return address)
01:0000C538 2F2B0452        	  1349: 	MOVE.l	Clinel(a3),-(sp)		* push current line onto stack
                            	  1350: 
01:0000C53C 70AA            	  1351: 	MOVEQ		#TK_TO-$100,d0		* set "TO" token
01:0000C53E 61000874        	  1352: 	BSR		LAB_SCCA			* scan for CHR$(d0) else syntax error/warm start
01:0000C542 61000702        	  1353: 	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
01:0000C546 1F2B05B5        	  1354: 	MOVE.b	Dtypef(a3),-(sp)		* push the FOR variable data type onto stack
01:0000C54A 610006F8        	  1355: 	BSR		LAB_EVNM			* evaluate expression and check is numeric else
                            	  1356: 							* do type mismatch
                            	  1357: 
01:0000C54E 2F2B0590        	  1358: 	MOVE.l	FAC1_m(a3),-(sp)		* push TO value mantissa
01:0000C552 3F2B0594        	  1359: 	MOVE.w	FAC1_e(a3),-(sp)		* push TO value exponent and sign
                            	  1360: 
01:0000C556 277C800000000590	  1361: 	MOVE.l	#$80000000,FAC1_m(a3)	* set default STEP size mantissa
01:0000C55E 377C81000594    	  1362: 	MOVE.w	#$8100,FAC1_e(a3)		* set default STEP size exponent and sign
                            	  1363: 
01:0000C564 61000858        	  1364: 	BSR		LAB_GBYT			* scan memory
01:0000C568 B03C00AF        	  1365: 	CMP.b		#TK_STEP,d0			* compare with STEP token
01:0000C56C 6608            	  1366: 	BNE.s		LAB_15B3			* jump if not "STEP"
                            	  1367: 
                            	  1368: 							* was STEP token so ....
01:0000C56E 6100084C        	  1369: 	BSR		LAB_IGBY			* increment & scan memory
01:0000C572 610006D0        	  1370: 	BSR		LAB_EVNM			* evaluate expression & check is numeric
                            	  1371: 							* else do type mismatch
                            	  1372: LAB_15B3
01:0000C576 2F2B0590        	  1373: 	MOVE.l	FAC1_m(a3),-(sp)		* push STEP value mantissa
01:0000C57A 3F2B0594        	  1374: 	MOVE.w	FAC1_e(a3),-(sp)		* push STEP value exponent and sign
                            	  1375: 
01:0000C57E 2F2B0472        	  1376: 	MOVE.l	Lvarpl(a3),-(sp)		* push variable pointer for FOR/NEXT
01:0000C582 3F3C0081        	  1377: 	MOVE.w	#TK_FOR,-(sp)		* push FOR token on stack
                            	  1378: 
01:0000C586 6018            	  1379: 	BRA.s		LAB_15C2			* go do interpreter inner loop
                            	  1380: 
                            	  1381: LAB_15DC						* have reached [EOL]+1
01:0000C588 300D            	  1382: 	MOVE.w	a5,d0				* copy BASIC execute pointer
01:0000C58A C07C0001        	  1383: 	AND.w		#1,d0				* and make line start address even
01:0000C58E DAC0            	  1384: 	ADD.w		d0,a5				* add to BASIC execute pointer
01:0000C590 201D            	  1385: 	MOVE.l	(a5)+,d0			* get next line pointer
01:0000C592 6700FC1C        	  1386: 	BEQ		LAB_1274			* if null go to immediate mode, no "BREAK"
                            	  1387: 							* message (was immediate or [EOT] marker)
                            	  1388: 
01:0000C596 275D0452        	  1389: 	MOVE.l	(a5)+,Clinel(a3)		* save (new) current line #
                            	  1390: LAB_15F6
01:0000C59A 61000822        	  1391: 	BSR		LAB_GBYT			* get BASIC byte
01:0000C59E 611A            	  1392: 	BSR.s		LAB_15FF			* go interpret BASIC code from (a5)
                            	  1393: 
                            	  1394: * interpreter inner loop (re)entry point
                            	  1395: 
                            	  1396: LAB_15C2
01:0000C5A0 6140            	  1397: 	BSR.s		LAB_1629			* do CRTL-C check vector
01:0000C5A2 4A2B0452        	  1398: 	TST.b		Clinel(a3)			* test current line #, is -ve for immediate mode
01:0000C5A6 6B04            	  1399: 	BMI.s		LAB_15D1			* branch if immediate mode
                            	  1400: 
01:0000C5A8 274D045A        	  1401: 	MOVE.l	a5,Cpntrl(a3)		* save BASIC execute pointer as continue pointer
                            	  1402: LAB_15D1
01:0000C5AC 101D            	  1403: 	MOVE.b	(a5)+,d0			* get this byte & increment pointer
01:0000C5AE 67D8            	  1404: 	BEQ.s		LAB_15DC			* loop if [EOL]
                            	  1405: 
01:0000C5B0 B03C003A        	  1406: 	CMP.b		#$3A,d0			* compare with ":"
01:0000C5B4 67E4            	  1407: 	BEQ.s		LAB_15F6			* loop if was statement separator
                            	  1408: 
01:0000C5B6 6000FBC8        	  1409: 	BRA		LAB_SNER			* else syntax error, then warm start
                            	  1410: 
                            	  1411: 
                            	  1412: *************************************************************************************
                            	  1413: *
                            	  1414: * interpret BASIC code from (a5)
                            	  1415: 
                            	  1416: LAB_15FF
01:0000C5BA 6700008C        	  1417: 	BEQ		RTS_006			* exit if zero [EOL]
                            	  1418: 
                            	  1419: LAB_1602
01:0000C5BE 0A000080        	  1420: 	EORI.b	#$80,d0			* normalise token
01:0000C5C2 6B0002F0        	  1421: 	BMI		LAB_LET			* if not token, go do implied LET
                            	  1422: 
01:0000C5C6 B03C0028        	  1423: 	CMP.b		#(TK_TAB-$80),d0		* compare normalised token with TAB
01:0000C5CA 6400FBB4        	  1424: 	BCC		LAB_SNER			* branch if d0>=TAB, syntax error/warm start
                            	  1425: 							* only tokens before TAB can start a statement
                            	  1426: 
01:0000C5CE 4880            	  1427: 	EXT.w		d0				* byte to word (clear high byte)
01:0000C5D0 D040            	  1428: 	ADD.w		d0,d0				* *2
01:0000C5D2 41FA2852        	  1429: 	LEA		LAB_CTBL(pc),a0		* get vector table base address
01:0000C5D6 30300000        	  1430: 	MOVE.w	(a0,d0.w),d0		* get offset to vector
01:0000C5DA 48700000        	  1431: 	PEA		(a0,d0.w)			* push vector
01:0000C5DE 600007DC        	  1432: 	BRA		LAB_IGBY			* get following byte & execute vector
                            	  1433: 
                            	  1434: 
                            	  1435: *************************************************************************************
                            	  1436: *
                            	  1437: * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
                            	  1438: * key press is detected.
                            	  1439: 
                            	  1440: LAB_1629
01:0000C5E2 4EEB0424        	  1441: 	JMP		V_CTLC(a3)			* ctrl c check vector
                            	  1442: 
                            	  1443: * if there was a key press it gets back here .....
                            	  1444: 
                            	  1445: LAB_1636
01:0000C5E6 B03C0003        	  1446: 	CMP.b		#$03,d0			* compare with CTRL-C
01:0000C5EA 670C            	  1447: 	BEQ.s		LAB_163B			* STOP if was CTRL-C
                            	  1448: 
                            	  1449: LAB_1639
01:0000C5EC 4E75            	  1450: 	RTS						*
                            	  1451: 
                            	  1452: 
                            	  1453: *************************************************************************************
                            	  1454: *
                            	  1455: * perform END
                            	  1456: 
                            	  1457: LAB_END
01:0000C5EE 66FC            	  1458: 	BNE.s		LAB_1639			* exit if something follows STOP
01:0000C5F0 177C000005DC    	  1459: 	MOVE.b	#0,Breakf(a3)		* clear break flag, indicate program end
                            	  1460: 
                            	  1461: 
                            	  1462: *************************************************************************************
                            	  1463: *
                            	  1464: * perform STOP
                            	  1465: 
                            	  1466: LAB_STOP
01:0000C5F6 66F4            	  1467: 	BNE.s		LAB_1639			* exit if something follows STOP
                            	  1468: 
                            	  1469: LAB_163B
01:0000C5F8 43EB0590        	  1470: 	LEA		Ibuffe(a3),a1		* get buffer end
01:0000C5FC BBC9            	  1471: 	CMPA.l	a1,a5				* compare execute address with buffer end
01:0000C5FE 650A            	  1472: 	BCS.s		LAB_164F			* branch if BASIC pointer is in buffer
                            	  1473: 							* can't continue in immediate mode
                            	  1474: 
                            	  1475: 							* else...
01:0000C600 274D045A        	  1476: 	MOVE.l	a5,Cpntrl(a3)		* save BASIC execute pointer as continue pointer
                            	  1477: LAB_1647
01:0000C604 276B04520456    	  1478: 	MOVE.l	Clinel(a3),Blinel(a3)	* save break line
                            	  1479: LAB_164F
01:0000C60A 584F            	  1480: 	ADDQ.w	#4,sp				* dump return address, don't return to execute
                            	  1481: 							* loop
01:0000C60C 102B05DC        	  1482: 	MOVE.b	Breakf(a3),d0		* get break flag
01:0000C610 6700FB9E        	  1483: 	BEQ		LAB_1274			* go do warm start if was program end
                            	  1484: 
01:0000C614 41FA2E89        	  1485: 	LEA		LAB_BMSG(pc),a0		* point to "Break"
01:0000C618 6000FB88        	  1486: 	BRA		LAB_1269			* print "Break" and do warm start
                            	  1487: 
                            	  1488: 
                            	  1489: *************************************************************************************
                            	  1490: *
                            	  1491: * perform RESTORE
                            	  1492: 
                            	  1493: LAB_RESTORE
01:0000C61C 206B042E        	  1494: 	MOVEA.l	Smeml(a3),a0		* copy start of memory
01:0000C620 6720            	  1495: 	BEQ.s		LAB_1624			* branch if next character null (RESTORE)
                            	  1496: 
01:0000C622 610001F0        	  1497: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
01:0000C626 B2AB0452        	  1498: 	CMP.l		Clinel(a3),d1		* compare current line # with required line #
01:0000C62A 630E            	  1499: 	BLS.s		LAB_GSCH			* branch if >= (start search from beginning)
                            	  1500: 
01:0000C62C 204D            	  1501: 	MOVEA.l	a5,a0				* copy BASIC execute pointer
                            	  1502: LAB_RESs
01:0000C62E 4A18            	  1503: 	TST.b		(a0)+				* test next byte & increment pointer
01:0000C630 66FC            	  1504: 	BNE.s		LAB_RESs			* loop if not EOL
                            	  1505: 
01:0000C632 3008            	  1506: 	MOVE.w	a0,d0				* copy pointer
01:0000C634 C07C0001        	  1507: 	AND.w		#1,d0				* mask odd bit
01:0000C638 D0C0            	  1508: 	ADD.w		d0,a0				* add pointer
                            	  1509: 							* search for line in Itemp from (a0)
                            	  1510: LAB_GSCH
01:0000C63A 6100FDCC        	  1511: 	BSR		LAB_SCLN			* search for d1 line number from a0
                            	  1512: 							* returns Cb=0 if found
01:0000C63E 6500FB28        	  1513: 	BCS		LAB_USER			* go do "Undefined statement" error if not found
                            	  1514: 
                            	  1515: LAB_1624
01:0000C642 4A20            	  1516: 	TST.b		-(a0)				* decrement pointer (faster)
01:0000C644 27480462        	  1517: 	MOVE.l	a0,Dptrl(a3)		* save DATA pointer
                            	  1518: RTS_006
01:0000C648 4E75            	  1519: 	RTS
                            	  1520: 
                            	  1521: 
                            	  1522: *************************************************************************************
                            	  1523: *
                            	  1524: * perform NULL
                            	  1525: 
                            	  1526: LAB_NULL
01:0000C64A 610010D0        	  1527: 	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
01:0000C64E 174005E4        	  1528: 	MOVE.b	d0,Nullct(a3)		* save new NULL count
01:0000C652 4E75            	  1529: 	RTS
                            	  1530: 
                            	  1531: 
                            	  1532: *************************************************************************************
                            	  1533: *
                            	  1534: * perform CONT
                            	  1535: 
                            	  1536: LAB_CONT
01:0000C654 6600FB2A        	  1537: 	BNE		LAB_SNER			* if following byte exit to do syntax error
                            	  1538: 
01:0000C658 4A2B0452        	  1539: 	TST.b		Clinel(a3)			* test current line #, is -ve for immediate mode
01:0000C65C 6A00FAEA        	  1540: 	BPL		LAB_CCER			* if running go do can't continue error
                            	  1541: 
01:0000C660 202B045A        	  1542: 	MOVE.l	Cpntrl(a3),d0		* get continue pointer
01:0000C664 6700FAE2        	  1543: 	BEQ		LAB_CCER			* go do can't continue error if we can't
                            	  1544: 
                            	  1545: 							* we can continue so ...
01:0000C668 2A40            	  1546: 	MOVEA.l	d0,a5				* save continue pointer as BASIC execute pointer
01:0000C66A 276B04560452    	  1547: 	MOVE.l	Blinel(a3),Clinel(a3)	* set break line as current line
01:0000C670 4E75            	  1548: 	RTS
                            	  1549: 
                            	  1550: 
                            	  1551: *************************************************************************************
                            	  1552: *
                            	  1553: * perform RUN
                            	  1554: 
                            	  1555: LAB_RUN
01:0000C672 660C            	  1556: 	BNE.s		LAB_RUNn			* if following byte do RUN n
                            	  1557: 
01:0000C674 6100FDB2        	  1558: 	BSR		LAB_1477			* execution to start, clear vars & flush stack
01:0000C678 274D045A        	  1559: 	MOVE.l	a5,Cpntrl(a3)		* save as continue pointer
01:0000C67C 6000FF22        	  1560: 	BRA		LAB_15C2			* go do interpreter inner loop
                            	  1561: 							* (can't RTS, we flushed the stack!)
                            	  1562: 
                            	  1563: LAB_RUNn
01:0000C680 6100FDAC        	  1564: 	BSR		LAB_147A			* go do "CLEAR"
01:0000C684 601C            	  1565: 	BRA.s		LAB_16B0			* get n and do GOTO n
                            	  1566: 
                            	  1567: 
                            	  1568: *************************************************************************************
                            	  1569: *
                            	  1570: * perform DO
                            	  1571: 
                            	  1572: LAB_DO
                            	  1573: *	MOVE.l	#$05,d0			* need 5 bytes for DO
                            	  1574: *	BSR.s		LAB_1212			* check room on stack for A bytes
01:0000C686 2F0D            	  1575: 	MOVE.l	a5,-(sp)			* push BASIC execute pointer on stack
01:0000C688 2F2B0452        	  1576: 	MOVE.l	Clinel(a3),-(sp)		* push current line on stack
01:0000C68C 3F3C009C        	  1577: 	MOVE.w	#TK_DO,-(sp)		* push token for DO on stack
01:0000C690 487AFF0E        	  1578: 	PEA		LAB_15C2(pc)		* set return address
01:0000C694 60000728        	  1579: 	BRA		LAB_GBYT			* scan memory & return to interpreter inner loop
                            	  1580: 
                            	  1581: 
                            	  1582: *************************************************************************************
                            	  1583: *
                            	  1584: * perform GOSUB
                            	  1585: 
                            	  1586: LAB_GOSUB
                            	  1587: *	MOVE.l	#10,d0			* need 10 bytes for GOSUB
                            	  1588: *	BSR.s		LAB_1212			* check room on stack for d0 bytes
01:0000C698 2F0D            	  1589: 	MOVE.l	a5,-(sp)			* push BASIC execute pointer
01:0000C69A 2F2B0452        	  1590: 	MOVE.l	Clinel(a3),-(sp)		* push current line
01:0000C69E 3F3C008D        	  1591: 	MOVE.w	#TK_GOSUB,-(sp)		* push token for GOSUB
                            	  1592: LAB_16B0
01:0000C6A2 6100071A        	  1593: 	BSR		LAB_GBYT			* scan memory
01:0000C6A6 487AFEF8        	  1594: 	PEA		LAB_15C2(pc)		* return to interpreter inner loop after GOTO n
                            	  1595: 
                            	  1596: * this PEA is needed because either we just cleared the stack and have nowhere to return
                            	  1597: * to or, in the case of GOSUB, we have just dropped a load on the stack and the address
                            	  1598: * we whould have returned to is buried. This burried return address will be unstacked by
                            	  1599: * the corresponding RETURN command
                            	  1600: 
                            	  1601: 
                            	  1602: *************************************************************************************
                            	  1603: *
                            	  1604: * perform GOTO
                            	  1605: 
                            	  1606: LAB_GOTO
01:0000C6AA 61000168        	  1607: 	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
01:0000C6AE 206B042E        	  1608: 	MOVEA.l	Smeml(a3),a0		* get start of memory
01:0000C6B2 B2AB0452        	  1609: 	CMP.l		Clinel(a3),d1		* compare current line with wanted #
01:0000C6B6 630E            	  1610: 	BLS.s		LAB_16D0			* branch if current # => wanted #
                            	  1611: 
01:0000C6B8 204D            	  1612: 	MOVEA.l	a5,a0				* copy BASIC execute pointer
                            	  1613: LAB_GOTs
01:0000C6BA 4A18            	  1614: 	TST.b		(a0)+				* test next byte & increment pointer
01:0000C6BC 66FC            	  1615: 	BNE.s		LAB_GOTs			* loop if not EOL
                            	  1616: 
01:0000C6BE 3008            	  1617: 	MOVE.w	a0,d0				* past pad byte(s)
01:0000C6C0 C07C0001        	  1618: 	AND.w		#1,d0				* mask odd bit
01:0000C6C4 D0C0            	  1619: 	ADD.w		d0,a0				* add to pointer
                            	  1620: 
                            	  1621: LAB_16D0
01:0000C6C6 6100FD40        	  1622: 	BSR		LAB_SCLN			* search for d1 line number from a0
                            	  1623: 							* returns Cb=0 if found
01:0000C6CA 6500FA9C        	  1624: 	BCS		LAB_USER			* if carry set go do "Undefined statement" error
                            	  1625: 
01:0000C6CE 2A48            	  1626: 	MOVEA.l	a0,a5				* copy to basic execute pointer
01:0000C6D0 534D            	  1627: 	SUBQ.w	#1,a5				* decrement pointer
01:0000C6D2 274D045A        	  1628: 	MOVE.l	a5,Cpntrl(a3)		* save as continue pointer
01:0000C6D6 4E75            	  1629: 	RTS
                            	  1630: 
                            	  1631: 
                            	  1632: *************************************************************************************
                            	  1633: *
                            	  1634: * perform LOOP
                            	  1635: 
                            	  1636: LAB_LOOP
01:0000C6D8 0C6F009C0004    	  1637: 	CMP.w		#TK_DO,4(sp)		* compare token on stack with DO token
01:0000C6DE 6600FA60        	  1638: 	BNE		LAB_LDER			* branch if no matching DO
                            	  1639: 
01:0000C6E2 1E00            	  1640: 	MOVE.b	d0,d7				* copy following token (byte)
01:0000C6E4 672E            	  1641: 	BEQ.s		LoopAlways			* if no following token loop forever
                            	  1642: 
01:0000C6E6 BE3C003A        	  1643: 	CMP.b		#':',d7			* compare with ":"
01:0000C6EA 6728            	  1644: 	BEQ.s		LoopAlways			* if no following token loop forever
                            	  1645: 
01:0000C6EC 9E3C00B0        	  1646: 	SUB.b		#TK_UNTIL,d7		* subtract token for UNTIL
01:0000C6F0 6708            	  1647: 	BEQ.s		DoRest			* branch if was UNTIL
                            	  1648: 
01:0000C6F2 5307            	  1649: 	SUBQ.b	#1,d7				* decrement result
01:0000C6F4 6600FA8A        	  1650: 	BNE		LAB_SNER			* if not WHILE go do syntax error & warm start
                            	  1651: 							* only if the token was WHILE will this fail
                            	  1652: 
01:0000C6F8 7EFF            	  1653: 	MOVEQ		#-1,d7			* set invert result longword
                            	  1654: DoRest
01:0000C6FA 610006C0        	  1655: 	BSR		LAB_IGBY			* increment & scan memory
01:0000C6FE 6100055C        	  1656: 	BSR		LAB_EVEX			* evaluate expression
01:0000C702 4A2B0594        	  1657: 	TST.b		FAC1_e(a3)			* test FAC1 exponent
01:0000C706 6706            	  1658: 	BEQ.s		DoCmp				* if = 0 go do straight compare
                            	  1659: 
01:0000C708 177C00FF0594    	  1660: 	MOVE.b	#$FF,FAC1_e(a3)		* else set all bits
                            	  1661: DoCmp
01:0000C70E BF2B0594        	  1662: 	EOR.b		d7,FAC1_e(a3)		* EOR with invert byte
01:0000C712 6614            	  1663: 	BNE.s		LoopDone			* if <> 0 clear stack & back to interpreter loop
                            	  1664: 
                            	  1665: 							* loop condition wasn't met so do it again
                            	  1666: LoopAlways
01:0000C714 276F00060452    	  1667: 	MOVE.l	6(sp),Clinel(a3)		* copy DO current line
01:0000C71A 2A6F000A        	  1668: 	MOVE.l	10(sp),a5			* save BASIC execute pointer
                            	  1669: 
01:0000C71E 41FAFE80        	  1670: 	LEA		LAB_15C2(pc),a0		* get return address
01:0000C722 2E88            	  1671: 	MOVE.l	a0,(sp)			* dump the call to this routine and set the
                            	  1672: 							* return address
01:0000C724 60000698        	  1673: 	BRA		LAB_GBYT			* scan memory and return to interpreter inner
                            	  1674: 							* loop
                            	  1675: 
                            	  1676: 							* clear stack & back to interpreter loop
                            	  1677: LoopDone
01:0000C728 4FEF000E        	  1678: 	LEA		14(sp),sp			* dump structure and call from stack
01:0000C72C 6014            	  1679: 	BRA.s		LAB_DATA			* go perform DATA (find : or [EOL])
                            	  1680: 
                            	  1681: 
                            	  1682: *************************************************************************************
                            	  1683: *
                            	  1684: * perform RETURN
                            	  1685: 
                            	  1686: LAB_RETURN
01:0000C72E 6616            	  1687: 	BNE.s		RTS_007			* exit if following token to allow syntax error
                            	  1688: 
01:0000C730 0C6F008D0004    	  1689: 	CMP.w		#TK_GOSUB,4(sp)		* compare token from stack with GOSUB
01:0000C736 6600FA44        	  1690: 	BNE		LAB_RGER			* do RETURN without GOSUB error if no matching
                            	  1691: 							* GOSUB
                            	  1692: 
01:0000C73A 5C4F            	  1693: 	ADDQ.w	#6,sp				* dump calling address & token
01:0000C73C 275F0452        	  1694: 	MOVE.l	(sp)+,Clinel(a3)		* pull current line
01:0000C740 2A5F            	  1695: 	MOVE.l	(sp)+,a5			* pull BASIC execute pointer
                            	  1696: 							* now do perform "DATA" statement as we could be
                            	  1697: 							* returning into the middle of an ON <var> GOSUB
                            	  1698: 							* n,m,p,q line (the return address used by the
                            	  1699: 							* DATA statement is the one pushed before the
                            	  1700: 							* GOSUB was executed!)
                            	  1701: 
                            	  1702: 
                            	  1703: *************************************************************************************
                            	  1704: *
                            	  1705: * perform DATA
                            	  1706: 
                            	  1707: LAB_DATA
01:0000C742 6104            	  1708: 	BSR.s		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
                            	  1709: 							* returns a0 as pointer to [:] or [EOL]
01:0000C744 2A48            	  1710: 	MOVEA.l	a0,a5				* skip rest of statement
                            	  1711: RTS_007
01:0000C746 4E75            	  1712: 	RTS
                            	  1713: 
                            	  1714: 
                            	  1715: *************************************************************************************
                            	  1716: *
                            	  1717: * scan for next BASIC statement ([:] or [EOL])
                            	  1718: * returns a0 as pointer to [:] or [EOL]
                            	  1719: 
                            	  1720: LAB_SNBS
01:0000C748 204D            	  1721: 	MOVEA.l	a5,a0				* copy BASIC execute pointer
01:0000C74A 7222            	  1722: 	MOVEQ		#$22,d1			* set string quote character
01:0000C74C 743A            	  1723: 	MOVEQ		#$3A,d2			* set look for character = ":"
01:0000C74E 6008            	  1724: 	BRA.s		LAB_172D			* go do search
                            	  1725: 
                            	  1726: LAB_172C
01:0000C750 B400            	  1727: 	CMP.b		d0,d2				* compare with ":"
01:0000C752 6708            	  1728: 	BEQ.s		RTS_007a			* exit if found
                            	  1729: 
01:0000C754 B200            	  1730: 	CMP.b		d0,d1				* compare with '"'
01:0000C756 670C            	  1731: 	BEQ.s		LAB_1725			* if found go search for [EOL]
                            	  1732: 
                            	  1733: LAB_172D
01:0000C758 1018            	  1734: 	MOVE.b	(a0)+,d0			* get next byte
01:0000C75A 66F4            	  1735: 	BNE.s		LAB_172C			* loop if not null [EOL]
                            	  1736: 
                            	  1737: RTS_007a
01:0000C75C 5348            	  1738: 	SUBQ.w	#1,a0				* correct pointer
01:0000C75E 4E75            	  1739: 	RTS
                            	  1740: 
                            	  1741: LAB_1723
01:0000C760 B200            	  1742: 	CMP.b		d0,d1				* compare with '"'
01:0000C762 67F4            	  1743: 	BEQ.s		LAB_172D			* if found go search for ":" or [EOL]
                            	  1744: 
                            	  1745: LAB_1725
01:0000C764 1018            	  1746: 	MOVE.b	(a0)+,d0			* get next byte
01:0000C766 66F8            	  1747: 	BNE.s		LAB_1723			* loop if not null [EOL]
                            	  1748: 
01:0000C768 60F2            	  1749: 	BRA.s		RTS_007a			* correct pointer & return
                            	  1750: 
                            	  1751: 
                            	  1752: *************************************************************************************
                            	  1753: *
                            	  1754: * perform IF
                            	  1755: 
                            	  1756: LAB_IF
01:0000C76A 610004F0        	  1757: 	BSR		LAB_EVEX			* evaluate expression
01:0000C76E 6100064E        	  1758: 	BSR		LAB_GBYT			* scan memory
01:0000C772 B03C00AD        	  1759: 	CMP.b		#TK_THEN,d0			* compare with THEN token
01:0000C776 6714            	  1760: 	BEQ.s		LAB_174B			* if it was THEN then continue
                            	  1761: 
                            	  1762: 							* wasn't IF .. THEN so must be IF .. GOTO
01:0000C778 B03C0089        	  1763: 	CMP.b		#TK_GOTO,d0			* compare with GOTO token
01:0000C77C 6600FA02        	  1764: 	BNE		LAB_SNER			* if not GOTO token do syntax error/warm start
                            	  1765: 
                            	  1766: 							* was GOTO so check for GOTO <n>
01:0000C780 204D            	  1767: 	MOVE.l	a5,a0				* save the execute pointer
01:0000C782 61000638        	  1768: 	BSR		LAB_IGBY			* scan memory, test for a numeric character
01:0000C786 2A48            	  1769: 	MOVE.l	a0,a5				* restore the execute pointer
01:0000C788 6400F9F6        	  1770: 	BCC		LAB_SNER			* if not numeric do syntax error/warm start
                            	  1771: 
                            	  1772: LAB_174B
01:0000C78C 102B0594        	  1773: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:0000C790 671E            	  1774: 	BEQ.s		LAB_174E			* if result was zero go look for an ELSE
                            	  1775: 
01:0000C792 61000628        	  1776: 	BSR		LAB_IGBY			* increment & scan memory
01:0000C796 6500FF12        	  1777: 	BCS		LAB_GOTO			* if numeric do GOTO n
                            	  1778: 							* a GOTO <n> will never return to the IF
                            	  1779: 							* statement so there is no need to return
                            	  1780: 							* to this code
                            	  1781: 
01:0000C79A B03C008E        	  1782: 	CMP.b		#TK_RETURN,d0		* compare with RETURN token
01:0000C79E 6700FE1E        	  1783: 	BEQ		LAB_1602			* if RETURN then interpret BASIC code from (a5)
                            	  1784: 							* and don't return here
                            	  1785: 
01:0000C7A2 6100FE16        	  1786: 	BSR		LAB_15FF			* else interpret BASIC code from (a5)
                            	  1787: 
                            	  1788: * the IF was executed and there may be a following ELSE so the code needs to return
                            	  1789: * here to check and ignore the ELSE if present
                            	  1790: 
01:0000C7A6 1015            	  1791: 	MOVE.b	(a5),d0			* get the next basic byte
01:0000C7A8 B03C00A9        	  1792: 	CMP.b		#TK_ELSE,d0			* compare it with the token for ELSE
01:0000C7AC 6794            	  1793: 	BEQ		LAB_DATA			* if ELSE ignore the following statement
                            	  1794: 
                            	  1795: * there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
                            	  1796: * following ELSE will, correctly, cause a syntax error
                            	  1797: 
01:0000C7AE 4E75            	  1798: 	RTS						* else return to interpreter inner loop
                            	  1799: 
                            	  1800: * perform ELSE after IF
                            	  1801: 
                            	  1802: LAB_174E
01:0000C7B0 101D            	  1803: 	MOVE.b	(a5)+,d0			* faster increment past THEN
01:0000C7B2 76A9            	  1804: 	MOVEQ		#TK_ELSE,d3			* set search for ELSE token
01:0000C7B4 788B            	  1805: 	MOVEQ		#TK_IF,d4			* set search for IF token
01:0000C7B6 7A00            	  1806: 	MOVEQ		#0,d5				* clear the nesting depth
                            	  1807: LAB_1750
01:0000C7B8 101D            	  1808: 	MOVE.b	(a5)+,d0			* get next BASIC byte & increment ptr
01:0000C7BA 6720            	  1809: 	BEQ.s		LAB_1754			* if EOL correct the pointer and return
                            	  1810: 
01:0000C7BC B004            	  1811: 	CMP.b		d4,d0				* compare with "IF" token
01:0000C7BE 6604            	  1812: 	BNE.s		LAB_1752			* skip if not nested IF
                            	  1813: 
01:0000C7C0 5245            	  1814: 	ADDQ.w	#1,d5				* else increment the nesting depth ..
01:0000C7C2 60F4            	  1815: 	BRA.s		LAB_1750			* .. and continue looking
                            	  1816: 
                            	  1817: LAB_1752
01:0000C7C4 B003            	  1818: 	CMP.b		d3,d0				* compare with ELSE token
01:0000C7C6 66F0            	  1819: 	BNE.s		LAB_1750			* if not ELSE continue looking
                            	  1820: 
                            	  1821: LAB_1756
01:0000C7C8 51CDFFEE        	  1822: 	DBF		d5,LAB_1750			* loop if still nested
                            	  1823: 
                            	  1824: * found the matching ELSE, now do <{n|statement}>
                            	  1825: 
01:0000C7CC 610005F0        	  1826: 	BSR		LAB_GBYT			* scan memory
01:0000C7D0 6500FED8        	  1827: 	BCS		LAB_GOTO			* if numeric do GOTO n
                            	  1828: 							* code will return to the interpreter loop
                            	  1829: 							* at the tail end of the GOTO <n>
                            	  1830: 
01:0000C7D4 6000FDE4        	  1831: 	BRA		LAB_15FF			* else interpret BASIC code from (a5)
                            	  1832: 							* code will return to the interpreter loop
                            	  1833: 							* at the tail end of the <statement>
                            	  1834: 
                            	  1835: 
                            	  1836: *************************************************************************************
                            	  1837: *
                            	  1838: * perform REM, skip (rest of) line
                            	  1839: 
                            	  1840: LAB_REM
01:0000C7D8 4A1D            	  1841: 	TST.b		(a5)+				* test byte & increment pointer
01:0000C7DA 66FC            	  1842: 	BNE.s		LAB_REM			* loop if not EOL
                            	  1843: 
                            	  1844: LAB_1754
01:0000C7DC 534D            	  1845: 	SUBQ.w	#1,a5				* correct the execute pointer
01:0000C7DE 4E75            	  1846: 	RTS
                            	  1847: 
                            	  1848: 
                            	  1849: *************************************************************************************
                            	  1850: *
                            	  1851: * perform ON
                            	  1852: 
                            	  1853: LAB_ON
01:0000C7E0 61000F3A        	  1854: 	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
01:0000C7E4 1400            	  1855: 	MOVE.b	d0,d2				* copy byte
01:0000C7E6 610005D6        	  1856: 	BSR		LAB_GBYT			* restore BASIC byte
01:0000C7EA 3F00            	  1857: 	MOVE.w	d0,-(sp)			* push GOTO/GOSUB token
01:0000C7EC B03C008D        	  1858: 	CMP.b		#TK_GOSUB,d0		* compare with GOSUB token
01:0000C7F0 6708            	  1859: 	BEQ.s		LAB_176C			* branch if GOSUB
                            	  1860: 
01:0000C7F2 B03C0089        	  1861: 	CMP.b		#TK_GOTO,d0			* compare with GOTO token
01:0000C7F6 6600F988        	  1862: 	BNE		LAB_SNER			* if not GOTO do syntax error, then warm start
                            	  1863: 
                            	  1864: * next character was GOTO or GOSUB
                            	  1865: 
                            	  1866: LAB_176C
01:0000C7FA 5302            	  1867: 	SUBQ.b	#1,d2				* decrement index (byte value)
01:0000C7FC 6606            	  1868: 	BNE.s		LAB_1773			* branch if not zero
                            	  1869: 
01:0000C7FE 301F            	  1870: 	MOVE.w	(sp)+,d0			* pull GOTO/GOSUB token
01:0000C800 6000FDBC        	  1871: 	BRA		LAB_1602			* go execute it
                            	  1872: 
                            	  1873: LAB_1773
01:0000C804 610005B6        	  1874: 	BSR		LAB_IGBY			* increment & scan memory
01:0000C808 610A            	  1875: 	BSR.s		LAB_GFPN			* get fixed-point number into temp integer & d1
                            	  1876: 							* (skip this n)
01:0000C80A B03C002C        	  1877: 	CMP.b		#$2C,d0			* compare next character with ","
01:0000C80E 67EA            	  1878: 	BEQ.s		LAB_176C			* loop if ","
                            	  1879: 
01:0000C810 301F            	  1880: 	MOVE.w	(sp)+,d0			* pull GOTO/GOSUB token (run out of options)
01:0000C812 4E75            	  1881: 	RTS						* and exit
                            	  1882: 
                            	  1883: 
                            	  1884: *************************************************************************************
                            	  1885: *
                            	  1886: * get fixed-point number into temp integer & d1
                            	  1887: * interpret number from (a5), leave (a5) pointing to byte after #
                            	  1888: 
                            	  1889: LAB_GFPN
01:0000C814 7200            	  1890: 	MOVEQ		#$00,d1			* clear integer register
01:0000C816 2001            	  1891: 	MOVE.l	d1,d0				* clear d0
01:0000C818 610005A4        	  1892: 	BSR		LAB_GBYT			* scan memory, Cb=1 if "0"-"9", & get byte
01:0000C81C 642E            	  1893: 	BCC.s		LAB_1786			* return if carry clear, chr was not "0"-"9"
                            	  1894: 
01:0000C81E 2F02            	  1895: 	MOVE.l	d2,-(sp)			* save d2
                            	  1896: LAB_1785
01:0000C820 2401            	  1897: 	MOVE.l	d1,d2				* copy integer register
01:0000C822 D281            	  1898: 	ADD.l		d1,d1				* *2
01:0000C824 6500F95A        	  1899: 	BCS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1900: 
01:0000C828 D281            	  1901: 	ADD.l		d1,d1				* *4
01:0000C82A 6500F954        	  1902: 	BCS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1903: 
01:0000C82E D282            	  1904: 	ADD.l		d2,d1				* *1 + *4
01:0000C830 6500F94E        	  1905: 	BCS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1906: 
01:0000C834 D281            	  1907: 	ADD.l		d1,d1				* *10
01:0000C836 6500F948        	  1908: 	BCS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1909: 
01:0000C83A 903C0030        	  1910: 	SUB.b		#$30,d0			* subtract $30 from byte
01:0000C83E D280            	  1911: 	ADD.l		d0,d1				* add to integer register, the top 24 bits are
                            	  1912: 							* always clear
01:0000C840 6900F93E        	  1913: 	BVS		LAB_SNER			* if overflow do syntax error, then warm start
                            	  1914: 							* this makes the maximum line number 2147483647
01:0000C844 61000576        	  1915: 	BSR		LAB_IGBY			* increment & scan memory
01:0000C848 65D6            	  1916: 	BCS.s		LAB_1785			* loop for next character if "0"-"9"
                            	  1917: 
01:0000C84A 241F            	  1918: 	MOVE.l	(sp)+,d2			* restore d2
                            	  1919: LAB_1786
01:0000C84C 2741042A        	  1920: 	MOVE.l	d1,Itemp(a3)		* save Itemp
01:0000C850 4E75            	  1921: 	RTS
                            	  1922: 
                            	  1923: 
                            	  1924: *************************************************************************************
                            	  1925: *
                            	  1926: * perform DEC
                            	  1927: 
                            	  1928: LAB_DEC
01:0000C852 3F3C8180        	  1929: 	MOVE.w	#$8180,-(sp)		* set -1 sign/exponent
01:0000C856 600A            	  1930: 	BRA.s		LAB_17B7			* go do DEC
                            	  1931: 
                            	  1932: 
                            	  1933: *************************************************************************************
                            	  1934: *
                            	  1935: * perform INC
                            	  1936: 
                            	  1937: LAB_INC
01:0000C858 3F3C8100        	  1938: 	MOVE.w	#$8100,-(sp)		* set 1 sign/exponent
01:0000C85C 6004            	  1939: 	BRA.s		LAB_17B7			* go do INC
                            	  1940: 
                            	  1941: 							* was "," so another INCR variable to do
                            	  1942: LAB_17B8
01:0000C85E 6100055C        	  1943: 	BSR		LAB_IGBY			* increment and scan memory
                            	  1944: LAB_17B7
01:0000C862 61000766        	  1945: 	BSR		LAB_GVAR			* get variable address in a0
                            	  1946: 
                            	  1947: * if you want a non existant variable to return a null value then set the novar
                            	  1948: * value at the top of this file to some non zero value
                            	  1949: 
                            	  1950:  ifne	novar
                            	  1951: 
                            	  1952: 	BEQ.s		LAB_INCT			* if variable not found skip the inc/dec
                            	  1953: 
                            	  1954:  endc
                            	  1955: 
01:0000C866 4A2B05B5        	  1956: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  1957: 							* $00=float
01:0000C86A 6B00F8E8        	  1958: 	BMI		LAB_TMER			* if string do "Type mismatch" error/warm start
                            	  1959: 
01:0000C86E 6636            	  1960: 	BNE.s		LAB_INCI			* go do integer INC/DEC
                            	  1961: 
01:0000C870 27480472        	  1962: 	MOVE.l	a0,Lvarpl(a3)		* save var address
01:0000C874 610012FE        	  1963: 	BSR		LAB_UFAC			* unpack memory (a0) into FAC1
01:0000C878 277C800000000598	  1964: 	MOVE.l	#$80000000,FAC2_m(a3)	* set FAC2 mantissa for 1
01:0000C880 3017            	  1965: 	MOVE.w	(sp),d0			* move exponent & sign to d0
01:0000C882 3740059C        	  1966: 	MOVE.w	d0,FAC2_e(a3)		* move exponent & sign to FAC2
01:0000C886 176B0595059E    	  1967: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make sign compare = FAC1 sign
01:0000C88C B12B059E        	  1968: 	EOR.b		d0,FAC_sc(a3)		* make sign compare (FAC1_s EOR FAC2_s)
01:0000C890 61001000        	  1969: 	BSR		LAB_ADD			* add FAC2 to FAC1
01:0000C894 610012FA        	  1970: 	BSR		LAB_PFAC			* pack FAC1 into variable (Lvarpl)
                            	  1971: LAB_INCT
01:0000C898 61000524        	  1972: 	BSR		LAB_GBYT			* scan memory
01:0000C89C 0C00002C        	  1973: 	CMPI.b	#$2C,d0			* compare with ","
01:0000C8A0 67BC            	  1974: 	BEQ.s		LAB_17B8			* continue if "," (another variable to do)
                            	  1975: 
01:0000C8A2 544F            	  1976: 	ADDQ.w	#2,sp				* else dump sign & exponent
01:0000C8A4 4E75            	  1977: 	RTS
                            	  1978: 
                            	  1979: LAB_INCI
01:0000C8A6 4A2F0001        	  1980: 	TST.b		1(sp)				* test sign
01:0000C8AA 6604            	  1981: 	BNE.s		LAB_DECI			* branch if DEC
                            	  1982: 
01:0000C8AC 5290            	  1983: 	ADDQ.l	#1,(a0)			* increment variable
01:0000C8AE 60E8            	  1984: 	BRA.s		LAB_INCT			* go scan for more
                            	  1985: 
                            	  1986: LAB_DECI
01:0000C8B0 5390            	  1987: 	SUBQ.l	#1,(a0)			* decrement variable
01:0000C8B2 60E4            	  1988: 	BRA.s		LAB_INCT			* go scan for more
                            	  1989: 
                            	  1990: 
                            	  1991: *************************************************************************************
                            	  1992: *
                            	  1993: * perform LET
                            	  1994: 
                            	  1995: LAB_LET
01:0000C8B4 61000710        	  1996: 	BSR		LAB_SVAR			* search for or create a variable
                            	  1997: 							* return the variable address in a0
01:0000C8B8 27480472        	  1998: 	MOVE.l	a0,Lvarpl(a3)		* save variable address
01:0000C8BC 1F2B05B5        	  1999: 	MOVE.b	Dtypef(a3),-(sp)		* push var data type, $80=string, $40=integer,
                            	  2000: 							* $00=float
01:0000C8C0 70BD            	  2001: 	MOVEQ		#TK_EQUAL-$100,d0		* get = token
01:0000C8C2 610004F0        	  2002: 	BSR		LAB_SCCA			* scan for CHR$(d0), else do syntax error/warm
                            	  2003: 							* start
01:0000C8C6 61000394        	  2004: 	BSR		LAB_EVEX			* evaluate expression
01:0000C8CA 102B05B5        	  2005: 	MOVE.b	Dtypef(a3),d0		* copy expression data type
01:0000C8CE 175F05B5        	  2006: 	MOVE.b	(sp)+,Dtypef(a3)		* pop variable data type
01:0000C8D2 E318            	  2007: 	ROL.b		#1,d0				* set carry if expression type = string
01:0000C8D4 61000372        	  2008: 	BSR		LAB_CKTM			* type match check, set C for string
01:0000C8D8 670012B6        	  2009: 	BEQ		LAB_PFAC			* if number pack FAC1 into variable Lvarpl & RET
                            	  2010: 
                            	  2011: * string LET
                            	  2012: 
                            	  2013: LAB_17D5
01:0000C8DC 246B0472        	  2014: 	MOVEA.l	Lvarpl(a3),a2		* get pointer to variable
                            	  2015: LAB_17D6
01:0000C8E0 206B0590        	  2016: 	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer
01:0000C8E4 2250            	  2017: 	MOVEA.l	(a0),a1			* get string pointer
01:0000C8E6 B3EB0446        	  2018: 	CMP.l		Sstorl(a3),a1		* compare string memory start with string
                            	  2019: 							* pointer
01:0000C8EA 6516            	  2020: 	BCS.s		LAB_1811			* if it was in program memory assign the value
                            	  2021: 							* and exit
                            	  2022: 
01:0000C8EC B1EB0432        	  2023: 	CMPA.l	Sfncl(a3),a0		* compare functions start with descriptor
                            	  2024: 							* pointer
01:0000C8F0 6510            	  2025: 	BCS.s		LAB_1811			* branch if >= (string is on stack)
                            	  2026: 
                            	  2027: 							* string is variable$ make space and copy string
                            	  2028: LAB_1810
01:0000C8F2 7200            	  2029: 	MOVEQ		#0,d1				* clear length
01:0000C8F4 32280004        	  2030: 	MOVE.w	4(a0),d1			* get string length
01:0000C8F8 2050            	  2031: 	MOVEA.l	(a0),a0			* get string pointer
01:0000C8FA 61000B02        	  2032: 	BSR		LAB_20C9			* copy string
01:0000C8FE 206B0590        	  2033: 	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer back
                            	  2034: 							* clean stack & assign value to string variable
                            	  2035: LAB_1811
01:0000C902 B9C8            	  2036: 	CMPA.l	a0,a4				* is string on the descriptor stack
01:0000C904 6602            	  2037: 	BNE.s		LAB_1813			* skip pop if not
                            	  2038: 
01:0000C906 5C4C            	  2039: 	ADDQ.w	#$06,a4			* else update stack pointer
                            	  2040: LAB_1813
01:0000C908 24D8            	  2041: 	MOVE.l	(a0)+,(a2)+			* save pointer to variable
01:0000C90A 3490            	  2042: 	MOVE.w	(a0),(a2)			* save length to variable
                            	  2043: RTS_008
01:0000C90C 4E75            	  2044: 	RTS
                            	  2045: 
                            	  2046: 
                            	  2047: *************************************************************************************
                            	  2048: *
                            	  2049: * perform GET
                            	  2050: 
                            	  2051: LAB_GET
01:0000C90E 610006B6        	  2052: 	BSR		LAB_SVAR			* search for or create a variable
                            	  2053: 							* return the variable address in a0
01:0000C912 27480472        	  2054: 	MOVE.l	a0,Lvarpl(a3)		* save variable address as GET variable
01:0000C916 4A2B05B5        	  2055: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2056: 							* $00=float
01:0000C91A 6B0C            	  2057: 	BMI.s		LAB_GETS			* go get string character
                            	  2058: 
                            	  2059: 							* was numeric get
01:0000C91C 61001DD0        	  2060: 	BSR		INGET				* get input byte
01:0000C920 610009B8        	  2061: 	BSR		LAB_1FD0			* convert d0 to unsigned byte in FAC1
01:0000C924 6000126A        	  2062: 	BRA		LAB_PFAC			* pack FAC1 into variable (Lvarpl) & return
                            	  2063: 
                            	  2064: LAB_GETS
01:0000C928 7200            	  2065: 	MOVEQ		#$00,d1			* assume no byte
01:0000C92A 2041            	  2066: 	MOVE.l	d1,a0				* assume null string
01:0000C92C 61001DC0        	  2067: 	BSR		INGET				* get input byte
01:0000C930 6408            	  2068: 	BCC.s		LAB_NoSt			* branch if no byte received
                            	  2069: 
01:0000C932 7201            	  2070: 	MOVEQ		#$01,d1			* string is single byte
01:0000C934 61000AFA        	  2071: 	BSR		LAB_2115			* make string space d1 bytes long
                            	  2072: 							* return a0 = pointer, other registers unchanged
                            	  2073: 
01:0000C938 1080            	  2074: 	MOVE.b	d0,(a0)			* save byte in string (byte IS string!)
                            	  2075: LAB_NoSt
01:0000C93A 61000ADA        	  2076: 	BSR		LAB_RTST			* push string on descriptor stack
                            	  2077: 							* a0 = pointer, d1 = length
                            	  2078: 
01:0000C93E 609C            	  2079: 	BRA.s		LAB_17D5			* do string LET & return
                            	  2080: 
                            	  2081: 
                            	  2082: *************************************************************************************
                            	  2083: *
                            	  2084: * PRINT
                            	  2085: 
                            	  2086: LAB_1829
01:0000C940 610000B4        	  2087: 	BSR		LAB_18C6			* print string from stack
                            	  2088: LAB_182C
01:0000C944 61000478        	  2089: 	BSR		LAB_GBYT			* scan memory
                            	  2090: 
                            	  2091: * perform PRINT
                            	  2092: 
                            	  2093: LAB_PRINT
01:0000C948 674A            	  2094: 	BEQ.s		LAB_CRLF			* if nothing following just print CR/LF
                            	  2095: 
                            	  2096: LAB_1831
01:0000C94A B03C00A8        	  2097: 	CMP.b		#TK_TAB,d0			* compare with TAB( token
01:0000C94E 6764            	  2098: 	BEQ.s		LAB_18A2			* go do TAB/SPC
                            	  2099: 
01:0000C950 B03C00AC        	  2100: 	CMP.b		#TK_SPC,d0			* compare with SPC( token
01:0000C954 675E            	  2101: 	BEQ.s		LAB_18A2			* go do TAB/SPC
                            	  2102: 
01:0000C956 B03C002C        	  2103: 	CMP.b		#',',d0			* compare with ","
01:0000C95A 6740            	  2104: 	BEQ.s		LAB_188B			* go do move to next TAB mark
                            	  2105: 
01:0000C95C B03C003B        	  2106: 	CMP.b		#';',d0			* compare with ";"
01:0000C960 67000086        	  2107: 	BEQ		LAB_18BD			* if ";" continue with PRINT processing
                            	  2108: 
01:0000C964 610002F6        	  2109: 	BSR		LAB_EVEX			* evaluate expression
01:0000C968 4A2B05B5        	  2110: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2111: 							* $00=float
01:0000C96C 6BD2            	  2112: 	BMI.s		LAB_1829			* branch if string
                            	  2113: 
                            	  2114: ** replace the two lines above with this code
                            	  2115: 
                            	  2116: **	MOVE.b	Dtypef(a3),d0		* get data type flag, $80=string, $00=numeric
                            	  2117: **	BMI.s		LAB_1829			* branch if string
                            	  2118: 
01:0000C96E 6100139E        	  2119: 	BSR		LAB_2970			* convert FAC1 to string
01:0000C972 61000A5C        	  2120: 	BSR		LAB_20AE			* print " terminated string to FAC1 stack
                            	  2121: 
                            	  2122: * don't check fit if terminal width byte is zero
                            	  2123: 
01:0000C976 7000            	  2124: 	MOVEQ		#0,d0				* clear d0
01:0000C978 102B05E6        	  2125: 	MOVE.b	TWidth(a3),d0		* get terminal width byte
01:0000C97C 670C            	  2126: 	BEQ.s		LAB_185E			* skip check if zero
                            	  2127: 
01:0000C97E 902C0007        	  2128: 	SUB.b		7(a4),d0			* subtract string length
01:0000C982 902B05E5        	  2129: 	SUB.b		TPos(a3),d0			* subtract terminal position
01:0000C986 6402            	  2130: 	BCC.s		LAB_185E			* branch if less than terminal width
                            	  2131: 
01:0000C988 610A            	  2132: 	BSR.s		LAB_CRLF			* else print CR/LF
                            	  2133: LAB_185E
01:0000C98A 616A            	  2134: 	BSR.s		LAB_18C6			* print string from stack
01:0000C98C 60B6            	  2135: 	BRA.s		LAB_182C			* always go continue processing line
                            	  2136: 
                            	  2137: 
                            	  2138: *************************************************************************************
                            	  2139: *
                            	  2140: * CR/LF return to BASIC from BASIC input handler
                            	  2141: * leaves a0 pointing to the buffer start
                            	  2142: 
                            	  2143: LAB_1866
01:0000C98E 11BC00001000    	  2144: 	MOVE.b	#$00,(a0,d1.w)		* null terminate input
                            	  2145: 
                            	  2146: * print CR/LF
                            	  2147: 
                            	  2148: LAB_CRLF
01:0000C994 700D            	  2149: 	MOVEQ		#$0D,d0			* load [CR]
01:0000C996 6174            	  2150: 	BSR.s		LAB_PRNA			* go print the character
01:0000C998 700A            	  2151: 	MOVEQ		#$0A,d0			* load [LF]
01:0000C99A 6070            	  2152: 	BRA.s		LAB_PRNA			* go print the character & return
                            	  2153: 
                            	  2154: LAB_188B
01:0000C99C 142B05E5        	  2155: 	MOVE.b	TPos(a3),d2			* get terminal position
01:0000C9A0 B42B05E7        	  2156: 	CMP.b		Iclim(a3),d2		* compare with input column limit
01:0000C9A4 6504            	  2157: 	BCS.s		LAB_1898			* branch if less than Iclim
                            	  2158: 
01:0000C9A6 61EC            	  2159: 	BSR.s		LAB_CRLF			* else print CR/LF (next line)
01:0000C9A8 603E            	  2160: 	BRA.s		LAB_18BD			* continue with PRINT processing
                            	  2161: 
                            	  2162: LAB_1898
01:0000C9AA 942B05E2        	  2163: 	SUB.b		TabSiz(a3),d2		* subtract TAB size
01:0000C9AE 64FA            	  2164: 	BCC.s		LAB_1898			* loop if result was >= 0
                            	  2165: 
01:0000C9B0 4402            	  2166: 	NEG.b		d2				* twos complement it
01:0000C9B2 6022            	  2167: 	BRA.s		LAB_18B7			* print d2 spaces
                            	  2168: 
                            	  2169: 							* do TAB/SPC
                            	  2170: LAB_18A2
01:0000C9B4 3F00            	  2171: 	MOVE.w	d0,-(sp)			* save token
01:0000C9B6 61000D60        	  2172: 	BSR		LAB_SGBY			* increment and get byte, result in d0 and Itemp
01:0000C9BA 3400            	  2173: 	MOVE.w	d0,d2				* copy byte
01:0000C9BC 61000400        	  2174: 	BSR		LAB_GBYT			* get basic byte back
01:0000C9C0 B03C0029        	  2175: 	CMP.b		#$29,d0			* is next character ")"
01:0000C9C4 6600F7BA        	  2176: 	BNE		LAB_SNER			* if not do syntax error, then warm start
                            	  2177: 
01:0000C9C8 301F            	  2178: 	MOVE.w	(sp)+,d0			* get token back
01:0000C9CA B03C00A8        	  2179: 	CMP.b		#TK_TAB,d0			* was it TAB ?
01:0000C9CE 6606            	  2180: 	BNE.s		LAB_18B7			* branch if not (was SPC)
                            	  2181: 
                            	  2182: 							* calculate TAB offset
01:0000C9D0 942B05E5        	  2183: 	SUB.b		TPos(a3),d2			* subtract terminal position
01:0000C9D4 6312            	  2184: 	BLS.s		LAB_18BD			* branch if result was <= 0
                            	  2185: 							* can't TAB backwards or already there
                            	  2186: 
                            	  2187: 							* print d2.b spaces
                            	  2188: LAB_18B7
01:0000C9D6 7000            	  2189: 	MOVEQ		#0,d0				* clear longword
01:0000C9D8 5300            	  2190: 	SUBQ.b	#1,d0				* make d0 = $FF
01:0000C9DA C480            	  2191: 	AND.l		d0,d2				* mask for byte only
01:0000C9DC 670A            	  2192: 	BEQ.s		LAB_18BD			* branch if zero
                            	  2193: 
01:0000C9DE 7020            	  2194: 	MOVEQ		#$20,d0			* load " "
01:0000C9E0 5302            	  2195: 	SUBQ.b	#1,d2				* adjust for DBF loop
                            	  2196: LAB_18B8
01:0000C9E2 6128            	  2197: 	BSR.s		LAB_PRNA			* go print
01:0000C9E4 51CAFFFC        	  2198: 	DBF		d2,LAB_18B8			* decrement count and loop if not all done
                            	  2199: 
                            	  2200: 							* continue with PRINT processing
                            	  2201: LAB_18BD
01:0000C9E8 610003D2        	  2202: 	BSR		LAB_IGBY			* increment & scan memory
01:0000C9EC 6600FF5C        	  2203: 	BNE		LAB_1831			* if byte continue executing PRINT
                            	  2204: 
01:0000C9F0 4E75            	  2205: 	RTS						* exit if nothing more to print
                            	  2206: 
                            	  2207: 
                            	  2208: *************************************************************************************
                            	  2209: *
                            	  2210: * print null terminated string from a0
                            	  2211: 
                            	  2212: LAB_18C3
01:0000C9F2 610009DC        	  2213: 	BSR		LAB_20AE			* print terminated string to FAC1/stack
                            	  2214: 
                            	  2215: * print string from stack
                            	  2216: 
                            	  2217: LAB_18C6
01:0000C9F6 61000BC4        	  2218: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  2219: 							* returns with d0 = length, a0 = pointer
01:0000C9FA 670C            	  2220: 	BEQ.s		RTS_009			* exit (RTS) if null string
                            	  2221: 
01:0000C9FC 3200            	  2222: 	MOVE.w	d0,d1				* copy length & set Z flag
01:0000C9FE 5341            	  2223: 	SUBQ.w	#1,d1				* -1 for BF loop
                            	  2224: LAB_18CD
01:0000CA00 1018            	  2225: 	MOVE.b	(a0)+,d0			* get byte from string
01:0000CA02 6108            	  2226: 	BSR.s		LAB_PRNA			* go print the character
01:0000CA04 51C9FFFA        	  2227: 	DBF		d1,LAB_18CD			* decrement count and loop if not done yet
                            	  2228: 
                            	  2229: RTS_009
01:0000CA08 4E75            	  2230: 	RTS
                            	  2231: 
                            	  2232: 
                            	  2233: *************************************************************************************
                            	  2234: *
                            	  2235: * print "?" character
                            	  2236: 
                            	  2237: LAB_18E3
01:0000CA0A 703F            	  2238: 	MOVEQ		#$3F,d0			* load "?" character
                            	  2239: 
                            	  2240: 
                            	  2241: *************************************************************************************
                            	  2242: *
                            	  2243: * print character in d0, includes the null handler and infinite line length code
                            	  2244: * changes no registers
                            	  2245: 
                            	  2246: LAB_PRNA
01:0000CA0C 2F01            	  2247: 	MOVE.l	d1,-(sp)			* save d1
01:0000CA0E B03C0020        	  2248: 	CMP.b		#$20,d0			* compare with " "
01:0000CA12 6528            	  2249: 	BCS.s		LAB_18F9			* branch if less, non printing character
                            	  2250: 
                            	  2251: 							* don't check fit if terminal width byte is zero
01:0000CA14 122B05E6        	  2252: 	MOVE.b	TWidth(a3),d1		* get terminal width
01:0000CA18 6610            	  2253: 	BNE.s		LAB_18F0			* branch if not zero (not infinite length)
                            	  2254: 
                            	  2255: 							* is "infinite line" so check TAB position
01:0000CA1A 122B05E5        	  2256: 	MOVE.b	TPos(a3),d1			* get position
01:0000CA1E 922B05E2        	  2257: 	SUB.b		TabSiz(a3),d1		* subtract TAB size
01:0000CA22 6614            	  2258: 	BNE.s		LAB_18F7			* skip reset if different
                            	  2259: 
01:0000CA24 174105E5        	  2260: 	MOVE.b	d1,TPos(a3)			* else reset position
01:0000CA28 600E            	  2261: 	BRA.s		LAB_18F7			* go print character
                            	  2262: 
                            	  2263: LAB_18F0
01:0000CA2A B22B05E5        	  2264: 	CMP.b		TPos(a3),d1			* compare with terminal character position
01:0000CA2E 6608            	  2265: 	BNE.s		LAB_18F7			* branch if not at end of line
                            	  2266: 
01:0000CA30 2F00            	  2267: 	MOVE.l	d0,-(sp)			* save d0
01:0000CA32 6100FF60        	  2268: 	BSR		LAB_CRLF			* else print CR/LF
01:0000CA36 201F            	  2269: 	MOVE.l	(sp)+,d0			* restore d0
                            	  2270: LAB_18F7
01:0000CA38 522B05E5        	  2271: 	ADDQ.b	#$01,TPos(a3)		* increment terminal position
                            	  2272: LAB_18F9
01:0000CA3C 4EAB0412        	  2273: 	JSR		V_OUTP(a3)			* output byte via output vector
01:0000CA40 B03C000D        	  2274: 	CMP.b		#$0D,d0			* compare with [CR]
01:0000CA44 6618            	  2275: 	BNE.s		LAB_188A			* branch if not [CR]
                            	  2276: 
                            	  2277: 							* else print nullct nulls after the [CR]
01:0000CA46 7200            	  2278: 	MOVEQ		#$00,d1			* clear d1
01:0000CA48 122B05E4        	  2279: 	MOVE.b	Nullct(a3),d1		* get null count
01:0000CA4C 670C            	  2280: 	BEQ.s		LAB_1886			* branch if no nulls
                            	  2281: 
01:0000CA4E 7000            	  2282: 	MOVEQ		#$00,d0			* load [NULL]
                            	  2283: LAB_1880
01:0000CA50 4EAB0412        	  2284: 	JSR		V_OUTP(a3)			* go print the character
01:0000CA54 51C9FFFA        	  2285: 	DBF		d1,LAB_1880			* decrement count and loop if not all done
                            	  2286: 
01:0000CA58 700D            	  2287: 	MOVEQ		#$0D,d0			* restore the character
                            	  2288: LAB_1886
01:0000CA5A 174105E5        	  2289: 	MOVE.b	d1,TPos(a3)			* clear terminal position
                            	  2290: LAB_188A
01:0000CA5E 221F            	  2291: 	MOVE.l	(sp)+,d1			* restore d1
01:0000CA60 4E75            	  2292: 	RTS
                            	  2293: 
                            	  2294: 
                            	  2295: *************************************************************************************
                            	  2296: *
                            	  2297: * handle bad input data
                            	  2298: 
                            	  2299: LAB_1904
01:0000CA62 2A5F            	  2300: 	MOVEA.l	(sp)+,a5			* restore execute pointer
01:0000CA64 4A2B05E0        	  2301: 	TST.b		Imode(a3)			* test input mode flag, $00=INPUT, $98=READ
01:0000CA68 6A0A            	  2302: 	BPL.s		LAB_1913			* branch if INPUT (go do redo)
                            	  2303: 
01:0000CA6A 276B045E0452    	  2304: 	MOVE.l	Dlinel(a3),Clinel(a3)	* save DATA line as current line
01:0000CA70 6000F6E2        	  2305: 	BRA		LAB_TMER			* do type mismatch error, then warm start
                            	  2306: 
                            	  2307: 							* mode was INPUT
                            	  2308: LAB_1913
01:0000CA74 41FA2A52        	  2309: 	LEA		LAB_REDO(pc),a0		* point to redo message
01:0000CA78 6100FF78        	  2310: 	BSR		LAB_18C3			* print null terminated string from memory
01:0000CA7C 2A6B045A        	  2311: 	MOVEA.l	Cpntrl(a3),a5		* save continue pointer as BASIC execute pointer
01:0000CA80 4E75            	  2312: 	RTS
                            	  2313: 
                            	  2314: 
                            	  2315: *************************************************************************************
                            	  2316: *
                            	  2317: * perform INPUT
                            	  2318: 
                            	  2319: LAB_INPUT
01:0000CA82 6100085E        	  2320: 	BSR		LAB_CKRN			* check not direct (back here if ok)
01:0000CA86 B03C0022        	  2321: 	CMP.b		#'"',d0			* compare the next byte with open quote
01:0000CA8A 660E            	  2322: 	BNE.s		LAB_1934			* if no prompt string just go get the input
                            	  2323: 
01:0000CA8C 61000306        	  2324: 	BSR		LAB_1BC1			* print "..." string
01:0000CA90 703B            	  2325: 	MOVEQ		#';',d0			* set the search character to ";"
01:0000CA92 61000320        	  2326: 	BSR		LAB_SCCA			* scan for CHR$(d0), else do syntax error/warm
                            	  2327: 							* start
01:0000CA96 6100FF5E        	  2328: 	BSR		LAB_18C6			* print string from Sutill/Sutilh
                            	  2329: 							* finished the prompt, now read the data
                            	  2330: LAB_1934
01:0000CA9A 6100F80E        	  2331: 	BSR		LAB_INLN			* print "? " and get BASIC input
                            	  2332: 							* return a0 pointing to the buffer start
01:0000CA9E 7000            	  2333: 	MOVEQ		#0,d0				* flag INPUT
                            	  2334: 
                            	  2335: * if you don't want a null response to INPUT to break the program then set the nobrk
                            	  2336: * value at the top of this file to some non zero value
                            	  2337: 
                            	  2338:  ifne	nobrk
                            	  2339: 
                            	  2340: 	BRA.s		LAB_1953			* go handle the input
                            	  2341: 
                            	  2342:  endc
                            	  2343: 
                            	  2344: * if you do want a null response to INPUT to break the program then leave the nobrk
                            	  2345: * value at the top of this file set to zero
                            	  2346: 
                            	  2347:  ifeq	nobrk
                            	  2348: 
01:0000CAA0 4A10            	  2349: 	TST.b		(a0)				* test first byte from buffer
01:0000CAA2 660A            	  2350: 	BNE.s		LAB_1953			* branch if not null input
                            	  2351: 
01:0000CAA4 6000FB5E        	  2352: 	BRA		LAB_1647			* go do BREAK exit
                            	  2353: 
                            	  2354:  endc
                            	  2355: 
                            	  2356: 
                            	  2357: *************************************************************************************
                            	  2358: *
                            	  2359: * perform READ
                            	  2360: 
                            	  2361: LAB_READ
01:0000CAA8 206B0462        	  2362: 	MOVEA.l	Dptrl(a3),a0		* get the DATA pointer
01:0000CAAC 7098            	  2363: 	MOVEQ		#$98-$100,d0		* flag READ
                            	  2364: LAB_1953
01:0000CAAE 174005E0        	  2365: 	MOVE.b	d0,Imode(a3)		* set input mode flag, $00=INPUT, $98=READ
01:0000CAB2 27480466        	  2366: 	MOVE.l	a0,Rdptrl(a3)		* save READ pointer
                            	  2367: 
                            	  2368: 							* READ or INPUT the next variable from list
                            	  2369: LAB_195B
01:0000CAB6 6100050E        	  2370: 	BSR		LAB_SVAR			* search for or create a variable
                            	  2371: 							* return the variable address in a0
01:0000CABA 27480472        	  2372: 	MOVE.l	a0,Lvarpl(a3)		* save variable address as LET variable
01:0000CABE 2F0D            	  2373: 	MOVE.l	a5,-(sp)			* save BASIC execute pointer
                            	  2374: LAB_1961
01:0000CAC0 2A6B0466        	  2375: 	MOVEA.l	Rdptrl(a3),a5		* set READ pointer as BASIC execute pointer
01:0000CAC4 610002F8        	  2376: 	BSR		LAB_GBYT			* scan memory
01:0000CAC8 661E            	  2377: 	BNE.s		LAB_1986			* if not null go get the value
                            	  2378: 
                            	  2379: 							* the pointer was to a null entry
01:0000CACA 4A2B05E0        	  2380: 	TST.b		Imode(a3)			* test input mode flag, $00=INPUT, $98=READ
01:0000CACE 6B72            	  2381: 	BMI.s		LAB_19DD			* branch if READ (go find the next statement)
                            	  2382: 
                            	  2383: 							* else the mode was INPUT so get more
01:0000CAD0 6100FF38        	  2384: 	BSR		LAB_18E3			* print a "?" character
01:0000CAD4 6100F7D4        	  2385: 	BSR		LAB_INLN			* print "? " and get BASIC input
                            	  2386: 							* return a0 pointing to the buffer start
                            	  2387: 
                            	  2388: * if you don't want a null response to INPUT to break the program then set the nobrk
                            	  2389: * value at the top of this file to some non zero value
                            	  2390: 
                            	  2391:  ifne	nobrk
                            	  2392: 
                            	  2393: 	MOVE.l	a0,Rdptrl(a3)		* save the READ pointer
                            	  2394: 	BRA.s		LAB_1961			* go handle the input
                            	  2395: 
                            	  2396:  endc
                            	  2397: 
                            	  2398: * if you do want a null response to INPUT to break the program then leave the nobrk
                            	  2399: * value at the top of this file set to zero
                            	  2400: 
                            	  2401:  ifeq	nobrk
                            	  2402: 
01:0000CAD8 4A10            	  2403: 	TST.b		(a0)				* test the first byte from the buffer
01:0000CADA 6604            	  2404: 	BNE.s		LAB_1984			* if not null input go handle it
                            	  2405: 
01:0000CADC 6000FB26        	  2406: 	BRA		LAB_1647			* else go do the BREAK exit
                            	  2407: 
                            	  2408: LAB_1984
01:0000CAE0 2A48            	  2409: 	MOVEA.l	a0,a5				* set the execute pointer to the buffer
01:0000CAE2 534D            	  2410: 	SUBQ.w	#1,a5				* decrement the execute pointer
                            	  2411: 
                            	  2412:  endc
                            	  2413: 
                            	  2414: LAB_1985
01:0000CAE4 610002D6        	  2415: 	BSR		LAB_IGBY			* increment & scan memory
                            	  2416: LAB_1986
01:0000CAE8 4A2B05B5        	  2417: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2418: 							* $00=float
01:0000CAEC 6A20            	  2419: 	BPL.s		LAB_19B0			* branch if numeric
                            	  2420: 
                            	  2421: 							* else get string
01:0000CAEE 1400            	  2422: 	MOVE.b	d0,d2				* save search character
01:0000CAF0 B03C0022        	  2423: 	CMP.b		#$22,d0			* was it " ?
01:0000CAF4 6706            	  2424: 	BEQ.s		LAB_1999			* branch if so
                            	  2425: 
01:0000CAF6 743A            	  2426: 	MOVEQ		#':',d2			* set new search character
01:0000CAF8 702C            	  2427: 	MOVEQ		#',',d0			* other search character is ","
01:0000CAFA 534D            	  2428: 	SUBQ.w	#1,a5				* decrement BASIC execute pointer
                            	  2429: LAB_1999
01:0000CAFC 524D            	  2430: 	ADDQ.w	#1,a5				* increment BASIC execute pointer
01:0000CAFE 1600            	  2431: 	MOVE.b	d0,d3				* set second search character
01:0000CB00 204D            	  2432: 	MOVEA.l	a5,a0				* BASIC execute pointer is source
                            	  2433: 
01:0000CB02 610008D0        	  2434: 	BSR		LAB_20B4			* print d2/d3 terminated string to FAC1 stack
                            	  2435: 							* d2 = Srchc, d3 = Asrch, a0 is source
01:0000CB06 2A4A            	  2436: 	MOVEA.l	a2,a5				* copy end of string to BASIC execute pointer
01:0000CB08 6100FDD2        	  2437: 	BSR		LAB_17D5			* go do string LET
01:0000CB0C 6010            	  2438: 	BRA.s		LAB_19B6			* go check string terminator
                            	  2439: 
                            	  2440: 							* get numeric INPUT
                            	  2441: LAB_19B0
01:0000CB0E 1F2B05B5        	  2442: 	MOVE.b	Dtypef(a3),-(sp)		* save variable data type
01:0000CB12 61001D82        	  2443: 	BSR		LAB_2887			* get FAC1 from string
01:0000CB16 175F05B5        	  2444: 	MOVE.b	(sp)+,Dtypef(a3)		* restore variable data type
01:0000CB1A 61001074        	  2445: 	BSR		LAB_PFAC			* pack FAC1 into (Lvarpl)
                            	  2446: LAB_19B6
01:0000CB1E 6100029E        	  2447: 	BSR		LAB_GBYT			* scan memory
01:0000CB22 670A            	  2448: 	BEQ.s		LAB_19C2			* branch if null (last entry)
                            	  2449: 
01:0000CB24 B03C002C        	  2450: 	CMP.b		#',',d0			* else compare with ","
01:0000CB28 6600FF38        	  2451: 	BNE		LAB_1904			* if not "," go handle bad input data
                            	  2452: 
01:0000CB2C 524D            	  2453: 	ADDQ.w	#1,a5				* else was "," so point to next chr
                            	  2454: 							* got good input data
                            	  2455: LAB_19C2
01:0000CB2E 274D0466        	  2456: 	MOVE.l	a5,Rdptrl(a3)		* save the read pointer for now
01:0000CB32 2A5F            	  2457: 	MOVEA.l	(sp)+,a5			* restore the execute pointer
01:0000CB34 61000288        	  2458: 	BSR		LAB_GBYT			* scan the memory
01:0000CB38 6736            	  2459: 	BEQ.s		LAB_1A03			* if null go do extra ignored message
                            	  2460: 
01:0000CB3A 487AFF7A        	  2461: 	PEA		LAB_195B(pc)		* set return address
01:0000CB3E 60000272        	  2462: 	BRA		LAB_1C01			* scan for "," else do syntax error/warm start
                            	  2463: 							* then go INPUT next variable from list
                            	  2464: 
                            	  2465: 							* find next DATA statement or do "Out of Data"
                            	  2466: 							* error
                            	  2467: LAB_19DD
01:0000CB42 6100FC04        	  2468: 	BSR		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
                            	  2469: 							* returns a0 as pointer to [:] or [EOL]
01:0000CB46 2A48            	  2470: 	MOVEA.l	a0,a5				* add index, now = pointer to [EOL]/[EOS]
01:0000CB48 524D            	  2471: 	ADDQ.w	#1,a5				* pointer to next character
01:0000CB4A B03C003A        	  2472: 	CMP.b		#':',d0			* was it statement end?
01:0000CB4E 6712            	  2473: 	BEQ.s		LAB_19F6			* branch if [:]
                            	  2474: 
                            	  2475: 							* was [EOL] so find next line
                            	  2476: 
01:0000CB50 320D            	  2477: 	MOVE.w	a5,d1				* past pad byte(s)
01:0000CB52 C27C0001        	  2478: 	AND.w		#1,d1				* mask odd bit
01:0000CB56 DAC1            	  2479: 	ADD.w		d1,a5				* add pointer
01:0000CB58 241D            	  2480: 	MOVE.l	(a5)+,d2			* get next line pointer
01:0000CB5A 6700F61C        	  2481: 	BEQ		LAB_ODER			* branch if end of program
                            	  2482: 
01:0000CB5E 275D045E        	  2483: 	MOVE.l	(a5)+,Dlinel(a3)		* save current DATA line
                            	  2484: LAB_19F6
01:0000CB62 6100025A        	  2485: 	BSR		LAB_GBYT			* scan memory
01:0000CB66 B03C0083        	  2486: 	CMP.b		#TK_DATA,d0			* compare with "DATA" token
01:0000CB6A 6700FF78        	  2487: 	BEQ		LAB_1985			* was "DATA" so go do next READ
                            	  2488: 
01:0000CB6E 60D2            	  2489: 	BRA.s		LAB_19DD			* go find next statement if not "DATA"
                            	  2490: 
                            	  2491: * end of INPUT/READ routine
                            	  2492: 
                            	  2493: LAB_1A03
01:0000CB70 206B0466        	  2494: 	MOVEA.l	Rdptrl(a3),a0		* get temp READ pointer
01:0000CB74 4A2B05E0        	  2495: 	TST.b		Imode(a3)			* get input mode flag, $00=INPUT, $98=READ
01:0000CB78 6A06            	  2496: 	BPL.s		LAB_1A0E			* branch if INPUT
                            	  2497: 
01:0000CB7A 27480462        	  2498: 	MOVE.l	a0,Dptrl(a3)		* else save temp READ pointer as DATA pointer
01:0000CB7E 4E75            	  2499: 	RTS
                            	  2500: 
                            	  2501: 							* we were getting INPUT
                            	  2502: LAB_1A0E
01:0000CB80 4A10            	  2503: 	TST.b		(a0)				* test next byte
01:0000CB82 6602            	  2504: 	BNE.s		LAB_1A1B			* error if not end of INPUT
                            	  2505: 
01:0000CB84 4E75            	  2506: 	RTS
                            	  2507: 							* user typed too much
                            	  2508: LAB_1A1B
01:0000CB86 41FA2930        	  2509: 	LEA		LAB_IMSG(pc),a0		* point to extra ignored message
01:0000CB8A 6000FE66        	  2510: 	BRA		LAB_18C3			* print null terminated string from memory & RTS
                            	  2511: 
                            	  2512: 
                            	  2513: *************************************************************************************
                            	  2514: *
                            	  2515: * perform NEXT
                            	  2516: 
                            	  2517: LAB_NEXT
01:0000CB8E 6610            	  2518: 	BNE.s		LAB_1A46			* branch if NEXT var
                            	  2519: 
01:0000CB90 584F            	  2520: 	ADDQ.w	#4,sp				* back past return address
01:0000CB92 0C570081        	  2521: 	CMP.w		#TK_FOR,(sp)		* is FOR token on stack?
01:0000CB96 6600F5EC        	  2522: 	BNE		LAB_NFER			* if not do NEXT without FOR err/warm start
                            	  2523: 
01:0000CB9A 206F0002        	  2524: 	MOVEA.l	2(sp),a0			* get stacked FOR variable pointer
01:0000CB9E 601C            	  2525: 	BRA.s		LAB_11BD			* branch always (no variable to search for)
                            	  2526: 
                            	  2527: * NEXT var
                            	  2528: 
                            	  2529: LAB_1A46
01:0000CBA0 61000428        	  2530: 	BSR		LAB_GVAR			* get variable address in a0
01:0000CBA4 584F            	  2531: 	ADDQ.w	#4,sp				* back past return address
01:0000CBA6 303C0081        	  2532: 	MOVE.w	#TK_FOR,d0			* set for FOR token
01:0000CBAA 721C            	  2533: 	MOVEQ		#$1C,d1			* set for FOR use size
01:0000CBAC 6002            	  2534: 	BRA.s		LAB_11A6			* enter loop for next variable search
                            	  2535: 
                            	  2536: LAB_11A5
01:0000CBAE DFC1            	  2537: 	ADDA.l	d1,sp				* add FOR stack use size
                            	  2538: LAB_11A6
01:0000CBB0 B057            	  2539: 	CMP.w		(sp),d0			* is FOR token on stack?
01:0000CBB2 6600F5D0        	  2540: 	BNE		LAB_NFER			* if not found do NEXT without FOR error and
                            	  2541: 							* warm start
                            	  2542: 
                            	  2543: 							* was FOR token
01:0000CBB6 B1EF0002        	  2544: 	CMPA.l	2(sp),a0			* compare var pointer with stacked var pointer
01:0000CBBA 66F2            	  2545: 	BNE.s		LAB_11A5			* loop if no match found
                            	  2546: 
                            	  2547: LAB_11BD
01:0000CBBC 376F0006059C    	  2548: 	MOVE.w	6(sp),FAC2_e(a3)		* get STEP value exponent and sign
01:0000CBC2 276F00080598    	  2549: 	MOVE.l	8(sp),FAC2_m(a3)		* get STEP value mantissa
                            	  2550: 
01:0000CBC8 176F001205B5    	  2551: 	MOVE.b	18(sp),Dtypef(a3)		* restore FOR variable data type
01:0000CBCE 6100021A        	  2552: 	BSR		LAB_1C19			* check type and unpack (a0)
                            	  2553: 
01:0000CBD2 176B059D059E    	  2554: 	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* save FAC2 sign as sign compare
01:0000CBD8 102B0595        	  2555: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:0000CBDC B12B059E        	  2556: 	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
                            	  2557: 
01:0000CBE0 27480472        	  2558: 	MOVE.l	a0,Lvarpl(a3)		* save variable pointer
01:0000CBE4 61000CAC        	  2559: 	BSR		LAB_ADD			* add STEP value to FOR variable
01:0000CBE8 176F001205B5    	  2560: 	MOVE.b	18(sp),Dtypef(a3)		* restore FOR variable data type (again)
01:0000CBEE 61000FA0        	  2561: 	BSR		LAB_PFAC			* pack FAC1 into FOR variable (Lvarpl)
                            	  2562: 
01:0000CBF2 376F000C059C    	  2563: 	MOVE.w	12(sp),FAC2_e(a3)		* get TO value exponent and sign
01:0000CBF8 276F000E0598    	  2564: 	MOVE.l	14(sp),FAC2_m(a3)		* get TO value mantissa
                            	  2565: 
01:0000CBFE 176B059D059E    	  2566: 	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* save FAC2 sign as sign compare
01:0000CC04 102B0595        	  2567: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:0000CC08 B12B059E        	  2568: 	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
                            	  2569: 
01:0000CC0C 6100102C        	  2570: 	BSR		LAB_27FA			* compare FAC1 with FAC2 (TO value)
                            	  2571: 							* returns d0=+1 if FAC1 > FAC2
                            	  2572: 							* returns d0= 0 if FAC1 = FAC2
                            	  2573: 							* returns d0=-1 if FAC1 < FAC2
                            	  2574: 
01:0000CC10 322F0006        	  2575: 	MOVE.w	6(sp),d1			* get STEP value exponent and sign
01:0000CC14 B141            	  2576: 	EOR.w		d0,d1				* EOR compare result with STEP exponent and sign
                            	  2577: 
01:0000CC16 4A00            	  2578: 	TST.b		d0				* test for =
01:0000CC18 6704            	  2579: 	BEQ.s		LAB_1A90			* branch if = (loop INcomplete)
                            	  2580: 
01:0000CC1A 4A01            	  2581: 	TST.b		d1				* test result
01:0000CC1C 6A0E            	  2582: 	BPL.s		LAB_1A9B			* branch if > (loop complete)
                            	  2583: 
                            	  2584: 							* loop back and do it all again
                            	  2585: LAB_1A90
01:0000CC1E 276F00140452    	  2586: 	MOVE.l	20(sp),Clinel(a3)		* reset current line
01:0000CC24 2A6F0018        	  2587: 	MOVE.l	24(sp),a5			* reset BASIC execute pointer
01:0000CC28 6000F976        	  2588: 	BRA		LAB_15C2			* go do interpreter inner loop
                            	  2589: 
                            	  2590: 							* loop complete so carry on
                            	  2591: LAB_1A9B
01:0000CC2C 4FEF001C        	  2592: 	ADDA.w	#28,sp			* add 28 to dump FOR structure
01:0000CC30 6100018C        	  2593: 	BSR		LAB_GBYT			* scan memory
01:0000CC34 B03C002C        	  2594: 	CMP.b		#$2C,d0			* compare with ","
01:0000CC38 6600F966        	  2595: 	BNE		LAB_15C2			* if not "," go do interpreter inner loop
                            	  2596: 
                            	  2597: 							* was "," so another NEXT variable to do
01:0000CC3C 6100017E        	  2598: 	BSR		LAB_IGBY			* else increment & scan memory
01:0000CC40 6100FF5E        	  2599: 	BSR		LAB_1A46			* do NEXT (var)
                            	  2600: 
                            	  2601: 
                            	  2602: *************************************************************************************
                            	  2603: *
                            	  2604: * evaluate expression & check is numeric, else do type mismatch
                            	  2605: 
                            	  2606: LAB_EVNM
01:0000CC44 6116            	  2607: 	BSR.s		LAB_EVEX			* evaluate expression
                            	  2608: 
                            	  2609: 
                            	  2610: *************************************************************************************
                            	  2611: *
                            	  2612: * check if source is numeric, else do type mismatch
                            	  2613: 
                            	  2614: LAB_CTNM
01:0000CC46 B040            	  2615: 	CMP.w		d0,d0				* required type is numeric so clear carry
                            	  2616: 
                            	  2617: 
                            	  2618: *************************************************************************************
                            	  2619: *
                            	  2620: * type match check, set C for string, clear C for numeric
                            	  2621: 
                            	  2622: LAB_CKTM
01:0000CC48 082B000705B5    	  2623: 	BTST.b	#7,Dtypef(a3)		* test data type flag, don't change carry
01:0000CC4E 6606            	  2624: 	BNE.s		LAB_1ABA			* branch if data type is string
                            	  2625: 
                            	  2626: 							* else data type was numeric
01:0000CC50 6500F502        	  2627: 	BCS		LAB_TMER			* if required type is string do type mismatch
                            	  2628: 							* error
                            	  2629: 
01:0000CC54 4E75            	  2630: 	RTS
                            	  2631: 							* data type was string, now check required type
                            	  2632: LAB_1ABA
01:0000CC56 6400F4FC        	  2633: 	BCC		LAB_TMER			* if required type is numeric do type mismatch
                            	  2634: 							* error
01:0000CC5A 4E75            	  2635: 	RTS
                            	  2636: 
                            	  2637: 
                            	  2638: *************************************************************************************
                            	  2639: *
                            	  2640: * this routine evaluates any type of expression. first it pushes an end marker so
                            	  2641: * it knows when the expression has been evaluated, this is a precedence value of zero.
                            	  2642: * next the first value is evaluated, this can be an in line value, either numeric or
                            	  2643: * string, a variable or array element of any type, a function or even an expression
                            	  2644: * in parenthesis. this value is kept in FAC_1
                            	  2645: * after the value is evaluated a test is made on the next BASIC program byte, if it
                            	  2646: * is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
                            	  2647: * in the comparison evaluation flag. this test loops until no more comparrison operators
                            	  2648: * are found or more than one of any type is found. in the last case an error is generated
                            	  2649: 
                            	  2650: * evaluate expression
                            	  2651: 
                            	  2652: LAB_EVEX
01:0000CC5C 534D            	  2653: 	SUBQ.w	#1,a5				* decrement BASIC execute pointer
                            	  2654: LAB_EVEZ
01:0000CC5E 7200            	  2655: 	MOVEQ		#0,d1				* clear precedence word
01:0000CC60 174105B5        	  2656: 	MOVE.b	d1,Dtypef(a3)		* clear the data type, $80=string, $40=integer,
                            	  2657: 							* $00=float
01:0000CC64 601C            	  2658: 	BRA.s		LAB_1ACD			* enter loop
                            	  2659: 
                            	  2660: * get vector, set up operator then continue evaluation
                            	  2661: 
                            	  2662: LAB_1B43						*
01:0000CC66 41FA22A6        	  2663: 	LEA		LAB_OPPT(pc),a0		* point to operator vector table
01:0000CC6A 30301002        	  2664: 	MOVE.w	2(a0,d1.w),d0		* get vector offset
01:0000CC6E 48700000        	  2665: 	PEA		(a0,d0.w)			* push vector
                            	  2666: 
01:0000CC72 2F2B0590        	  2667: 	MOVE.l	FAC1_m(a3),-(sp)		* push FAC1 mantissa
01:0000CC76 3F2B0594        	  2668: 	MOVE.w	FAC1_e(a3),-(sp)		* push sign and exponent
01:0000CC7A 1F2B05E3        	  2669: 	MOVE.b	comp_f(a3),-(sp)		* push comparison evaluation flag
                            	  2670: 
01:0000CC7E 32301000        	  2671: 	MOVE.w	(a0,d1.w),d1		* get precedence value
                            	  2672: LAB_1ACD
01:0000CC82 3F01            	  2673: 	MOVE.w	d1,-(sp)			* push precedence value
01:0000CC84 610000E4        	  2674: 	BSR		LAB_GVAL			* get value from line
01:0000CC88 177C000005E3    	  2675: 	MOVE.b	#$00,comp_f(a3)		* clear compare function flag
                            	  2676: LAB_1ADB
01:0000CC8E 6100012E        	  2677: 	BSR		LAB_GBYT			* scan memory
                            	  2678: LAB_1ADE
01:0000CC92 903C00BC        	  2679: 	SUB.b		#TK_GT,d0			* subtract token for > (lowest compare function)
01:0000CC96 652A            	  2680: 	BCS.s		LAB_1AFA			* branch if < TK_GT
                            	  2681: 
01:0000CC98 B03C0003        	  2682: 	CMP.b		#$03,d0			* compare with ">" to "<" tokens
01:0000CC9C 650A            	  2683: 	BCS.s		LAB_1AE0			* branch if <= TK_SGN (is compare function)
                            	  2684: 
01:0000CC9E 4A2B05E3        	  2685: 	TST.b		comp_f(a3)			* test compare function flag
01:0000CCA2 6660            	  2686: 	BNE.s		LAB_1B2A			* branch if compare function
                            	  2687: 
01:0000CCA4 60000086        	  2688: 	BRA		LAB_1B78			* go do functions
                            	  2689: 
                            	  2690: 							* was token for > = or < (d0 = 0, 1 or 2)
                            	  2691: LAB_1AE0
01:0000CCA8 7201            	  2692: 	MOVEQ		#1,d1				* set to 0000 0001
01:0000CCAA E121            	  2693: 	ASL.b		d0,d1				* 1 if >, 2 if =, 4 if <
01:0000CCAC 102B05E3        	  2694: 	MOVE.b	comp_f(a3),d0		* copy old compare function flag
01:0000CCB0 B32B05E3        	  2695: 	EOR.b		d1,comp_f(a3)		* EOR in this compare function bit
01:0000CCB4 B02B05E3        	  2696: 	CMP.b		comp_f(a3),d0		* compare old with new compare function flag
01:0000CCB8 6400F4C6        	  2697: 	BCC		LAB_SNER			* if new <= old comp_f do syntax error and warm
                            	  2698: 							* start, there was more than one <, = or >
01:0000CCBC 610000FE        	  2699: 	BSR		LAB_IGBY			* increment & scan memory
01:0000CCC0 60D0            	  2700: 	BRA.s		LAB_1ADE			* go do next character
                            	  2701: 
                            	  2702: 							* token is < ">" or > "<" tokens
                            	  2703: LAB_1AFA
01:0000CCC2 4A2B05E3        	  2704: 	TST.b		comp_f(a3)			* test compare function flag
01:0000CCC6 663C            	  2705: 	BNE.s		LAB_1B2A			* branch if compare function
                            	  2706: 
                            	  2707: 							* was < TK_GT so is operator or lower
01:0000CCC8 D03C000A        	  2708: 	ADD.b	#(TK_GT-TK_PLUS),d0		* add # of operators (+ - * / ^ AND OR EOR)
01:0000CCCC 645E            	  2709: 	BCC.s		LAB_1B78			* branch if < + operator
                            	  2710: 
01:0000CCCE 6608            	  2711: 	BNE.s		LAB_1B0B			* branch if not + token
                            	  2712: 
01:0000CCD0 4A2B05B5        	  2713: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2714: 							* $00=float
01:0000CCD4 6B000872        	  2715: 	BMI		LAB_224D			* type is string & token was +
                            	  2716: 
                            	  2717: LAB_1B0B
01:0000CCD8 7200            	  2718: 	MOVEQ		#0,d1				* clear longword
01:0000CCDA D000            	  2719: 	ADD.b		d0,d0				* *2
01:0000CCDC D000            	  2720: 	ADD.b		d0,d0				* *4
01:0000CCDE 1200            	  2721: 	MOVE.b	d0,d1				* copy to index
                            	  2722: LAB_1B13
01:0000CCE0 301F            	  2723: 	MOVE.w	(sp)+,d0			* pull previous precedence
01:0000CCE2 41FA222A        	  2724: 	LEA		LAB_OPPT(pc),a0		* set pointer to operator table
01:0000CCE6 B0701000        	  2725: 	CMP.w		(a0,d1.w),d0		* compare with this opperator precedence
01:0000CCEA 6446            	  2726: 	BCC.s		LAB_1B7D			* branch if previous precedence (d0) >=
                            	  2727: 
01:0000CCEC 6100FF58        	  2728: 	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
                            	  2729: LAB_1B1C
01:0000CCF0 3F00            	  2730: 	MOVE.w	d0,-(sp)			* save precedence
                            	  2731: LAB_1B1D
01:0000CCF2 6100FF72        	  2732: 	BSR		LAB_1B43			* get vector, set-up operator and continue
                            	  2733: 							* evaluation
01:0000CCF6 301F            	  2734: 	MOVE.w	(sp)+,d0			* restore precedence
01:0000CCF8 222B05D8        	  2735: 	MOVE.l	prstk(a3),d1		* get stacked function pointer
01:0000CCFC 6A22            	  2736: 	BPL.s		LAB_1B3C			* branch if stacked values
                            	  2737: 
01:0000CCFE 3000            	  2738: 	MOVE.w	d0,d0				* copy precedence (set flags)
01:0000CD00 672E            	  2739: 	BEQ.s		LAB_1B7B			* exit if done
                            	  2740: 
01:0000CD02 603C            	  2741: 	BRA.s		LAB_1B86			* else pop FAC2 & return (do function)
                            	  2742: 
                            	  2743: 							* was compare function (< = >)
                            	  2744: LAB_1B2A
01:0000CD04 102B05B5        	  2745: 	MOVE.b	Dtypef(a3),d0		* get data type flag
01:0000CD08 122B05E3        	  2746: 	MOVE.b	comp_f(a3),d1		* get compare function flag
01:0000CD0C D000            	  2747: 	ADD.b		d0,d0				* string bit flag into X bit
01:0000CD0E D301            	  2748: 	ADDX.b	d1,d1				* shift compare function flag
                            	  2749: 
01:0000CD10 177C000005B5    	  2750: 	MOVE.b	#0,Dtypef(a3)		* clear data type flag, $00=float
01:0000CD16 174105E3        	  2751: 	MOVE.b	d1,comp_f(a3)		* save new compare function flag
01:0000CD1A 534D            	  2752: 	SUBQ.w	#1,a5				* decrement BASIC execute pointer
01:0000CD1C 7230            	  2753: 	MOVEQ		#(TK_LT-TK_PLUS)*4,d1	* set offset to last operator entry
01:0000CD1E 60C0            	  2754: 	BRA.s		LAB_1B13			* branch always
                            	  2755: 
                            	  2756: LAB_1B3C
01:0000CD20 41FA21EC        	  2757: 	LEA		LAB_OPPT(pc),a0		* point to function vector table
01:0000CD24 B0701000        	  2758: 	CMP.w		(a0,d1.w),d0		* compare with this opperator precedence
01:0000CD28 6416            	  2759: 	BCC.s		LAB_1B86			* branch if d0 >=, pop FAC2 & return
                            	  2760: 
01:0000CD2A 60C4            	  2761: 	BRA.s		LAB_1B1C			* branch always
                            	  2762: 
                            	  2763: * do functions
                            	  2764: 
                            	  2765: LAB_1B78
01:0000CD2C 72FF            	  2766: 	MOVEQ		#-1,d1			* flag all done
01:0000CD2E 301F            	  2767: 	MOVE.w	(sp)+,d0			* pull precedence word
                            	  2768: LAB_1B7B
01:0000CD30 6732            	  2769: 	BEQ.s		LAB_1B9D			* exit if done
                            	  2770: 
                            	  2771: LAB_1B7D
01:0000CD32 B07C0064        	  2772: 	CMP.w		#$64,d0			* compare previous precedence with $64
01:0000CD36 6704            	  2773: 	BEQ.s		LAB_1B84			* branch if was $64 (< function can be string)
                            	  2774: 
01:0000CD38 6100FF0C        	  2775: 	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
                            	  2776: LAB_1B84
01:0000CD3C 274105D8        	  2777: 	MOVE.l	d1,prstk(a3)		* save current operator index
                            	  2778: 
                            	  2779: 							* pop FAC2 & return
                            	  2780: LAB_1B86
01:0000CD40 101F            	  2781: 	MOVE.b	(sp)+,d0			* pop comparison evaluation flag
01:0000CD42 1200            	  2782: 	MOVE.b	d0,d1				* copy comparison evaluation flag
01:0000CD44 E208            	  2783: 	LSR.b		#1,d0				* shift out comparison evaluation lowest bit
01:0000CD46 174005E1        	  2784: 	MOVE.b	d0,Cflag(a3)		* save comparison evaluation flag
01:0000CD4A 375F059C        	  2785: 	MOVE.w	(sp)+,FAC2_e(a3)		* pop exponent and sign
01:0000CD4E 275F0598        	  2786: 	MOVE.l	(sp)+,FAC2_m(a3)		* pop mantissa
01:0000CD52 176B059D059E    	  2787: 	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* copy FAC2 sign
01:0000CD58 102B0595        	  2788: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:0000CD5C B12B059E        	  2789: 	EOR.b		d0,FAC_sc(a3)		* EOR FAC1 sign and set sign compare
                            	  2790: 
01:0000CD60 E209            	  2791: 	LSR.b		#1,d1				* type bit into X and C
01:0000CD62 4E75            	  2792: 	RTS
                            	  2793: 
                            	  2794: LAB_1B9D
01:0000CD64 102B0594        	  2795: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:0000CD68 4E75            	  2796: 	RTS
                            	  2797: 
                            	  2798: 
                            	  2799: *************************************************************************************
                            	  2800: *
                            	  2801: * get a value from the BASIC line
                            	  2802: 
                            	  2803: LAB_GVAL
01:0000CD6A 6150            	  2804: 	BSR.s		LAB_IGBY			* increment & scan memory
01:0000CD6C 65001B28        	  2805: 	BCS		LAB_2887			* if numeric get FAC1 from string & return
                            	  2806: 
01:0000CD70 4A00            	  2807: 	TST.b		d0				* test byte
01:0000CD72 6B00008C        	  2808: 	BMI		LAB_1BD0			* if -ve go test token values
                            	  2809: 
                            	  2810: 							* else it is either a string, number, variable
                            	  2811: 							* or (<expr>)
01:0000CD76 B03C0024        	  2812: 	CMP.b		#'$',d0			* compare with "$"
01:0000CD7A 67001B1A        	  2813: 	BEQ		LAB_2887			* if "$" get hex number from string & return
                            	  2814: 
01:0000CD7E B03C0025        	  2815: 	CMP.b		#'%',d0			* else compare with "%"
01:0000CD82 67001B12        	  2816: 	BEQ		LAB_2887			* if "%" get binary number from string & return
                            	  2817: 
01:0000CD86 B03C002E        	  2818: 	CMP.b		#$2E,d0			* compare with "."
01:0000CD8A 67001B0A        	  2819: 	BEQ		LAB_2887			* if so get FAC1 from string and return
                            	  2820: 							* (e.g. .123)
                            	  2821: 
                            	  2822: 							* wasn't a number so ...
01:0000CD8E B03C0022        	  2823: 	CMP.b		#$22,d0			* compare with "
01:0000CD92 660C            	  2824: 	BNE.s		LAB_1BF3			* if not open quote it must be a variable or
                            	  2825: 							* open bracket
                            	  2826: 
                            	  2827: 							* was open quote so get the enclosed string
                            	  2828: 
                            	  2829: * print "..." string to string stack
                            	  2830: 
                            	  2831: LAB_1BC1
01:0000CD94 101D            	  2832: 	MOVE.b	(a5)+,d0			* increment BASIC execute pointer (past ")
                            	  2833: 							* fastest/shortest method
01:0000CD96 204D            	  2834: 	MOVEA.l	a5,a0				* copy basic execute pointer (string start)
01:0000CD98 61000636        	  2835: 	BSR		LAB_20AE			* print " terminated string to stack
01:0000CD9C 2A4A            	  2836: 	MOVEA.l	a2,a5				* restore BASIC execute pointer from temp
01:0000CD9E 4E75            	  2837: 	RTS
                            	  2838: 
                            	  2839: * get value from line .. continued
                            	  2840: 							* wasn't any sort of number so ...
                            	  2841: LAB_1BF3
01:0000CDA0 B03C0028        	  2842: 	CMP.b		#'(',d0			* compare with "("
01:0000CDA4 6640            	  2843: 	BNE.s		LAB_1C18			* if not "(" get (var) and return value in FAC1
                            	  2844: 							* and $ flag
                            	  2845: 
                            	  2846: 
                            	  2847: *************************************************************************************
                            	  2848: *
                            	  2849: * evaluate expression within parentheses
                            	  2850: 
                            	  2851: LAB_1BF7
01:0000CDA6 6100FEB6        	  2852: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
                            	  2853: 
                            	  2854: 
                            	  2855: *************************************************************************************
                            	  2856: *
                            	  2857: * all the 'scan for' routines return the character after the sought character
                            	  2858: 
                            	  2859: * scan for ")", else do syntax error, then warm start
                            	  2860: 
                            	  2861: LAB_1BFB
01:0000CDAA 7029            	  2862: 	MOVEQ		#$29,d0			* load d0 with ")"
01:0000CDAC 6006            	  2863: 	BRA.s		LAB_SCCA
                            	  2864: 
                            	  2865: 
                            	  2866: *************************************************************************************
                            	  2867: *
                            	  2868: * scan for "," and get byte, else do Syntax error then warm start
                            	  2869: 
                            	  2870: LAB_SCGB
01:0000CDAE 487A096C        	  2871: 	PEA		LAB_GTBY(pc)		* return address is to get byte parameter
                            	  2872: 
                            	  2873: 
                            	  2874: *************************************************************************************
                            	  2875: *
                            	  2876: * scan for ",", else do syntax error, then warm start
                            	  2877: 
                            	  2878: LAB_1C01
01:0000CDB2 702C            	  2879: 	MOVEQ		#$2C,d0			* load d0 with ","
                            	  2880: 
                            	  2881: 
                            	  2882: *************************************************************************************
                            	  2883: *
                            	  2884: * scan for CHR$(d0) , else do syntax error, then warm start
                            	  2885: 
                            	  2886: LAB_SCCA
01:0000CDB4 B01D            	  2887: 	CMP.b		(a5)+,d0			* check next byte is = d0
01:0000CDB6 6706            	  2888: 	BEQ.s		LAB_GBYT			* if so go get next
                            	  2889: 
01:0000CDB8 6000F3C6        	  2890: 	BRA		LAB_SNER			* else do syntax error/warm start
                            	  2891: 
                            	  2892: 
                            	  2893: *************************************************************************************
                            	  2894: *
                            	  2895: * BASIC increment and scan memory routine
                            	  2896: 
                            	  2897: LAB_IGBY
01:0000CDBC 101D            	  2898: 	MOVE.b	(a5)+,d0			* get byte & increment pointer
                            	  2899: 
                            	  2900: * scan memory routine, exit with Cb = 1 if numeric character
                            	  2901: * also skips any spaces encountered
                            	  2902: 
                            	  2903: LAB_GBYT
01:0000CDBE 1015            	  2904: 	MOVE.b	(a5),d0			* get byte
                            	  2905: 
01:0000CDC0 B03C0020        	  2906: 	CMP.b		#$20,d0			* compare with " "
01:0000CDC4 67F6            	  2907: 	BEQ.s		LAB_IGBY			* if " " go do next
                            	  2908: 
                            	  2909: * test current BASIC byte, exit with Cb = 1 if numeric character
                            	  2910: 
01:0000CDC6 B03C00A9        	  2911: 	CMP.b		#TK_ELSE,d0			* compare with the token for ELSE
01:0000CDCA 640C            	  2912: 	BCC.s		RTS_001			* exit if >= (not numeric, carry clear)
                            	  2913: 
01:0000CDCC B03C003A        	  2914: 	CMP.b		#$3A,d0			* compare with ":"
01:0000CDD0 6406            	  2915: 	BCC.s		RTS_001			* exit if >= (not numeric, carry clear)
                            	  2916: 
01:0000CDD2 7CD0            	  2917: 	MOVEQ		#$D0,d6			* set -"0"
01:0000CDD4 D006            	  2918: 	ADD.b		d6,d0				* add -"0"
01:0000CDD6 9006            	  2919: 	SUB.b		d6,d0				* subtract -"0"
                            	  2920: RTS_001						* carry set if byte = "0"-"9"
01:0000CDD8 4E75            	  2921: 	RTS
                            	  2922: 
                            	  2923: 
                            	  2924: *************************************************************************************
                            	  2925: *
                            	  2926: * set-up for - operator
                            	  2927: 
                            	  2928: LAB_1C11
01:0000CDDA 6100FE6A        	  2929: 	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
01:0000CDDE 7228            	  2930: 	MOVEQ	#(TK_GT-TK_PLUS)*4,d1		* set offset from base to - operator
                            	  2931: LAB_1C13
01:0000CDE0 588F            	  2932: 	LEA		4(sp),sp			* dump GVAL return address
01:0000CDE2 6000FF0E        	  2933: 	BRA		LAB_1B1D			* continue evaluating expression
                            	  2934: 
                            	  2935: 
                            	  2936: *************************************************************************************
                            	  2937: *
                            	  2938: * variable name set-up
                            	  2939: * get (var), return value in FAC_1 & data type flag
                            	  2940: 
                            	  2941: LAB_1C18
01:0000CDE6 610001E2        	  2942: 	BSR		LAB_GVAR			* get variable address in a0
                            	  2943: 
                            	  2944: * if you want a non existant variable to return a null value then set the novar
                            	  2945: * value at the top of this file to some non zero value
                            	  2946: 
                            	  2947:  ifne	novar
                            	  2948: 
                            	  2949: 	BNE.s		LAB_1C19			* if it exists return it
                            	  2950: 
                            	  2951: 	LEA.l		LAB_1D96(pc),a0		* else return a null descriptor/pointer
                            	  2952: 
                            	  2953:  endc
                            	  2954: 
                            	  2955: * return existing variable value
                            	  2956: 
                            	  2957: LAB_1C19
01:0000CDEA 4A2B05B5        	  2958: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  2959: 							* $00=float
01:0000CDEE 67000D84        	  2960: 	BEQ		LAB_UFAC			* if float unpack memory (a0) into FAC1 and
                            	  2961: 							* return
                            	  2962: 
01:0000CDF2 6A06            	  2963: 	BPL.s		LAB_1C1A			* if integer unpack memory (a0) into FAC1
                            	  2964: 							* and return
                            	  2965: 
01:0000CDF4 27480590        	  2966: 	MOVE.l	a0,FAC1_m(a3)		* else save descriptor pointer in FAC1
01:0000CDF8 4E75            	  2967: 	RTS
                            	  2968: 
                            	  2969: LAB_1C1A
01:0000CDFA 2010            	  2970: 	MOVE.l	(a0),d0			* get integer value
01:0000CDFC 600004BC        	  2971: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  2972: 
                            	  2973: 
                            	  2974: *************************************************************************************
                            	  2975: *
                            	  2976: * get value from line .. continued
                            	  2977: * do tokens
                            	  2978: 
                            	  2979: LAB_1BD0
01:0000CE00 B03C00B3        	  2980: 	CMP.b		#TK_MINUS,d0		* compare with token for -
01:0000CE04 67D4            	  2981: 	BEQ.s		LAB_1C11			* branch if - token (do set-up for - operator)
                            	  2982: 
                            	  2983: 							* wasn't -123 so ...
01:0000CE06 B03C00B2        	  2984: 	CMP.b		#TK_PLUS,d0			* compare with token for +
01:0000CE0A 6700FF5E        	  2985: 	BEQ		LAB_GVAL			* branch if + token (+n = n so ignore leading +)
                            	  2986: 
01:0000CE0E B03C00AE        	  2987: 	CMP.b		#TK_NOT,d0			* compare with token for NOT
01:0000CE12 6606            	  2988: 	BNE.s		LAB_1BE7			* branch if not token for NOT
                            	  2989: 
                            	  2990: 							* was NOT token
01:0000CE14 323C002C        	  2991: 	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1	* offset to NOT function
01:0000CE18 60C6            	  2992: 	BRA.s		LAB_1C13			* do set-up for function then execute
                            	  2993: 
                            	  2994: 							* wasn't +, - or NOT so ...
                            	  2995: LAB_1BE7
01:0000CE1A B03C00AB        	  2996: 	CMP.b		#TK_FN,d0			* compare with token for FN
01:0000CE1E 67000514        	  2997: 	BEQ		LAB_201E			* if FN go evaluate FNx
                            	  2998: 
                            	  2999: 							* wasn't +, -, NOT or FN so ...
01:0000CE22 903C00BF        	  3000: 	SUB.b		#TK_SGN,d0			* compare with token for SGN & normalise
01:0000CE26 6500F358        	  3001: 	BCS		LAB_SNER			* if < SGN token then do syntax error
                            	  3002: 
                            	  3003: * get value from line .. continued
                            	  3004: * only functions left so set up function references
                            	  3005: 
                            	  3006: * new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
                            	  3007: * to process function calls. now the function vector is computed and pushed on the stack
                            	  3008: * and the preprocess offset is read. if the preprocess offset is non zero then the vector
                            	  3009: * is calculated and the routine called, if not this routine just does RTS. whichever
                            	  3010: * happens the RTS at the end of this routine, or the preprocess routine calls, the
                            	  3011: * function code
                            	  3012: 
                            	  3013: * this also removes some less than elegant code that was used to bypass type checking
                            	  3014: * for functions that returned strings
                            	  3015: 
01:0000CE2A C07C007F        	  3016: 	AND.w		#$7F,d0			* mask byte
01:0000CE2E D040            	  3017: 	ADD.w		d0,d0				* *2 (2 bytes per function offset)
                            	  3018: 
01:0000CE30 41FA2090        	  3019: 	LEA		LAB_FTBL(pc),a0		* pointer to functions vector table
01:0000CE34 32300000        	  3020: 	MOVE.w	(a0,d0.w),d1		* get function vector offset
01:0000CE38 48701000        	  3021: 	PEA		(a0,d1.w)			* push function vector
                            	  3022: 
01:0000CE3C 41FA2038        	  3023: 	LEA		LAB_FTPP(pc),a0		* pointer to functions preprocess vector table
01:0000CE40 30300000        	  3024: 	MOVE.w	(a0,d0.w),d0		* get function preprocess vector offset
01:0000CE44 6712            	  3025: 	BEQ.s		LAB_1C2A			* no preprocess vector so go do function
                            	  3026: 
01:0000CE46 41F00000        	  3027: 	LEA		(a0,d0.w),a0		* get function preprocess vector
01:0000CE4A 4ED0            	  3028: 	JMP		(a0)				* go do preprocess routine then function
                            	  3029: 
                            	  3030: 
                            	  3031: *************************************************************************************
                            	  3032: *
                            	  3033: * process string expression in parenthesis
                            	  3034: 
                            	  3035: LAB_PPFS
01:0000CE4C 6100FF58        	  3036: 	BSR		LAB_1BF7			* process expression in parenthesis
01:0000CE50 4A2B05B5        	  3037: 	TST.b		Dtypef(a3)			* test data type
01:0000CE54 6A00F2FE        	  3038: 	BPL		LAB_TMER			* if numeric do Type missmatch Error/warm start
                            	  3039: 
                            	  3040: LAB_1C2A
01:0000CE58 4E75            	  3041: 	RTS						* else do function
                            	  3042: 
                            	  3043: 
                            	  3044: *************************************************************************************
                            	  3045: *
                            	  3046: * process numeric expression in parenthesis
                            	  3047: 
                            	  3048: LAB_PPFN
01:0000CE5A 6100FF4A        	  3049: 	BSR		LAB_1BF7			* process expression in parenthesis
01:0000CE5E 4A2B05B5        	  3050: 	TST.b		Dtypef(a3)			* test data type
01:0000CE62 6B00F2F0        	  3051: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  3052: 
01:0000CE66 4E75            	  3053: 	RTS						* else do function
                            	  3054: 
                            	  3055: 
                            	  3056: *************************************************************************************
                            	  3057: *
                            	  3058: * set numeric data type and increment BASIC execute pointer
                            	  3059: 
                            	  3060: LAB_PPBI
01:0000CE68 177C000005B5    	  3061: 	MOVE.b	#$00,Dtypef(a3)		* clear data type flag, $00=float
01:0000CE6E 101D            	  3062: 	MOVE.b	(a5)+,d0			* get next BASIC byte
01:0000CE70 4E75            	  3063: 	RTS						* do function
                            	  3064: 
                            	  3065: 
                            	  3066: *************************************************************************************
                            	  3067: *
                            	  3068: * process string for LEFT$, RIGHT$ or MID$
                            	  3069: 
                            	  3070: LAB_LRMS
01:0000CE72 6100FDEA        	  3071: 	BSR		LAB_EVEZ			* evaluate (should be string) expression
01:0000CE76 4A2B05B5        	  3072: 	TST.b		Dtypef(a3)			* test data type flag
01:0000CE7A 6A00F2D8        	  3073: 	BPL		LAB_TMER			* if type is not string do type mismatch error
                            	  3074: 
01:0000CE7E 141D            	  3075: 	MOVE.b	(a5)+,d2			* get BASIC byte
01:0000CE80 B43C002C        	  3076: 	CMP.b		#',',d2			* compare with comma
01:0000CE84 6600F2FA        	  3077: 	BNE		LAB_SNER			* if not "," go do syntax error/warm start
                            	  3078: 
01:0000CE88 2F2B0590        	  3079: 	MOVE.l	FAC1_m(a3),-(sp)		* save descriptor pointer
01:0000CE8C 610008A2        	  3080: 	BSR		LAB_GTWO			* get word parameter, result in d0 and Itemp
01:0000CE90 205F            	  3081: 	MOVEA.l	(sp)+,a0			* restore descriptor pointer
01:0000CE92 4E75            	  3082: 	RTS						* do function
                            	  3083: 
                            	  3084: 
                            	  3085: *************************************************************************************
                            	  3086: *
                            	  3087: * process numeric expression(s) for BIN$ or HEX$
                            	  3088: 
                            	  3089: LAB_BHSS
01:0000CE94 6100FDC8        	  3090: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
01:0000CE98 4A2B05B5        	  3091: 	TST.b		Dtypef(a3)			* test data type
01:0000CE9C 6B00F2B6        	  3092: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  3093: 
01:0000CEA0 61000DC4        	  3094: 	BSR		LAB_2831			* convert FAC1 floating to fixed
                            	  3095: 							* result in d0 and Itemp
01:0000CEA4 7200            	  3096: 	MOVEQ		#0,d1				* set default to no leading "0"s
01:0000CEA6 141D            	  3097: 	MOVE.b	(a5)+,d2			* get BASIC byte
01:0000CEA8 B43C002C        	  3098: 	CMP.b		#',',d2			* compare with comma
01:0000CEAC 660C            	  3099: 	BNE.s		LAB_BHCB			* if not "," go check close bracket
                            	  3100: 
01:0000CEAE 2F00            	  3101: 	MOVE.l	d0,-(sp)			* copy number to stack
01:0000CEB0 6100086A        	  3102: 	BSR		LAB_GTBY			* get byte value
01:0000CEB4 2200            	  3103: 	MOVE.l	d0,d1				* copy leading 0s #
01:0000CEB6 201F            	  3104: 	MOVE.l	(sp)+,d0			* restore number from stack
01:0000CEB8 141D            	  3105: 	MOVE.b	(a5)+,d2			* get BASIC byte
                            	  3106: LAB_BHCB
01:0000CEBA B43C0029        	  3107: 	CMP.b		#')',d2			* compare with close bracket
01:0000CEBE 6600F2C0        	  3108: 	BNE		LAB_SNER			* if not ")" do Syntax Error/warm start
                            	  3109: 
01:0000CEC2 4E75            	  3110: 	RTS						* go do function
                            	  3111: 
                            	  3112: 
                            	  3113: *************************************************************************************
                            	  3114: *
                            	  3115: * perform EOR
                            	  3116: 
                            	  3117: LAB_EOR
01:0000CEC4 6116            	  3118: 	BSR.s		GetFirst			* get two values for OR, AND or EOR
                            	  3119: 							* first in d0, and Itemp, second in d2
01:0000CEC6 B580            	  3120: 	EOR.l		d2,d0				* EOR values
01:0000CEC8 600003F0        	  3121: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3122: 
                            	  3123: 
                            	  3124: *************************************************************************************
                            	  3125: *
                            	  3126: * perform OR
                            	  3127: 
                            	  3128: LAB_OR
01:0000CECC 610E            	  3129: 	BSR.s		GetFirst			* get two values for OR, AND or EOR
                            	  3130: 							* first in d0, and Itemp, second in d2
01:0000CECE 8082            	  3131: 	OR.l		d2,d0				* do OR
01:0000CED0 600003E8        	  3132: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3133: 
                            	  3134: 
                            	  3135: *************************************************************************************
                            	  3136: *
                            	  3137: * perform AND
                            	  3138: 
                            	  3139: LAB_AND
01:0000CED4 6106            	  3140: 	BSR.s		GetFirst			* get two values for OR, AND or EOR
                            	  3141: 							* first in d0, and Itemp, second in d2
01:0000CED6 C082            	  3142: 	AND.l		d2,d0				* do AND
01:0000CED8 600003E0        	  3143: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3144: 
                            	  3145: 
                            	  3146: *************************************************************************************
                            	  3147: *
                            	  3148: * get two values for OR, AND, EOR
                            	  3149: * first in d0, second in d2
                            	  3150: 
                            	  3151: GetFirst
01:0000CEDC 61000228        	  3152: 	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
                            	  3153: 							* result in d0 and Itemp
01:0000CEE0 2400            	  3154: 	MOVE.l	d0,d2				* copy second value
01:0000CEE2 61000CEA        	  3155: 	BSR		LAB_279B			* copy FAC2 to FAC1, get first value in
                            	  3156: 							* expression
01:0000CEE6 6000021E        	  3157: 	BRA		LAB_EVIR			* evaluate integer expression (no sign check)
                            	  3158: 							* result in d0 and Itemp & return
                            	  3159: 
                            	  3160: 
                            	  3161: *************************************************************************************
                            	  3162: *
                            	  3163: * perform NOT
                            	  3164: 
                            	  3165: LAB_EQUAL
01:0000CEEA 6100021A        	  3166: 	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
                            	  3167: 							* result in d0 and Itemp
01:0000CEEE 4680            	  3168: 	NOT.l		d0				* bitwise invert
01:0000CEF0 600003C8        	  3169: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3170: 
                            	  3171: 
                            	  3172: *************************************************************************************
                            	  3173: *
                            	  3174: * perform comparisons
                            	  3175: * do < compare
                            	  3176: 
                            	  3177: LAB_LTHAN
01:0000CEF4 6100FD52        	  3178: 	BSR		LAB_CKTM			* type match check, set C for string
01:0000CEF8 6506            	  3179: 	BCS.s		LAB_1CAE			* branch if string
                            	  3180: 
                            	  3181: 							* do numeric < compare
01:0000CEFA 61000D3E        	  3182: 	BSR		LAB_27FA			* compare FAC1 with FAC2
                            	  3183: 							* returns d0=+1 if FAC1 > FAC2
                            	  3184: 							* returns d0= 0 if FAC1 = FAC2
                            	  3185: 							* returns d0=-1 if FAC1 < FAC2
01:0000CEFE 6042            	  3186: 	BRA.s		LAB_1CF2			* process result
                            	  3187: 
                            	  3188: 							* do string < compare
                            	  3189: LAB_1CAE
01:0000CF00 177C000005B5    	  3190: 	MOVE.b	#$00,Dtypef(a3)		* clear data type, $80=string, $40=integer,
                            	  3191: 							* $00=float
01:0000CF06 610006B4        	  3192: 	BSR		LAB_22B6			* pop string off descriptor stack, or from top
                            	  3193: 							* of string space returns d0 = length,
                            	  3194: 							* a0 = pointer
01:0000CF0A 2248            	  3195: 	MOVEA.l	a0,a1				* copy string 2 pointer
01:0000CF0C 2200            	  3196: 	MOVE.l	d0,d1				* copy string 2 length
01:0000CF0E 206B0598        	  3197: 	MOVEA.l	FAC2_m(a3),a0		* get string 1 descriptor pointer
01:0000CF12 610006AC        	  3198: 	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  3199: 							* d0 = length, a0 = pointer
01:0000CF16 2400            	  3200: 	MOVE.l	d0,d2				* copy length
01:0000CF18 6604            	  3201: 	BNE.s		LAB_1CB5			* branch if not null string
                            	  3202: 
01:0000CF1A 4A81            	  3203: 	TST.l		d1				* test if string 2 is null also
01:0000CF1C 6724            	  3204: 	BEQ.s		LAB_1CF2			* if so do string 1 = string 2
                            	  3205: 
                            	  3206: LAB_1CB5
01:0000CF1E 9481            	  3207: 	SUB.l		d1,d2				* subtract string 2 length
01:0000CF20 670C            	  3208: 	BEQ.s		LAB_1CD5			* branch if strings = length
                            	  3209: 
01:0000CF22 6504            	  3210: 	BCS.s		LAB_1CD4			* branch if string 1 < string 2
                            	  3211: 
01:0000CF24 70FF            	  3212: 	MOVEQ		#-1,d0			* set for string 1 > string 2
01:0000CF26 6008            	  3213: 	BRA.s		LAB_1CD6			* go do character comapare
                            	  3214: 
                            	  3215: LAB_1CD4
01:0000CF28 2200            	  3216: 	MOVE.l	d0,d1				* string 1 length is compare length
01:0000CF2A 7001            	  3217: 	MOVEQ		#1,d0				* and set for string 1 < string 2
01:0000CF2C 6002            	  3218: 	BRA.s		LAB_1CD6			* go do character comapare
                            	  3219: 
                            	  3220: LAB_1CD5
01:0000CF2E 2002            	  3221: 	MOVE.l	d2,d0				* set for string 1 = string 2
                            	  3222: LAB_1CD6
01:0000CF30 5381            	  3223: 	SUBQ.l	#1,d1				* adjust length for DBcc loop
                            	  3224: 
                            	  3225: 							* d1 is length to compare, d0 is <=> for length
                            	  3226: 							* a0 is string 1 pointer, a1 is string 2 pointer
                            	  3227: LAB_1CE6
01:0000CF32 B308            	  3228: 	CMPM.b	(a0)+,(a1)+			* compare string bytes (1 with 2)
01:0000CF34 56C9FFFC        	  3229: 	DBNE		d1,LAB_1CE6			* loop if same and not end yet
                            	  3230: 
01:0000CF38 6708            	  3231: 	BEQ.s		LAB_1CF2			* if = to here, then go use length compare
                            	  3232: 
01:0000CF3A 6404            	  3233: 	BCC.s		LAB_1CDB			* else branch if string 1 > string 2
                            	  3234: 
01:0000CF3C 70FF            	  3235: 	MOVEQ		#-1,d0			* else set for string 1 < string 2
01:0000CF3E 6002            	  3236: 	BRA.s		LAB_1CF2			* go set result
                            	  3237: 
                            	  3238: LAB_1CDB
01:0000CF40 7001            	  3239: 	MOVEQ		#1,d0				* and set for string 1 > string 2
                            	  3240: 
                            	  3241: LAB_1CF2
01:0000CF42 5200            	  3242: 	ADDQ.b	#1,d0				* make result 0, 1 or 2
01:0000CF44 1200            	  3243: 	MOVE.b	d0,d1				* copy to d1
01:0000CF46 7001            	  3244: 	MOVEQ		#1,d0				* set d0 longword
01:0000CF48 E338            	  3245: 	ROL.b		d1,d0				* make 1, 2 or 4 (result = flag bit)
01:0000CF4A C02B05E1        	  3246: 	AND.b		Cflag(a3),d0		* AND with comparison evaluation flag
01:0000CF4E 67000CD2        	  3247: 	BEQ		LAB_27DB			* exit if not a wanted result (i.e. false)
                            	  3248: 
01:0000CF52 70FF            	  3249: 	MOVEQ		#-1,d0			* else set -1 (true)
01:0000CF54 60000CCC        	  3250: 	BRA		LAB_27DB			* save d0 as integer & return
                            	  3251: 
                            	  3252: 
                            	  3253: LAB_1CFE
01:0000CF58 6100FE58        	  3254: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
                            	  3255: 
                            	  3256: 
                            	  3257: *************************************************************************************
                            	  3258: *
                            	  3259: * perform DIM
                            	  3260: 
                            	  3261: LAB_DIM
01:0000CF5C 72FF            	  3262: 	MOVEQ		#-1,d1			* set "DIM" flag
01:0000CF5E 6170            	  3263: 	BSR.s		LAB_1D10			* search for or dimension a variable
01:0000CF60 6100FE5C        	  3264: 	BSR		LAB_GBYT			* scan memory
01:0000CF64 66F2            	  3265: 	BNE.s		LAB_1CFE			* loop and scan for "," if not null
                            	  3266: 
01:0000CF66 4E75            	  3267: 	RTS
                            	  3268: 
                            	  3269: 
                            	  3270: *************************************************************************************
                            	  3271: *
                            	  3272: * perform << (left shift)
                            	  3273: 
                            	  3274: LAB_LSHIFT
01:0000CF68 612E            	  3275: 	BSR.s		GetPair			* get an integer and byte pair
                            	  3276: 							* byte is in d2, integer is in d0 and Itemp
01:0000CF6A 6708            	  3277: 	BEQ.s		NoShift			* branch if byte zero
                            	  3278: 
01:0000CF6C B43C0020        	  3279: 	CMP.b		#$20,d2			* compare bit count with 32d
01:0000CF70 6420            	  3280: 	BCC.s		TooBig			* branch if >=
                            	  3281: 
01:0000CF72 E5A0            	  3282: 	ASL.l		d2,d0				* shift longword
                            	  3283: NoShift
01:0000CF74 60000344        	  3284: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3285: 
                            	  3286: 
                            	  3287: *************************************************************************************
                            	  3288: *
                            	  3289: * perform >> (right shift)
                            	  3290: 
                            	  3291: LAB_RSHIFT
01:0000CF78 611E            	  3292: 	BSR.s		GetPair			* get an integer and byte pair
                            	  3293: 							* byte is in d2, integer is in d0 and Itemp
01:0000CF7A 67F8            	  3294: 	BEQ.s		NoShift			* branch if byte zero
                            	  3295: 
01:0000CF7C B43C0020        	  3296: 	CMP.b		#$20,d2			* compare bit count with 32d
01:0000CF80 650A            	  3297: 	BCS.s		Not2Big			* branch if >= (return shift)
                            	  3298: 
01:0000CF82 4A80            	  3299: 	TST.l		d0				* test sign bit
01:0000CF84 6A0C            	  3300: 	BPL.s		TooBig			* branch if +ve
                            	  3301: 
01:0000CF86 70FF            	  3302: 	MOVEQ		#-1,d0			* set longword
01:0000CF88 60000330        	  3303: 	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
                            	  3304: 
                            	  3305: Not2Big
01:0000CF8C E4A0            	  3306: 	ASR.l		d2,d0				* shift longword
01:0000CF8E 6000032A        	  3307: 	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
                            	  3308: 
                            	  3309: TooBig
01:0000CF92 7000            	  3310: 	MOVEQ		#0,d0				* clear longword
01:0000CF94 60000324        	  3311: 	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
                            	  3312: 
                            	  3313: 
                            	  3314: *************************************************************************************
                            	  3315: *
                            	  3316: * get an integer and byte pair
                            	  3317: * byte is in d2, integer is in d0 and Itemp
                            	  3318: 
                            	  3319: GetPair
01:0000CF98 61000786        	  3320: 	BSR		LAB_EVBY			* evaluate byte expression, result in d0 and
                            	  3321: 							* Itemp
01:0000CF9C 1400            	  3322: 	MOVE.b	d0,d2				* save it
01:0000CF9E 61000C2E        	  3323: 	BSR		LAB_279B			* copy FAC2 to FAC1, get first value in
                            	  3324: 							* expression
01:0000CFA2 61000162        	  3325: 	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
                            	  3326: 							* result in d0 and Itemp
01:0000CFA6 4A02            	  3327: 	TST.b		d2				* test byte value
01:0000CFA8 4E75            	  3328: 	RTS
                            	  3329: 
                            	  3330: 
                            	  3331: *************************************************************************************
                            	  3332: *
                            	  3333: * check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
                            	  3334: 
                            	  3335: LAB_CASC
01:0000CFAA B03C0061        	  3336: 	CMP.b		#$61,d0			* compare with "a"
01:0000CFAE 6410            	  3337: 	BCC.s		LAB_1D83			* if >="a" go check =<"z"
                            	  3338: 
                            	  3339: 
                            	  3340: *************************************************************************************
                            	  3341: *
                            	  3342: * check alpha upper case, return C=0 if<"A" or >"Z"
                            	  3343: 
                            	  3344: LAB_CAUC
01:0000CFB0 B03C0041        	  3345: 	CMP.b		#$41,d0			* compare with "A"
01:0000CFB4 6404            	  3346: 	BCC.s		LAB_1D8A			* if >="A" go check =<"Z"
                            	  3347: 
01:0000CFB6 8040            	  3348: 	OR		d0,d0				* make C=0
01:0000CFB8 4E75            	  3349: 	RTS
                            	  3350: 
                            	  3351: LAB_1D8A
01:0000CFBA B03C005B        	  3352: 	CMP.b		#$5B,d0			* compare with "Z"+1
                            	  3353: 							* carry set if byte<="Z"
01:0000CFBE 4E75            	  3354: 	RTS
                            	  3355: 
                            	  3356: LAB_1D83
01:0000CFC0 B03C007B        	  3357: 	CMP.b		#$7B,d0			* compare with "z"+1
                            	  3358: 							* carry set if byte<="z"
01:0000CFC4 4E75            	  3359: 	RTS
                            	  3360: 
                            	  3361: 
                            	  3362: *************************************************************************************
                            	  3363: *
                            	  3364: * search for or create variable. this is used to automatically create a variable if
                            	  3365: * it is not found. any routines that need to create the variable call LAB_GVAR via
                            	  3366: * this point and error generation is supressed and the variable will be created
                            	  3367: *
                            	  3368: * return pointer to variable in Cvaral and a0
                            	  3369: * set data type to variable type
                            	  3370: 
                            	  3371: LAB_SVAR
01:0000CFC6 6102            	  3372: 	BSR.s		LAB_GVAR			* search for variable
                            	  3373: LAB_FVAR
01:0000CFC8 4E75            	  3374: 	RTS
                            	  3375: 
                            	  3376: 
                            	  3377: *************************************************************************************
                            	  3378: *
                            	  3379: * search for variable. if this routine is called from anywhere but the above call and
                            	  3380: * the variable searched for does not exist then an error will be returned
                            	  3381: *
                            	  3382: * DIM flag is in d1.b
                            	  3383: * return pointer to variable in Cvaral and a0
                            	  3384: * set data type to variable type
                            	  3385: 
                            	  3386: LAB_GVAR
01:0000CFCA 7200            	  3387: 	MOVEQ		#$00,d1			* set DIM flag = $00
01:0000CFCC 6100FDF0        	  3388: 	BSR		LAB_GBYT			* scan memory (1st character)
                            	  3389: LAB_1D10
01:0000CFD0 174105B4        	  3390: 	MOVE.b	d1,Defdim(a3)		* save DIM flag
                            	  3391: 
                            	  3392: * search for FN name entry point
                            	  3393: 
                            	  3394: LAB_1D12
01:0000CFD4 61D4            	  3395: 	BSR.s		LAB_CASC			* check byte, return C=0 if<"A" or >"Z"
01:0000CFD6 6400F1A8        	  3396: 	BCC		LAB_SNER			* if not, syntax error then warm start
                            	  3397: 
                            	  3398: 							* it is a variable name so ...
01:0000CFDA 7200            	  3399: 	MOVEQ		#$0,d1			* set index for name byte
01:0000CFDC 41EB046A        	  3400: 	LEA		Varname(a3),a0		* pointer to variable name
01:0000CFE0 2081            	  3401: 	MOVE.l	d1,(a0)			* clear the variable name
01:0000CFE2 174105B5        	  3402: 	MOVE.b	d1,Dtypef(a3)		* clear the data type, $80=string, $40=integer,
                            	  3403: 							* $00=float
                            	  3404: 
                            	  3405: LAB_1D2D
01:0000CFE6 B27C0004        	  3406: 	CMP.w		#$04,d1			* done all significant characters?
01:0000CFEA 6406            	  3407: 	BCC.s		LAB_1D2E			* if so go ignore any more
                            	  3408: 
01:0000CFEC 11801000        	  3409: 	MOVE.b	d0,(a0,d1.w)		* save the character
01:0000CFF0 5241            	  3410: 	ADDQ.w	#1,d1				* increment index
                            	  3411: LAB_1D2E
01:0000CFF2 6100FDC8        	  3412: 	BSR		LAB_IGBY			* increment & scan memory (next character)
01:0000CFF6 65EE            	  3413: 	BCS.s		LAB_1D2D			* branch if character = "0"-"9" (ok)
                            	  3414: 
                            	  3415: 							* character wasn't "0" to "9" so ...
01:0000CFF8 61B0            	  3416: 	BSR.s		LAB_CASC			* check byte, return C=0 if<"A" or >"Z"
01:0000CFFA 65EA            	  3417: 	BCS.s		LAB_1D2D			* branch if = "A"-"Z" (ok)
                            	  3418: 
                            	  3419: 							* check if string variable
01:0000CFFC B03C0024        	  3420: 	CMP.b		#'$',d0			* compare with "$"
01:0000D000 660C            	  3421: 	BNE.s		LAB_1D44			* branch if not string
                            	  3422: 
                            	  3423: 							* type is string
01:0000D002 002B0080046B    	  3424: 	OR.b		#$80,Varname+1(a3)	* set top bit of 2nd character, indicate string
01:0000D008 6100FDB2        	  3425: 	BSR		LAB_IGBY			* increment & scan memory
01:0000D00C 6010            	  3426: 	BRA.s		LAB_1D45			* skip integer check
                            	  3427: 
                            	  3428: 							* check if integer variable
                            	  3429: LAB_1D44
01:0000D00E B03C0026        	  3430: 	CMP.b		#'&',d0			* compare with "&"
01:0000D012 660A            	  3431: 	BNE.s		LAB_1D45			* branch if not integer
                            	  3432: 
                            	  3433: 							* type is integer
01:0000D014 002B0080046C    	  3434: 	OR.b		#$80,Varname+2(a3)	* set top bit of 3rd character, indicate integer
01:0000D01A 6100FDA0        	  3435: 	BSR		LAB_IGBY			* increment & scan memory
                            	  3436: 
                            	  3437: * after we have determined the variable type we need to determine
                            	  3438: * if it's an array of type
                            	  3439: 
                            	  3440: 							* gets here with character after var name in d0
                            	  3441: LAB_1D45
01:0000D01E 4A2B05DF        	  3442: 	TST.b		Sufnxf(a3)			* test function name flag
01:0000D022 670E            	  3443: 	BEQ.s		LAB_1D48			* if not FN or FN variable continue
                            	  3444: 
01:0000D024 6A14            	  3445: 	BPL.s		LAB_1D49			* if FN variable go find or create it
                            	  3446: 
                            	  3447: 							* else was FN name
01:0000D026 202B046A        	  3448: 	MOVE.l	Varname(a3),d0		* get whole function name
01:0000D02A 7208            	  3449: 	MOVEQ		#8,d1				* set step to next function size -4
01:0000D02C 41EB0432        	  3450: 	LEA		Sfncl(a3),a0		* get pointer to start of functions
01:0000D030 601C            	  3451: 	BRA.s		LAB_1D4B			* go find function
                            	  3452: 
                            	  3453: LAB_1D48
01:0000D032 903C0028        	  3454: 	SUB.b		#'(',d0			* subtract "("
01:0000D036 670000F4        	  3455: 	BEQ		LAB_1E17			* if "(" go find, or make, array
                            	  3456: 
                            	  3457: * either find or create var
                            	  3458: * var name (1st four characters only!) is in Varname
                            	  3459: 
                            	  3460: 							* variable name wasn't var( .. so look for
                            	  3461: 							* plain variable
                            	  3462: LAB_1D49
01:0000D03A 202B046A        	  3463: 	MOVE.l	Varname(a3),d0		* get whole variable name
                            	  3464: LAB_1D4A
01:0000D03E 7204            	  3465: 	MOVEQ		#4,d1				* set step to next variable size -4
01:0000D040 41EB0436        	  3466: 	LEA		Svarl(a3),a0		* get pointer to start of variables
                            	  3467: 
01:0000D044 08000017        	  3468: 	BTST.l	#23,d0			* test if string name
01:0000D048 6704            	  3469: 	BEQ.s		LAB_1D4B			* branch if not
                            	  3470: 
01:0000D04A 5441            	  3471: 	ADDQ.w	#2,d1				* 6 bytes per string entry
01:0000D04C 5848            	  3472: 	ADDQ.w	#(Sstrl-Svarl),a0		* move to string area
                            	  3473: 
                            	  3474: LAB_1D4B
01:0000D04E 22680004        	  3475: 	MOVEA.l	4(a0),a1			* get end address
01:0000D052 2050            	  3476: 	MOVEA.l	(a0),a0			* get start address
01:0000D054 6006            	  3477: 	BRA.s		LAB_1D5E			* enter loop at exit check
                            	  3478: 
                            	  3479: LAB_1D5D
01:0000D056 B098            	  3480: 	CMP.l		(a0)+,d0			* compare this variable with name
01:0000D058 6776            	  3481: 	BEQ.s		LAB_1DD7			* branch if match (found var)
                            	  3482: 
01:0000D05A D1C1            	  3483: 	ADDA.l	d1,a0				* add offset to next variable
                            	  3484: LAB_1D5E
01:0000D05C B1C9            	  3485: 	CMPA.l	a1,a0				* compare address with variable space end
01:0000D05E 66F6            	  3486: 	BNE.s		LAB_1D5D			* if not end go check next
                            	  3487: 
01:0000D060 4A2B05DF        	  3488: 	TST.b		Sufnxf(a3)			* is it a function or function variable
01:0000D064 660A            	  3489: 	BNE.s		LAB_1D94			* if was go do DEF or function variable
                            	  3490: 
                            	  3491: 							* reached end of variable mem without match
                            	  3492: 							* ... so create new variable, possibly
                            	  3493: 
01:0000D066 45FAFF60        	  3494: 	LEA		LAB_FVAR(pc),a2		* get the address of the create if doesn't
                            	  3495: 							* exist call to LAB_GVAR
01:0000D06A B5D7            	  3496: 	CMPA.l	(sp),a2			* compare the return address with expected
01:0000D06C 6600F0CE        	  3497: 	BNE		LAB_UVER			* if not create go do error or return null
                            	  3498: 
                            	  3499: * this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
                            	  3500: 
                            	  3501: LAB_1D94
01:0000D070 082B000005DF    	  3502: 	BTST.b	#0,Sufnxf(a3)		* test function search flag
01:0000D076 6600F0CC        	  3503: 	BNE		LAB_UFER			* if not doing DEF then go do undefined
                            	  3504: 							* function error
                            	  3505: 
                            	  3506: 							* else create new variable/function
                            	  3507: LAB_1D98
01:0000D07A 246B0442        	  3508: 	MOVEA.l	Earryl(a3),a2		* get end of block to move
01:0000D07E 240A            	  3509: 	MOVE.l	a2,d2				* copy end of block to move
01:0000D080 9489            	  3510: 	SUB.l		a1,d2				* calculate block to move size
                            	  3511: 
01:0000D082 204A            	  3512: 	MOVEA.l	a2,a0				* copy end of block to move
01:0000D084 5881            	  3513: 	ADDQ.l	#4,d1				* space for one variable/function + name
01:0000D086 D5C1            	  3514: 	ADDA.l	d1,a2				* add space for one variable/function
01:0000D088 274A0442        	  3515: 	MOVE.l	a2,Earryl(a3)		* set new array mem end
01:0000D08C E28A            	  3516: 	LSR.l		#1,d2				* /2 for word copy
01:0000D08E 6712            	  3517: 	BEQ.s		LAB_1DAF			* skip move if zero length block
                            	  3518: 
01:0000D090 5382            	  3519: 	SUBQ.l	#1,d2				* -1 for DFB loop
01:0000D092 4842            	  3520: 	SWAP		d2				* swap high word to low word
                            	  3521: LAB_1DAC
01:0000D094 4842            	  3522: 	SWAP		d2				* swap high word to low word
                            	  3523: LAB_1DAE
01:0000D096 3520            	  3524: 	MOVE.w	-(a0),-(a2)			* copy word
01:0000D098 51CAFFFC        	  3525: 	DBF		d2,LAB_1DAE			* loop until done
                            	  3526: 
01:0000D09C 4842            	  3527: 	SWAP		d2				* swap high word to low word
01:0000D09E 51CAFFF4        	  3528: 	DBF		d2,LAB_1DAC			* decrement high count and loop until done
                            	  3529: 
                            	  3530: * get here after creating either a function, variable or string
                            	  3531: * if function set variables start, string start, array start
                            	  3532: * if variable set string start, array start
                            	  3533: * if string set array start
                            	  3534: 
                            	  3535: LAB_1DAF
01:0000D0A2 4A2B05DF        	  3536: 	TST.b		Sufnxf(a3)			* was it function
01:0000D0A6 6B08            	  3537: 	BMI.s		LAB_1DB0			* branch if was FN
                            	  3538: 
01:0000D0A8 08000017        	  3539: 	BTST.l	#23,d0			* was it string
01:0000D0AC 660A            	  3540: 	BNE.s		LAB_1DB2			* branch if string
                            	  3541: 
01:0000D0AE 6004            	  3542: 	BRA.s		LAB_1DB1			* branch if was plain variable
                            	  3543: 
                            	  3544: LAB_1DB0
01:0000D0B0 D3AB0436        	  3545: 	ADD.l		d1,Svarl(a3)		* set new variable memory start
                            	  3546: LAB_1DB1
01:0000D0B4 D3AB043A        	  3547: 	ADD.l		d1,Sstrl(a3)		* set new start of strings
                            	  3548: LAB_1DB2
01:0000D0B8 D3AB043E        	  3549: 	ADD.l		d1,Sarryl(a3)		* set new array memory start
01:0000D0BC 20C0            	  3550: 	MOVE.l	d0,(a0)+			* save variable/function name
01:0000D0BE 20BC00000000    	  3551: 	MOVE.l	#$00,(a0)			* initialise variable
01:0000D0C4 08000017        	  3552: 	BTST.l	#23,d0			* was it string
01:0000D0C8 6706            	  3553: 	BEQ.s		LAB_1DD7			* branch if not string
                            	  3554: 
01:0000D0CA 317C00000004    	  3555: 	MOVE.w	#$00,4(a0)			* else initialise string length
                            	  3556: 
                            	  3557: 							* found a match for var ((Vrschl) = ptr)
                            	  3558: LAB_1DD7
01:0000D0D0 2200            	  3559: 	MOVE.l	d0,d1				* ........ $....... &....... ........
01:0000D0D2 D281            	  3560: 	ADD.l		d1,d1				* .......$ .......& ........ .......0
01:0000D0D4 4841            	  3561: 	SWAP		d1				* ........ .......0 .......$ .......&
01:0000D0D6 E219            	  3562: 	ROR.b		#1,d1				* ........ .......0 .......$ &.......
01:0000D0D8 E249            	  3563: 	LSR.w		#1,d1				* ........ .......0 0....... $&......
01:0000D0DA C23C00C0        	  3564: 	AND.b		#$C0,d1			* mask the type bits
01:0000D0DE 174105B5        	  3565: 	MOVE.b	d1,Dtypef(a3)		* save the data type
                            	  3566: 
01:0000D0E2 177C000005DF    	  3567: 	MOVE.b	#$00,Sufnxf(a3)		* clear FN flag byte
                            	  3568: 
                            	  3569: * if you want a non existant variable to return a null value then set the novar
                            	  3570: * value at the top of this file to some non zero value
                            	  3571: 
                            	  3572:  ifne	novar
                            	  3573: 
                            	  3574: 	MOVEQ		#-1,d0			* return variable found
                            	  3575: 
                            	  3576:  endc
                            	  3577: 
01:0000D0E8 4E75            	  3578: 	RTS
                            	  3579: 
                            	  3580: 
                            	  3581: *************************************************************************************
                            	  3582: *
                            	  3583: * set-up array pointer, d0, to first element in array
                            	  3584: * set d0 to (a0)+2*(Dimcnt)+$0A
                            	  3585: 
                            	  3586: LAB_1DE6
01:0000D0EA 7005            	  3587: 	MOVEQ		#5,d0				* set d0 to 5 (*2 = 10, later)
01:0000D0EC D02B05DB        	  3588: 	ADD.b		Dimcnt(a3),d0		* add # of dimensions (1, 2 or 3)
01:0000D0F0 D080            	  3589: 	ADD.l		d0,d0				* *2 (bytes per dimension size)
01:0000D0F2 D088            	  3590: 	ADD.l		a0,d0				* add array start pointer
01:0000D0F4 4E75            	  3591: 	RTS
                            	  3592: 
                            	  3593: 
                            	  3594: *************************************************************************************
                            	  3595: *
                            	  3596: * evaluate unsigned integer expression
                            	  3597: 
                            	  3598: LAB_EVIN
01:0000D0F6 6100FCC4        	  3599: 	BSR		LAB_IGBY			* increment & scan memory
01:0000D0FA 6100FB48        	  3600: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  3601: 							* else do type mismatch
                            	  3602: 
                            	  3603: 
                            	  3604: *************************************************************************************
                            	  3605: *
                            	  3606: * evaluate positive integer expression, result in d0 and Itemp
                            	  3607: 
                            	  3608: LAB_EVPI
01:0000D0FE 4A2B0595        	  3609: 	TST.b		FAC1_s(a3)			* test FAC1 sign (b7)
01:0000D102 6B00F070        	  3610: 	BMI		LAB_FCER			* do function call error if -ve
                            	  3611: 
                            	  3612: 
                            	  3613: *************************************************************************************
                            	  3614: *
                            	  3615: * evaluate integer expression, no sign check
                            	  3616: * result in d0 and Itemp, exit with flags set correctly
                            	  3617: 
                            	  3618: LAB_EVIR
01:0000D106 0C2B00A00594    	  3619: 	CMPI.b	#$A0,FAC1_e(a3)		* compare exponent with exponent = 2^32 (n>2^31)
01:0000D10C 65000B58        	  3620: 	BCS		LAB_2831			* convert FAC1 floating to fixed
                            	  3621: 							* result in d0 and Itemp
01:0000D110 6600F062        	  3622: 	BNE		LAB_FCER			* if > do function call error, then warm start
                            	  3623: 
01:0000D114 4A2B0595        	  3624: 	TST.b		FAC1_s(a3)			* test sign of FAC1
01:0000D118 6A000B4C        	  3625: 	BPL		LAB_2831			* if +ve then ok
                            	  3626: 
01:0000D11C 202B0590        	  3627: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:0000D120 4480            	  3628: 	NEG.l		d0				* do -d0
01:0000D122 6800F050        	  3629: 	BVC		LAB_FCER			* if not $80000000 do FC error, then warm start
                            	  3630: 
01:0000D126 2740042A        	  3631: 	MOVE.l	d0,Itemp(a3)		* else just set it
01:0000D12A 4E75            	  3632: 	RTS
                            	  3633: 
                            	  3634: 
                            	  3635: *************************************************************************************
                            	  3636: *
                            	  3637: * find or make array
                            	  3638: 
                            	  3639: LAB_1E17
01:0000D12C 3F2B05B4        	  3640: 	MOVE.w	Defdim(a3),-(sp)		* get DIM flag and data type flag (word in mem)
01:0000D130 7200            	  3641: 	MOVEQ		#0,d1				* clear dimensions count
                            	  3642: 
                            	  3643: * now get the array dimension(s) and stack it (them) before the data type and DIM flag
                            	  3644: 
                            	  3645: LAB_1E1F
01:0000D132 3F01            	  3646: 	MOVE.w	d1,-(sp)			* save dimensions count
01:0000D134 2F2B046A        	  3647: 	MOVE.l	Varname(a3),-(sp)		* save variable name
01:0000D138 61BC            	  3648: 	BSR.s		LAB_EVIN			* evaluate integer expression
                            	  3649: 
01:0000D13A 4840            	  3650: 	SWAP		d0				* swap high word to low word
01:0000D13C 4A40            	  3651: 	TST.w		d0				* test swapped high word
01:0000D13E 6600F024        	  3652: 	BNE		LAB_ABER			* if too big do array bounds error
                            	  3653: 
01:0000D142 275F046A        	  3654: 	MOVE.l	(sp)+,Varname(a3)		* restore variable name
01:0000D146 321F            	  3655: 	MOVE.w	(sp)+,d1			* restore dimensions count
01:0000D148 301F            	  3656: 	MOVE.w	(sp)+,d0			* restore DIM and data type flags
01:0000D14A 3F2B042C        	  3657: 	MOVE.w	Itemp+2(a3),-(sp)		* stack this dimension size
01:0000D14E 3F00            	  3658: 	MOVE.w	d0,-(sp)			* save DIM and data type flags
01:0000D150 5241            	  3659: 	ADDQ.w	#1,d1				* increment dimensions count
01:0000D152 6100FC6A        	  3660: 	BSR		LAB_GBYT			* scan memory
01:0000D156 B03C002C        	  3661: 	CMP.b		#$2C,d0			* compare with ","
01:0000D15A 67D6            	  3662: 	BEQ.s		LAB_1E1F			* if found go do next dimension
                            	  3663: 
01:0000D15C 174105DB        	  3664: 	MOVE.b	d1,Dimcnt(a3)		* store dimensions count
01:0000D160 6100FC48        	  3665: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
01:0000D164 375F05B4        	  3666: 	MOVE.w	(sp)+,Defdim(a3)		* restore DIM and data type flags (word in mem)
01:0000D168 206B043E        	  3667: 	MOVEA.l	Sarryl(a3),a0		* get array mem start
                            	  3668: 
                            	  3669: * now check to see if we are at the end of array memory (we would be if there were
                            	  3670: * no arrays).
                            	  3671: 
                            	  3672: LAB_1E5C
01:0000D16C 274805AC        	  3673: 	MOVE.l	a0,Astrtl(a3)		* save as array start pointer
01:0000D170 B1EB0442        	  3674: 	CMPA.l	Earryl(a3),a0		* compare with array mem end
01:0000D174 672E            	  3675: 	BEQ.s		LAB_1EA1			* go build array if not found
                            	  3676: 
                            	  3677: 							* search for array
01:0000D176 2010            	  3678: 	MOVE.l	(a0),d0			* get this array name
01:0000D178 B0AB046A        	  3679: 	CMP.l		Varname(a3),d0		* compare with array name
01:0000D17C 670A            	  3680: 	BEQ.s		LAB_1E8D			* array found so branch
                            	  3681: 
                            	  3682: 							* no match
01:0000D17E 20680004        	  3683: 	MOVEA.l	4(a0),a0			* get this array size
01:0000D182 D1EB05AC        	  3684: 	ADDA.l	Astrtl(a3),a0		* add to array start pointer
01:0000D186 60E4            	  3685: 	BRA.s		LAB_1E5C			* go check next array
                            	  3686: 
                            	  3687: 							* found array, are we trying to dimension it?
                            	  3688: LAB_1E8D
01:0000D188 4A2B05B4        	  3689: 	TST.b		Defdim(a3)			* are we trying to dimension it?
01:0000D18C 6600EFD2        	  3690: 	BNE		LAB_DDER			* if so do double dimension error/warm start
                            	  3691: 
                            	  3692: * found the array and we're not dimensioning it so we must find an element in it
                            	  3693: 
01:0000D190 6100FF58        	  3694: 	BSR		LAB_1DE6			* set data pointer, d0, to the first element
                            	  3695: 							* in the array
01:0000D194 5048            	  3696: 	ADDQ.w	#8,a0				* index to dimension count
01:0000D196 3018            	  3697: 	MOVE.w	(a0)+,d0			* get no of dimensions
01:0000D198 B02B05DB        	  3698: 	CMP.b		Dimcnt(a3),d0		* compare with dimensions count
01:0000D19C 67000094        	  3699: 	BEQ		LAB_1F28			* found array so go get element
                            	  3700: 
01:0000D1A0 6000EF92        	  3701: 	BRA		LAB_WDER			* else wrong so do "Wrong dimensions" error
                            	  3702: 
                            	  3703: 							* array not found, so possibly build it
                            	  3704: LAB_1EA1
01:0000D1A4 4A2B05B4        	  3705: 	TST.b		Defdim(a3)			* test the default DIM flag
01:0000D1A8 6700EF8E        	  3706: 	BEQ		LAB_UDER			* if default flag is clear then we are not
                            	  3707: 							* explicitly dimensioning an array so go
                            	  3708: 							* do an "Undimensioned array" error
                            	  3709: 
01:0000D1AC 6100FF3C        	  3710: 	BSR		LAB_1DE6			* set data pointer, d0, to the first element
                            	  3711: 							* in the array
01:0000D1B0 202B046A        	  3712: 	MOVE.l	Varname(a3),d0		* get array name
01:0000D1B4 20C0            	  3713: 	MOVE.l	d0,(a0)+			* save array name
01:0000D1B6 7204            	  3714: 	MOVEQ		#4,d1				* set 4 bytes per element
01:0000D1B8 08000017        	  3715: 	BTST.l	#23,d0			* test if string array
01:0000D1BC 6702            	  3716: 	BEQ.s		LAB_1EDF			* branch if not string
                            	  3717: 
01:0000D1BE 7206            	  3718: 	MOVEQ		#6,d1				* else 6 bytes per element
                            	  3719: LAB_1EDF
01:0000D1C0 274105A8        	  3720: 	MOVE.l	d1,Asptl(a3)		* set array data size (bytes per element)
01:0000D1C4 122B05DB        	  3721: 	MOVE.b	Dimcnt(a3),d1		* get dimensions count
01:0000D1C8 5848            	  3722: 	ADDQ.w	#4,a0				* skip the array size now (don't know it yet!)
01:0000D1CA 30C1            	  3723: 	MOVE.w	d1,(a0)+			* set array's dimensions count
                            	  3724: 
                            	  3725: * now calculate the array data space size
                            	  3726: 
                            	  3727: LAB_1EC0
                            	  3728: 
                            	  3729: * If you want arrays to dimension themselves by default then comment out the test
                            	  3730: * above and uncomment the next three code lines and the label LAB_1ED0
                            	  3731: 
                            	  3732: *	MOVE.w	#$0A,d1			* set default dimension value, allow 0 to 9
                            	  3733: *	TST.b		Defdim(a3)			* test default DIM flag
                            	  3734: *	BNE.s		LAB_1ED0			* branch if b6 of Defdim is clear
                            	  3735: 
01:0000D1CC 321F            	  3736: 	MOVE.w	(sp)+,d1			* get dimension size
                            	  3737: *LAB_1ED0
01:0000D1CE 30C1            	  3738: 	MOVE.w	d1,(a0)+			* save to array header
01:0000D1D0 610000AE        	  3739: 	BSR		LAB_1F7C			* do this dimension size+1 * array size
                            	  3740: 							* (d1+1)*(Asptl), result in d0
01:0000D1D4 274005A8        	  3741: 	MOVE.l	d0,Asptl(a3)		* save array data size
01:0000D1D8 532B05DB        	  3742: 	SUBQ.b	#1,Dimcnt(a3)		* decrement dimensions count
01:0000D1DC 66EE            	  3743: 	BNE.s		LAB_1EC0			* loop while not = 0
                            	  3744: 
01:0000D1DE D1EB05A8        	  3745: 	ADDA.l	Asptl(a3),a0		* add size to first element address
01:0000D1E2 6500EF88        	  3746: 	BCS		LAB_OMER			* if overflow go do "Out of memory" error
                            	  3747: 
01:0000D1E6 B1EB0446        	  3748: 	CMPA.l	Sstorl(a3),a0		* compare with bottom of string memory
01:0000D1EA 650C            	  3749: 	BCS.s		LAB_1ED6			* branch if less (is ok)
                            	  3750: 
01:0000D1EC 6100028E        	  3751: 	BSR		LAB_GARB			* do garbage collection routine
01:0000D1F0 B1EB0446        	  3752: 	CMPA.l	Sstorl(a3),a0		* compare with bottom of string memory
01:0000D1F4 6400EF76        	  3753: 	BCC		LAB_OMER			* if Sstorl <= a0 do "Out of memory"
                            	  3754: 							* error then warm start
                            	  3755: 
                            	  3756: LAB_1ED6						* ok exit, carry set
01:0000D1F8 27480442        	  3757: 	MOVE.l	a0,Earryl(a3)		* save array mem end
01:0000D1FC 7000            	  3758: 	MOVEQ		#0,d0				* zero d0
01:0000D1FE 222B05A8        	  3759: 	MOVE.l	Asptl(a3),d1		* get size in bytes
01:0000D202 E289            	  3760: 	LSR.l		#1,d1				* /2 for word fill (may be odd # words)
01:0000D204 5341            	  3761: 	SUBQ.w	#1,d1				* adjust for DBF loop
                            	  3762: LAB_1ED8
01:0000D206 3100            	  3763: 	MOVE.w	d0,-(a0)			* decrement pointer and clear word
01:0000D208 51C9FFFC        	  3764: 	DBF		d1,LAB_1ED8			* decrement & loop until low word done
                            	  3765: 
01:0000D20C 4841            	  3766: 	SWAP		d1				* swap words
01:0000D20E 4A41            	  3767: 	TST.w		d1				* test high word
01:0000D210 6706            	  3768: 	BEQ.s		LAB_1F07			* exit if done
                            	  3769: 
01:0000D212 5341            	  3770: 	SUBQ.w	#1,d1				* decrement low (high) word
01:0000D214 4841            	  3771: 	SWAP		d1				* swap back
01:0000D216 60EE            	  3772: 	BRA.s		LAB_1ED8			* go do a whole block
                            	  3773: 
                            	  3774: * now we need to calculate the array size by doing Earryl - Astrtl
                            	  3775: 
                            	  3776: LAB_1F07
01:0000D218 206B05AC        	  3777: 	MOVEA.l	Astrtl(a3),a0		* get for calculation and as pointer
01:0000D21C 202B0442        	  3778: 	MOVE.l	Earryl(a3),d0		* get array memory end
01:0000D220 9088            	  3779: 	SUB.l		a0,d0				* calculate array size
01:0000D222 21400004        	  3780: 	MOVE.l	d0,4(a0)			* save size to array
01:0000D226 4A2B05B4        	  3781: 	TST.b		Defdim(a3)			* test default DIM flag
01:0000D22A 6652            	  3782: 	BNE.s		RTS_011			* exit (RET) if this was a DIM command
                            	  3783: 
                            	  3784: 							* else, find element
01:0000D22C 5048            	  3785: 	ADDQ.w	#8,a0				* index to dimension count
01:0000D22E 375805DB        	  3786: 	MOVE.w	(a0)+,Dimcnt(a3)		* get array's dimension count
                            	  3787: 
                            	  3788: * we have found, or built, the array. now we need to find the element
                            	  3789: 
                            	  3790: LAB_1F28
01:0000D232 7000            	  3791: 	MOVEQ		#0,d0				* clear first result
01:0000D234 274005A8        	  3792: 	MOVE.l	d0,Asptl(a3)		* clear array data pointer
                            	  3793: 
                            	  3794: * compare nth dimension bound (a0) with nth index (sp)+
                            	  3795: * if greater do array bounds error
                            	  3796: 
                            	  3797: LAB_1F2C
01:0000D238 3218            	  3798: 	MOVE.w	(a0)+,d1			* get nth dimension bound
01:0000D23A B257            	  3799: 	CMP.w		(sp),d1			* compare nth index with nth dimension bound
01:0000D23C 6500EF26        	  3800: 	BCS		LAB_ABER			* if d1 less or = do array bounds error
                            	  3801: 
                            	  3802: * now do pointer = pointer * nth dimension + nth index
                            	  3803: 
01:0000D240 4A80            	  3804: 	TST.l		d0				* test pointer
01:0000D242 6702            	  3805: 	BEQ.s		LAB_1F5A			* skip multiply if last result = null
                            	  3806: 
01:0000D244 613A            	  3807: 	BSR.s		LAB_1F7C			* do this dimension size+1 * array size
                            	  3808: LAB_1F5A
01:0000D246 7200            	  3809: 	MOVEQ		#0,d1				* clear longword
01:0000D248 321F            	  3810: 	MOVE.w	(sp)+,d1			* get nth dimension index
01:0000D24A D081            	  3811: 	ADD.l		d1,d0				* add index to size
01:0000D24C 274005A8        	  3812: 	MOVE.l	d0,Asptl(a3)		* save array data pointer
                            	  3813: 
01:0000D250 532B05DB        	  3814: 	SUBQ.b	#1,Dimcnt(a3)		* decrement dimensions count
01:0000D254 66E2            	  3815: 	BNE.s		LAB_1F2C			* loop if dimensions still to do
                            	  3816: 
01:0000D256 177C000005B5    	  3817: 	MOVE.b	#0,Dtypef(a3)		* set data type to float
01:0000D25C 7203            	  3818: 	MOVEQ		#3,d1				* set for numeric array
01:0000D25E 4A2B046B        	  3819: 	TST.b		Varname+1(a3)		* test if string array
01:0000D262 6A0A            	  3820: 	BPL.s		LAB_1F6A			* branch if not string
                            	  3821: 
01:0000D264 7205            	  3822: 	MOVEQ		#5,d1				* else set for string array
01:0000D266 177C008005B5    	  3823: 	MOVE.b	#$80,Dtypef(a3)		* and set data type to string
01:0000D26C 600C            	  3824: 	BRA.s		LAB_1F6B			* skip integer test
                            	  3825: 
                            	  3826: LAB_1F6A
01:0000D26E 4A2B046C        	  3827: 	TST.b		Varname+2(a3)		* test if integer array
01:0000D272 6A06            	  3828: 	BPL.s		LAB_1F6B			* branch if not integer
                            	  3829: 
01:0000D274 177C004005B5    	  3830: 	MOVE.b	#$40,Dtypef(a3)		* else set data type to integer
                            	  3831: LAB_1F6B
01:0000D27A 6104            	  3832: 	BSR.s		LAB_1F7C			* do element size (d1) * array size (Asptl)
01:0000D27C D1C0            	  3833: 	ADDA.l	d0,a0				* add array data start pointer
                            	  3834: RTS_011
01:0000D27E 4E75            	  3835: 	RTS
                            	  3836: 
                            	  3837: 
                            	  3838: *************************************************************************************
                            	  3839: *
                            	  3840: * do this dimension size (d1) * array data size (Asptl)
                            	  3841: 
                            	  3842: * do a 16 x 32 bit multiply
                            	  3843: * d1 holds the 16 bit multiplier
                            	  3844: * Asptl holds the 32 bit multiplicand
                            	  3845: 
                            	  3846: * d0	bbbb  bbbb
                            	  3847: * d1	0000  aaaa
                            	  3848: *	----------
                            	  3849: * d0	rrrr  rrrr
                            	  3850: 
                            	  3851: LAB_1F7C
01:0000D280 202B05A8        	  3852: 	MOVE.l	Asptl(a3),d0		* get result
01:0000D284 2400            	  3853: 	MOVE.l	d0,d2				* copy it
01:0000D286 4842            	  3854: 	SWAP		d2				* shift high word to low word
01:0000D288 C0C1            	  3855: 	MULU.w	d1,d0				* d1 * low word = low result
01:0000D28A C4C1            	  3856: 	MULU.w	d1,d2				* d1 * high word = high result
01:0000D28C 4842            	  3857: 	SWAP		d2				* align words for test
01:0000D28E 4A42            	  3858: 	TST.w		d2				* must be zero
01:0000D290 6600EEDA        	  3859: 	BNE		LAB_OMER			* if overflow go do "Out of memory" error
                            	  3860: 
01:0000D294 D082            	  3861: 	ADD.l		d2,d0				* calculate result
01:0000D296 6500EED4        	  3862: 	BCS		LAB_OMER			* if overflow go do "Out of memory" error
                            	  3863: 
01:0000D29A D0AB05A8        	  3864: 	ADD.l		Asptl(a3),d0		* add original
01:0000D29E 6500EECC        	  3865: 	BCS		LAB_OMER			* if overflow go do "Out of memory" error
                            	  3866: 
01:0000D2A2 4E75            	  3867: 	RTS
                            	  3868: 
                            	  3869: 
                            	  3870: *************************************************************************************
                            	  3871: *
                            	  3872: * perform FRE()
                            	  3873: 
                            	  3874: LAB_FRE
01:0000D2A4 4A2B05B5        	  3875: 	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
                            	  3876: 							* $00=float
01:0000D2A8 6A04            	  3877: 	BPL.s		LAB_1FB4			* branch if numeric
                            	  3878: 
01:0000D2AA 61000310        	  3879: 	BSR		LAB_22B6			* pop string off descriptor stack, or from
                            	  3880: 							* top of string space, returns d0 = length,
                            	  3881: 							* a0 = pointer
                            	  3882: 
                            	  3883: 							* FRE(n) was numeric so do this
                            	  3884: LAB_1FB4
01:0000D2AE 610001CC        	  3885: 	BSR		LAB_GARB			* go do garbage collection
01:0000D2B2 202B0446        	  3886: 	MOVE.l	Sstorl(a3),d0		* get bottom of string space
01:0000D2B6 90AB0442        	  3887: 	SUB.l		Earryl(a3),d0		* subtract array mem end
                            	  3888: 
                            	  3889: 
                            	  3890: *************************************************************************************
                            	  3891: *
                            	  3892: * convert d0 to signed longword in FAC1
                            	  3893: 
                            	  3894: LAB_AYFC
01:0000D2BA 177C000005B5    	  3895: 	MOVE.b	#$00,Dtypef(a3)		* clear data type, $80=string, $40=integer,
                            	  3896: 							* $00=float
01:0000D2C0 377CA0000594    	  3897: 	MOVE.w	#$A000,FAC1_e(a3)		* set FAC1 exponent and clear sign (b7)
01:0000D2C6 27400590        	  3898: 	MOVE.l	d0,FAC1_m(a3)		* save FAC1 mantissa
01:0000D2CA 6A000636        	  3899: 	BPL		LAB_24D0			* convert if +ve
                            	  3900: 
01:0000D2CE 003C0001        	  3901: 	ORI.b		#1,CCR			* else set carry
01:0000D2D2 6000062E        	  3902: 	BRA		LAB_24D0			* do +/- (carry is sign) & normalise FAC1
                            	  3903: 
                            	  3904: 
                            	  3905: *************************************************************************************
                            	  3906: *
                            	  3907: * remember if the line length is zero (infinite line) then POS(n) will return
                            	  3908: * position MOD tabsize
                            	  3909: 
                            	  3910: * perform POS()
                            	  3911: 
                            	  3912: LAB_POS
01:0000D2D6 102B05E5        	  3913: 	MOVE.b	TPos(a3),d0			* get terminal position
                            	  3914: 
                            	  3915: * convert d0 to unsigned byte in FAC1
                            	  3916: 
                            	  3917: LAB_1FD0
01:0000D2DA C0BC000000FF    	  3918: 	AND.l		#$FF,d0			* clear high bits
01:0000D2E0 60D8            	  3919: 	BRA.s		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
                            	  3920: 
                            	  3921: * check not direct (used by DEF and INPUT)
                            	  3922: 
                            	  3923: LAB_CKRN
01:0000D2E2 4A2B0452        	  3924: 	TST.b		Clinel(a3)			* test current line #
01:0000D2E6 6B00EE70        	  3925: 	BMI		LAB_IDER			* if -ve go do illegal direct error then warm
                            	  3926: 							* start
                            	  3927: 
01:0000D2EA 4E75            	  3928: 	RTS						* can continue so return
                            	  3929: 
                            	  3930: 
                            	  3931: *************************************************************************************
                            	  3932: *
                            	  3933: * perform DEF
                            	  3934: 
                            	  3935: LAB_DEF
01:0000D2EC 70AB            	  3936: 	MOVEQ		#TK_FN-$100,d0		* get FN token
01:0000D2EE 6100FAC4        	  3937: 	BSR		LAB_SCCA			* scan for CHR$(d0), else syntax error and
                            	  3938: 							* warm start
                            	  3939: 							* return character after d0
01:0000D2F2 177C008005DF    	  3940: 	MOVE.b	#$80,Sufnxf(a3)		* set FN flag bit
01:0000D2F8 6100FCDA        	  3941: 	BSR		LAB_1D12			* get FN name
01:0000D2FC 274805B0        	  3942: 	MOVE.l	a0,func_l(a3)		* save function pointer
                            	  3943: 
01:0000D300 61E0            	  3944: 	BSR.s		LAB_CKRN			* check not direct (back here if ok)
01:0000D302 0C1D0028        	  3945: 	CMP.b		#$28,(a5)+			* check next byte is "(" and increment
01:0000D306 6600EE78        	  3946: 	BNE		LAB_SNER			* else do syntax error/warm start
                            	  3947: 
01:0000D30A 177C007E05DF    	  3948: 	MOVE.b	#$7E,Sufnxf(a3)		* set FN variable flag bits
01:0000D310 6100FCB4        	  3949: 	BSR		LAB_SVAR			* search for or create a variable
                            	  3950: 							* return the variable address in a0
01:0000D314 6100FA94        	  3951: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
01:0000D318 70BD            	  3952: 	MOVEQ		#TK_EQUAL-$100,d0		* = token
01:0000D31A 6100FA98        	  3953: 	BSR		LAB_SCCA			* scan for CHR$(A), else syntax error/warm start
                            	  3954: 							* return character after d0
01:0000D31E 2F2B046A        	  3955: 	MOVE.l	Varname(a3),-(sp)		* push current variable name
01:0000D322 2F0D            	  3956: 	MOVE.l	a5,-(sp)			* push BASIC execute pointer
01:0000D324 6100F41C        	  3957: 	BSR		LAB_DATA			* go perform DATA, find end of DEF FN statement
01:0000D328 206B05B0        	  3958: 	MOVEA.l	func_l(a3),a0		* get the function pointer
01:0000D32C 209F            	  3959: 	MOVE.l	(sp)+,(a0)			* save BASIC execute pointer to function
01:0000D32E 215F0004        	  3960: 	MOVE.l	(sp)+,4(a0)			* save current variable name to function
01:0000D332 4E75            	  3961: 	RTS
                            	  3962: 
                            	  3963: 
                            	  3964: *************************************************************************************
                            	  3965: *
                            	  3966: * evaluate FNx
                            	  3967: 
                            	  3968: LAB_201E
01:0000D334 177C008105DF    	  3969: 	MOVE.b	#$81,Sufnxf(a3)		* set FN flag (find not create)
01:0000D33A 6100FA80        	  3970: 	BSR		LAB_IGBY			* increment & scan memory
01:0000D33E 6100FC94        	  3971: 	BSR		LAB_1D12			* get FN name
01:0000D342 1F2B05B5        	  3972: 	MOVE.b	Dtypef(a3),-(sp)		* push data type flag (function type)
01:0000D346 2F08            	  3973: 	MOVE.l	a0,-(sp)			* push function pointer
01:0000D348 0C150028        	  3974: 	CMP.b		#$28,(a5)			* check next byte is "(", no increment
01:0000D34C 6600EE32        	  3975: 	BNE		LAB_SNER			* else do syntax error/warm start
                            	  3976: 
01:0000D350 6100FA54        	  3977: 	BSR		LAB_1BF7			* evaluate expression within parentheses
01:0000D354 205F            	  3978: 	MOVEA.l	(sp)+,a0			* pop function pointer
01:0000D356 274805B0        	  3979: 	MOVE.l	a0,func_l(a3)		* set function pointer
01:0000D35A 1F2B05B5        	  3980: 	MOVE.b	Dtypef(a3),-(sp)		* push data type flag (function expression type)
                            	  3981: 
01:0000D35E 20280004        	  3982: 	MOVE.l	4(a0),d0			* get function variable name
01:0000D362 6100FCDA        	  3983: 	BSR		LAB_1D4A			* go find function variable (already created)
                            	  3984: 
                            	  3985: 							* now check type match for variable
01:0000D366 101F            	  3986: 	MOVE.b	(sp)+,d0			* pop data type flag (function expression type)
01:0000D368 E318            	  3987: 	ROL.b		#1,d0				* set carry if type = string
01:0000D36A 6100F8DC        	  3988: 	BSR		LAB_CKTM			* type match check, set C for string
                            	  3989: 
                            	  3990: 							* now stack the function variable value before
                            	  3991: 							* use
01:0000D36E 6712            	  3992: 	BEQ.s		LAB_2043			* branch if not string
                            	  3993: 
01:0000D370 43EB0476        	  3994: 	LEA		des_sk_e(a3),a1		* get string stack pointer max+1
01:0000D374 B9C9            	  3995: 	CMPA.l	a1,a4				* compare string stack pointer with max+1
01:0000D376 6700EDD4        	  3996: 	BEQ		LAB_SCER			* if no space on the stack go do string too
                            	  3997: 							* complex error
                            	  3998: 
01:0000D37A 39280004        	  3999: 	MOVE.w	4(a0),-(a4)			* string length on descriptor stack
01:0000D37E 2910            	  4000: 	MOVE.l	(a0),-(a4)			* string address on stack
01:0000D380 6002            	  4001: 	BRA.s		LAB_204S			* skip var push
                            	  4002: 
                            	  4003: LAB_2043
01:0000D382 2F10            	  4004: 	MOVE.l	(a0),-(sp)			* push variable
                            	  4005: LAB_204S
01:0000D384 2F08            	  4006: 	MOVE.l	a0,-(sp)			* push variable address
01:0000D386 1F2B05B5        	  4007: 	MOVE.b	Dtypef(a3),-(sp)		* push variable data type
                            	  4008: 
01:0000D38A 6132            	  4009: 	BSR.s		LAB_2045			* pack function expression value into (a0)
                            	  4010: 							* (function variable)
01:0000D38C 2F0D            	  4011: 	MOVE.l	a5,-(sp)			* push BASIC execute pointer
01:0000D38E 206B05B0        	  4012: 	MOVEA.l	func_l(a3),a0		* get function pointer
01:0000D392 2A50            	  4013: 	MOVEA.l	(a0),a5			* save function execute ptr as BASIC execute ptr
01:0000D394 6100F8C6        	  4014: 	BSR		LAB_EVEX			* evaluate expression
01:0000D398 6100FA24        	  4015: 	BSR		LAB_GBYT			* scan memory
01:0000D39C 6600EDE2        	  4016: 	BNE		LAB_SNER			* if not [EOL] or [EOS] do syntax error and
                            	  4017: 							* warm start
                            	  4018: 
01:0000D3A0 2A5F            	  4019: 	MOVE.l	(sp)+,a5			* restore BASIC execute pointer
                            	  4020: 
                            	  4021: * restore variable from stack and test data type
                            	  4022: 
01:0000D3A2 101F            	  4023: 	MOVE.b	(sp)+,d0			* pull variable data type
01:0000D3A4 205F            	  4024: 	MOVEA.l	(sp)+,a0			* pull variable address
01:0000D3A6 4A00            	  4025: 	TST.b		d0				* test variable data type
01:0000D3A8 6A08            	  4026: 	BPL.s		LAB_204T			* branch if not string
                            	  4027: 
01:0000D3AA 209C            	  4028: 	MOVE.l	(a4)+,(a0)			* string address from descriptor stack
01:0000D3AC 315C0004        	  4029: 	MOVE.w	(a4)+,4(a0)			* string length from descriptor stack
01:0000D3B0 6002            	  4030: 	BRA.s		LAB_2044			* skip variable pull
                            	  4031: 
                            	  4032: LAB_204T
01:0000D3B2 209F            	  4033: 	MOVE.l	(sp)+,(a0)			* restore variable from stack
                            	  4034: LAB_2044
01:0000D3B4 101F            	  4035: 	MOVE.b	(sp)+,d0			* pop data type flag (function type)
01:0000D3B6 E318            	  4036: 	ROL.b		#1,d0				* set carry if type = string
01:0000D3B8 6100F88E        	  4037: 	BSR		LAB_CKTM			* type match check, set C for string
01:0000D3BC 4E75            	  4038: 	RTS
                            	  4039: 
                            	  4040: LAB_2045
01:0000D3BE 4A2B05B5        	  4041: 	TST.b		Dtypef(a3)			* test data type
01:0000D3C2 6A0007E4        	  4042: 	BPL		LAB_2778			* if numeric pack FAC1 into variable (a0)
                            	  4043: 							* and return
                            	  4044: 
01:0000D3C6 2448            	  4045: 	MOVEA.l	a0,a2				* copy variable pointer
01:0000D3C8 6000F516        	  4046: 	BRA		LAB_17D6			* go do string LET & return
                            	  4047: 
                            	  4048: 
                            	  4049: 
                            	  4050: *************************************************************************************
                            	  4051: *
                            	  4052: * perform STR$()
                            	  4053: 
                            	  4054: LAB_STRS
01:0000D3CC 61000940        	  4055: 	BSR		LAB_2970			* convert FAC1 to string
                            	  4056: 
                            	  4057: * scan, set up string
                            	  4058: * print " terminated string to FAC1 stack
                            	  4059: 
                            	  4060: LAB_20AE
01:0000D3D0 7422            	  4061: 	MOVEQ		#$22,d2			* set Srchc character (terminator 1)
01:0000D3D2 3602            	  4062: 	MOVE.w	d2,d3				* set Asrch character (terminator 2)
                            	  4063: 
                            	  4064: * print d2/d3 terminated string to FAC1 stack
                            	  4065: * d2 = Srchc, d3 = Asrch, a0 is source
                            	  4066: * a6 is temp
                            	  4067: 
                            	  4068: LAB_20B4
01:0000D3D4 7200            	  4069: 	MOVEQ		#0,d1				* clear longword
01:0000D3D6 5341            	  4070: 	SUBQ.w	#1,d1				* set length to -1
01:0000D3D8 2448            	  4071: 	MOVEA.l	a0,a2				* copy start to calculate end
                            	  4072: LAB_20BE
01:0000D3DA 5241            	  4073: 	ADDQ.w	#1,d1				* increment length
01:0000D3DC 10301000        	  4074: 	MOVE.b	(a0,d1.w),d0		* get byte from string
01:0000D3E0 6710            	  4075: 	BEQ.s		LAB_20D0			* exit loop if null byte [EOS]
                            	  4076: 
01:0000D3E2 B002            	  4077: 	CMP.b		d2,d0				* compare with search character (terminator 1)
01:0000D3E4 6704            	  4078: 	BEQ.s		LAB_20CB			* branch if terminator
                            	  4079: 
01:0000D3E6 B003            	  4080: 	CMP.b		d3,d0				* compare with terminator 2
01:0000D3E8 66F0            	  4081: 	BNE.s		LAB_20BE			* loop if not terminator 2 (or null string)
                            	  4082: 
                            	  4083: LAB_20CB
01:0000D3EA B03C0022        	  4084: 	CMP.b		#$22,d0			* compare with "
01:0000D3EE 6602            	  4085: 	BNE.s		LAB_20D0			* branch if not "
                            	  4086: 
01:0000D3F0 524A            	  4087: 	ADDQ.w	#1,a2				* else increment string start (skip " at end)
                            	  4088: LAB_20D0
01:0000D3F2 D5C1            	  4089: 	ADDA.l	d1,a2				* add longowrd length to make string end+1
                            	  4090: 
01:0000D3F4 B1CB            	  4091: 	CMPA.l	a3,a0				* is string in ram
01:0000D3F6 651E            	  4092: 	BCS.s		LAB_RTST			* if not go push descriptor on stack & exit
                            	  4093: 							* (could be message string from ROM)
                            	  4094: 
01:0000D3F8 B1EB042E        	  4095: 	CMPA.l	Smeml(a3),a0		* is string in utility ram
01:0000D3FC 6418            	  4096: 	BCC.s		LAB_RTST			* if not go push descriptor on stack & exit
                            	  4097: 							* (is in string or program space)
                            	  4098: 
                            	  4099: 							* (else) copy string to string memory
                            	  4100: LAB_20C9
01:0000D3FE 2248            	  4101: 	MOVEA.l	a0,a1				* copy descriptor pointer
01:0000D400 2001            	  4102: 	MOVE.l	d1,d0				* copy longword length
01:0000D402 6604            	  4103: 	BNE.s		LAB_20D8			* branch if not null string
                            	  4104: 
01:0000D404 2041            	  4105: 	MOVEA.l	d1,a0				* make null pointer
01:0000D406 600E            	  4106: 	BRA.s		LAB_RTST			* go push descriptor on stack & exit
                            	  4107: 
                            	  4108: LAB_20D8
01:0000D408 6126            	  4109: 	BSR.s		LAB_2115			* make string space d1 bytes long
01:0000D40A D1C1            	  4110: 	ADDA.l	d1,a0				* new string end
01:0000D40C D3C1            	  4111: 	ADDA.l	d1,a1				* old string end
01:0000D40E 5340            	  4112: 	SUBQ.w	#1,d0				* -1 for DBF loop
                            	  4113: LAB_20E0
01:0000D410 1121            	  4114: 	MOVE.b	-(a1),-(a0)			* copy byte (source can be odd aligned)
01:0000D412 51C8FFFC        	  4115: 	DBF		d0,LAB_20E0			* loop until done
                            	  4116: 
                            	  4117: 
                            	  4118: 
                            	  4119: *************************************************************************************
                            	  4120: *
                            	  4121: * check for space on descriptor stack then ...
                            	  4122: * put string address and length on descriptor stack & update stack pointers
                            	  4123: * start is in a0, length is in d1
                            	  4124: 
                            	  4125: LAB_RTST
01:0000D416 43EB0476        	  4126: 	LEA		des_sk_e(a3),a1		* get string stack pointer max+1
01:0000D41A B9C9            	  4127: 	CMPA.l	a1,a4				* compare string stack pointer with max+1
01:0000D41C 6700ED2E        	  4128: 	BEQ		LAB_SCER			* if no space on string stack ..
                            	  4129: 							* .. go do 'string too complex' error
                            	  4130: 
                            	  4131: 							* push string & update pointers
01:0000D420 3901            	  4132: 	MOVE.w	d1,-(a4)			* string length on descriptor stack
01:0000D422 2908            	  4133: 	MOVE.l	a0,-(a4)			* string address on stack
01:0000D424 274C0590        	  4134: 	MOVE.l	a4,FAC1_m(a3)		* string descriptor pointer in FAC1
01:0000D428 177C008005B5    	  4135: 	MOVE.b	#$80,Dtypef(a3)		* save data type flag, $80=string
01:0000D42E 4E75            	  4136: 	RTS
                            	  4137: 
                            	  4138: 
                            	  4139: *************************************************************************************
                            	  4140: *
                            	  4141: * build descriptor a0/d1
                            	  4142: * make space in string memory for string d1.w long
                            	  4143: * return pointer in a0/Sutill
                            	  4144: 
                            	  4145: LAB_2115
01:0000D430 4A41            	  4146: 	TST.w		d1				* test length
01:0000D432 672E            	  4147: 	BEQ.s		LAB_2128			* branch if user wants null string
                            	  4148: 
                            	  4149: 							* make space for string d1 long
01:0000D434 2F00            	  4150: 	MOVE.l	d0,-(sp)			* save d0
01:0000D436 7000            	  4151: 	MOVEQ		#0,d0				* clear longword
01:0000D438 174005DE        	  4152: 	MOVE.b	d0,Gclctd(a3)		* clear garbage collected flag (b7)
01:0000D43C 7001            	  4153: 	MOVEQ		#1,d0				* +1 to possibly round up
01:0000D43E C041            	  4154: 	AND.w		d1,d0				* mask odd bit
01:0000D440 D041            	  4155: 	ADD.w		d1,d0				* ensure d0 is even length
01:0000D442 6404            	  4156: 	BCC.s		LAB_2117			* branch if no overflow
                            	  4157: 
01:0000D444 7001            	  4158: 	MOVEQ		#1,d0				* set to allocate 65536 bytes
01:0000D446 4840            	  4159: 	SWAP		d0				* makes $00010000
                            	  4160: LAB_2117
01:0000D448 206B0446        	  4161: 	MOVEA.l	Sstorl(a3),a0		* get bottom of string space
01:0000D44C 91C0            	  4162: 	SUBA.l	d0,a0				* subtract string length
01:0000D44E B1EB0442        	  4163: 	CMPA.l	Earryl(a3),a0		* compare with top of array space
01:0000D452 6512            	  4164: 	BCS.s		LAB_2137			* if less do out of memory error
                            	  4165: 
01:0000D454 27480446        	  4166: 	MOVE.l	a0,Sstorl(a3)		* save bottom of string space
01:0000D458 2748044E        	  4167: 	MOVE.l	a0,Sutill(a3)		* save string utility pointer
01:0000D45C 201F            	  4168: 	MOVE.l	(sp)+,d0			* restore d0
01:0000D45E 4A41            	  4169: 	TST.w		d1				* set flags on length
01:0000D460 4E75            	  4170: 	RTS
                            	  4171: 
                            	  4172: LAB_2128
01:0000D462 3041            	  4173: 	MOVEA.w	d1,a0				* make null pointer
01:0000D464 4E75            	  4174: 	RTS
                            	  4175: 
                            	  4176: LAB_2137
01:0000D466 4A2B05DE        	  4177: 	TST.b		Gclctd(a3)			* get garbage collected flag
01:0000D46A 6B00ED00        	  4178: 	BMI		LAB_OMER			* do "Out of memory" error, then warm start
                            	  4179: 
01:0000D46E 2F09            	  4180: 	MOVE.l	a1,-(sp)			* save a1
01:0000D470 610A            	  4181: 	BSR.s		LAB_GARB			* else go do garbage collection
01:0000D472 225F            	  4182: 	MOVEA.l	(sp)+,a1			* restore a1
01:0000D474 177C008005DE    	  4183: 	MOVE.b	#$80,Gclctd(a3)		* set garbage collected flag
01:0000D47A 60CC            	  4184: 	BRA.s		LAB_2117			* go try again
                            	  4185: 
                            	  4186: 
                            	  4187: *************************************************************************************
                            	  4188: *
                            	  4189: * garbage collection routine
                            	  4190: 
                            	  4191: LAB_GARB
01:0000D47C 48E7E0E0        	  4192: 	MOVEM.l	d0-d2/a0-a2,-(sp)		* save registers
01:0000D480 276B044A0446    	  4193: 	MOVE.l	Ememl(a3),Sstorl(a3)	* start with no strings
                            	  4194: 
                            	  4195: 							* re-run routine from last ending
                            	  4196: LAB_214B
01:0000D486 222B0442        	  4197: 	MOVE.l	Earryl(a3),d1		* set highest uncollected string so far
01:0000D48A 7000            	  4198: 	MOVEQ		#0,d0				* clear longword
01:0000D48C 2240            	  4199: 	MOVEA.l	d0,a1				* clear string to move pointer
01:0000D48E 206B043A        	  4200: 	MOVEA.l	Sstrl(a3),a0		* set pointer to start of strings
01:0000D492 5888            	  4201: 	LEA		4(a0),a0			* index to string pointer
01:0000D494 246B043E        	  4202: 	MOVEA.l	Sarryl(a3),a2		* set end pointer to start of arrays (end of
                            	  4203: 							* strings)
01:0000D498 6006            	  4204: 	BRA.s		LAB_2176			* branch into loop at end loop test
                            	  4205: 
                            	  4206: LAB_2161
01:0000D49A 617E            	  4207: 	BSR		LAB_2206			* test and set if this is the highest string
01:0000D49C 41E8000A        	  4208: 	LEA		10(a0),a0			* increment to next string
                            	  4209: LAB_2176
01:0000D4A0 B1CA            	  4210: 	CMPA.l	a2,a0				* compare end of area with pointer
01:0000D4A2 65F6            	  4211: 	BCS.s		LAB_2161			* go do next if not at end
                            	  4212: 
                            	  4213: * done strings, now do arrays.
                            	  4214: 
01:0000D4A4 5988            	  4215: 	LEA		-4(a0),a0			* decrement pointer to start of arrays
01:0000D4A6 246B0442        	  4216: 	MOVEA.l	Earryl(a3),a2		* set end pointer to end of arrays
01:0000D4AA 6024            	  4217: 	BRA.s		LAB_218F			* branch into loop at end loop test
                            	  4218: 
                            	  4219: LAB_217E
01:0000D4AC 24280004        	  4220: 	MOVE.l	4(a0),d2			* get array size
01:0000D4B0 D488            	  4221: 	ADD.l		a0,d2				* makes start of next array
                            	  4222: 
01:0000D4B2 2010            	  4223: 	MOVE.l	(a0),d0			* get array name
01:0000D4B4 08000017        	  4224: 	BTST		#23,d0			* test string flag
01:0000D4B8 6714            	  4225: 	BEQ.s		LAB_218B			* branch if not string
                            	  4226: 
01:0000D4BA 30280008        	  4227: 	MOVE.w	8(a0),d0			* get # of dimensions
01:0000D4BE D040            	  4228: 	ADD.w		d0,d0				* *2
01:0000D4C0 D0C0            	  4229: 	ADDA.w	d0,a0				* add to skip dimension size(s)
01:0000D4C2 41E8000A        	  4230: 	LEA		10(a0),a0			* increment to first element
                            	  4231: LAB_2183
01:0000D4C6 6152            	  4232: 	BSR.s		LAB_2206			* test and set if this is the highest string
01:0000D4C8 5C48            	  4233: 	ADDQ.w	#6,a0				* increment to next element
01:0000D4CA B1C2            	  4234: 	CMPA.l	d2,a0				* compare with start of next array
01:0000D4CC 66F8            	  4235: 	BNE.s		LAB_2183			* go do next if not at end of array
                            	  4236: 
                            	  4237: LAB_218B
01:0000D4CE 2042            	  4238: 	MOVEA.l	d2,a0				* pointer to next array
                            	  4239: LAB_218F
01:0000D4D0 B5C8            	  4240: 	CMPA.l	a0,a2				* compare pointer with array end
01:0000D4D2 66D8            	  4241: 	BNE.s		LAB_217E			* go do next if not at end
                            	  4242: 
                            	  4243: * done arrays and variables, now just the descriptor stack to do
                            	  4244: 
01:0000D4D4 204C            	  4245: 	MOVEA.l	a4,a0				* get descriptor stack pointer
01:0000D4D6 45EB048E        	  4246: 	LEA		des_sk(a3),a2		* set end pointer to end of stack
01:0000D4DA 6004            	  4247: 	BRA.s		LAB_21C4			* branch into loop at end loop test
                            	  4248: 
                            	  4249: LAB_21C2
01:0000D4DC 613C            	  4250: 	BSR.s		LAB_2206			* test and set if this is the highest string
01:0000D4DE 5C88            	  4251: 	LEA		6(a0),a0			* increment to next string
                            	  4252: LAB_21C4
01:0000D4E0 B5C8            	  4253: 	CMPA.l	a0,a2				* compare pointer with stack end
01:0000D4E2 66F8            	  4254: 	BNE.s		LAB_21C2			* go do next if not at end
                            	  4255: 
                            	  4256: * descriptor search complete, now either exit or set-up and move string
                            	  4257: 
01:0000D4E4 2009            	  4258: 	MOVE.l	a1,d0				* set the flags (a1 is move string)
01:0000D4E6 672C            	  4259: 	BEQ.s		LAB_21D1			* go tidy up and exit if no move
                            	  4260: 
01:0000D4E8 2051            	  4261: 	MOVEA.l	(a1),a0			* a0 is now string start
01:0000D4EA 7200            	  4262: 	MOVEQ		#0,d1				* clear d1
01:0000D4EC 32290004        	  4263: 	MOVE.w	4(a1),d1			* d1 is string length
01:0000D4F0 5281            	  4264: 	ADDQ.l	#1,d1				* +1
01:0000D4F2 C23C00FE        	  4265: 	AND.b		#$FE,d1			* make even length
01:0000D4F6 D1C1            	  4266: 	ADDA.l	d1,a0				* pointer is now to string end+1
01:0000D4F8 246B0446        	  4267: 	MOVEA.l	Sstorl(a3),a2		* is destination end+1
01:0000D4FC B1CA            	  4268: 	CMPA.l	a2,a0				* does the string need moving
01:0000D4FE 670C            	  4269: 	BEQ.s		LAB_2240			* branch if not
                            	  4270: 
01:0000D500 E289            	  4271: 	LSR.l		#1,d1				* word move so do /2
01:0000D502 5341            	  4272: 	SUBQ.w	#1,d1				* -1 for DBF loop
                            	  4273: LAB_2216
01:0000D504 3520            	  4274: 	MOVE.w	-(a0),-(a2)			* copy word
01:0000D506 51C9FFFC        	  4275: 	DBF		d1,LAB_2216			* loop until done
                            	  4276: 
01:0000D50A 228A            	  4277: 	MOVE.l	a2,(a1)			* save new string start
                            	  4278: LAB_2240
01:0000D50C 27510446        	  4279: 	MOVE.l	(a1),Sstorl(a3)		* string start is new string mem start
01:0000D510 6000FF74        	  4280: 	BRA		LAB_214B			* re-run routine from last ending
                            	  4281: 							* (but don't collect this string)
                            	  4282: 
                            	  4283: LAB_21D1
01:0000D514 4CDF0707        	  4284: 	MOVEM.l	(sp)+,d0-d2/a0-a2		* restore registers
01:0000D518 4E75            	  4285: 	RTS
                            	  4286: 
                            	  4287: * test and set if this is the highest string
                            	  4288: 
                            	  4289: LAB_2206
01:0000D51A 2010            	  4290: 	MOVE.l	(a0),d0			* get this string pointer
01:0000D51C 6728            	  4291: 	BEQ.s		RTS_012			* exit if null string
                            	  4292: 
01:0000D51E B280            	  4293: 	CMP.l		d0,d1				* compare with highest uncollected string so far
01:0000D520 6424            	  4294: 	BCC.s		RTS_012			* exit if <= with highest so far
                            	  4295: 
01:0000D522 B0AB0446        	  4296: 	CMP.l		Sstorl(a3),d0		* compare with bottom of string space
01:0000D526 641E            	  4297: 	BCC.s		RTS_012			* exit if >= bottom of string space
                            	  4298: 
01:0000D528 70FF            	  4299: 	MOVEQ		#-1,d0			* d0 = $FFFFFFFF
01:0000D52A 30280004        	  4300: 	MOVE.w	4(a0),d0			* d0 is string length
01:0000D52E 4440            	  4301: 	NEG.w		d0				* make -ve
01:0000D530 C03C00FE        	  4302: 	AND.b		#$FE,d0			* make -ve even length
01:0000D534 D0AB0446        	  4303: 	ADD.l		Sstorl(a3),d0		* add string store to -ve length
01:0000D538 B090            	  4304: 	CMP.l		(a0),d0			* compare with string address
01:0000D53A 6706            	  4305: 	BEQ.s		LAB_2212			* if = go move string store pointer down
                            	  4306: 
01:0000D53C 2210            	  4307: 	MOVE.l	(a0),d1			* highest = current
01:0000D53E 2248            	  4308: 	MOVEA.l	a0,a1				* string to move = current
01:0000D540 4E75            	  4309: 	RTS
                            	  4310: 
                            	  4311: LAB_2212
01:0000D542 27400446        	  4312: 	MOVE.l	d0,Sstorl(a3)		* set new string store start
                            	  4313: RTS_012
01:0000D546 4E75            	  4314: 	RTS
                            	  4315: 
                            	  4316: 
                            	  4317: *************************************************************************************
                            	  4318: *
                            	  4319: * concatenate - add strings
                            	  4320: * string descriptor 1 is in FAC1_m, string 2 is in line
                            	  4321: 
                            	  4322: LAB_224D
01:0000D548 487AF744        	  4323: 	PEA		LAB_1ADB(pc)		* continue evaluation after concatenate
01:0000D54C 2F2B0590        	  4324: 	MOVE.l	FAC1_m(a3),-(sp)		* stack descriptor pointer for string 1
                            	  4325: 
01:0000D550 6100F818        	  4326: 	BSR		LAB_GVAL			* get value from line
01:0000D554 4A2B05B5        	  4327: 	TST.b		Dtypef(a3)			* test data type flag
01:0000D558 6A00EBFA        	  4328: 	BPL		LAB_TMER			* if type is not string do type mismatch error
                            	  4329: 
01:0000D55C 205F            	  4330: 	MOVEA.l	(sp)+,a0			* restore descriptor pointer for string 1
                            	  4331: 
                            	  4332: *************************************************************************************
                            	  4333: *
                            	  4334: * concatenate
                            	  4335: * string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
                            	  4336: 
                            	  4337: LAB_224E
01:0000D55E 226B0590        	  4338: 	MOVEA.l	FAC1_m(a3),a1		* copy descriptor pointer 2
01:0000D562 32280004        	  4339: 	MOVE.w	4(a0),d1			* get length 1
01:0000D566 D2690004        	  4340: 	ADD.w		4(a1),d1			* add length 2
01:0000D56A 6500EBE4        	  4341: 	BCS		LAB_SLER			* if overflow go do 'string too long' error
                            	  4342: 
01:0000D56E 2F08            	  4343: 	MOVE.l	a0,-(sp)			* save descriptor pointer 1
01:0000D570 6100FEBE        	  4344: 	BSR		LAB_2115			* make space d1 bytes long
01:0000D574 27480598        	  4345: 	MOVE.l	a0,FAC2_m(a3)		* save new string start pointer
01:0000D578 2057            	  4346: 	MOVEA.l	(sp),a0			* copy descriptor pointer 1 from stack
01:0000D57A 30280004        	  4347: 	MOVE.w	4(a0),d0			* get length
01:0000D57E 2050            	  4348: 	MOVEA.l	(a0),a0			* get string pointer
01:0000D580 6120            	  4349: 	BSR.s		LAB_229E			* copy string d0 bytes long from a0 to Sutill
                            	  4350: 							* return with a0 = pointer, d1 = length
                            	  4351: 
01:0000D582 206B0590        	  4352: 	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer for string 2
01:0000D586 6138            	  4353: 	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  4354: 							* a0 = pointer, d0 = length
01:0000D588 6118            	  4355: 	BSR.s		LAB_229E			* copy string d0 bytes long from a0 to Sutill
                            	  4356: 							* return with a0 = pointer, d1 = length
                            	  4357: 
01:0000D58A 205F            	  4358: 	MOVEA.l	(sp)+,a0			* get descriptor pointer for string 1
01:0000D58C 6132            	  4359: 	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  4360: 							* d0 = length, a0 = pointer
                            	  4361: 
01:0000D58E 206B0598        	  4362: 	MOVEA.l	FAC2_m(a3),a0		* retreive the result string pointer
01:0000D592 2208            	  4363: 	MOVE.l	a0,d1				* copy the result string pointer
01:0000D594 6700FE80        	  4364: 	BEQ		LAB_RTST			* if it is a null string just return it
                            	  4365: 							* a0 = pointer, d1 = length
                            	  4366: 
01:0000D598 4481            	  4367: 	NEG.l		d1				* else make the start pointer negative
01:0000D59A D2AB044E        	  4368: 	ADD.l		Sutill(a3),d1		* add the end pointert to give the length
01:0000D59E 6000FE76        	  4369: 	BRA		LAB_RTST			* push string on descriptor stack
                            	  4370: 							* a0 = pointer, d1 = length
                            	  4371: 
                            	  4372: 
                            	  4373: *************************************************************************************
                            	  4374: *
                            	  4375: * copy string d0 bytes long from a0 to Sutill
                            	  4376: * return with a0 = pointer, d1 = length
                            	  4377: 
                            	  4378: LAB_229E
01:0000D5A2 3200            	  4379: 	MOVE.w	d0,d1				* copy and check length
01:0000D5A4 6714            	  4380: 	BEQ.s		RTS_013			* skip copy if null
                            	  4381: 
01:0000D5A6 226B044E        	  4382: 	MOVEA.l	Sutill(a3),a1		* get destination pointer
01:0000D5AA 2F09            	  4383: 	MOVE.l	a1,-(sp)			* save destination string pointer
01:0000D5AC 5340            	  4384: 	SUBQ.w	#1,d0				* subtract for DBF loop
                            	  4385: LAB_22A0
01:0000D5AE 12D8            	  4386: 	MOVE.b	(a0)+,(a1)+			* copy byte
01:0000D5B0 51C8FFFC        	  4387: 	DBF		d0,LAB_22A0			* loop if not done
                            	  4388: 
01:0000D5B4 2749044E        	  4389: 	MOVE.l	a1,Sutill(a3)		* update Sutill to end of copied string
01:0000D5B8 205F            	  4390: 	MOVEA.l	(sp)+,a0			* restore destination string pointer
                            	  4391: RTS_013
01:0000D5BA 4E75            	  4392: 	RTS
                            	  4393: 
                            	  4394: 
                            	  4395: *************************************************************************************
                            	  4396: *
                            	  4397: * pop string off descriptor stack, or from top of string space
                            	  4398: * returns with d0.l = length, a0 = pointer
                            	  4399: 
                            	  4400: LAB_22B6
01:0000D5BC 206B0590        	  4401: 	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer
                            	  4402: 
                            	  4403: 
                            	  4404: *************************************************************************************
                            	  4405: *
                            	  4406: * pop (a0) descriptor off stack or from string space
                            	  4407: * returns with d0.l = length, a0 = pointer
                            	  4408: 
                            	  4409: LAB_22BA
01:0000D5C0 48E74040        	  4410: 	MOVEM.l	a1/d1,-(sp)			* save other regs
01:0000D5C4 B9C8            	  4411: 	CMPA.l	a0,a4				* is string on the descriptor stack
01:0000D5C6 6602            	  4412: 	BNE.s		LAB_22BD			* skip pop if not
                            	  4413: 
01:0000D5C8 5C4C            	  4414: 	ADDQ.w	#$06,a4			* else update stack pointer
                            	  4415: LAB_22BD
01:0000D5CA 7000            	  4416: 	MOVEQ		#0,d0				* clear string length longword
01:0000D5CC 2258            	  4417: 	MOVEA.l	(a0)+,a1			* get string address
01:0000D5CE 3018            	  4418: 	MOVE.w	(a0)+,d0			* get string length
                            	  4419: 
01:0000D5D0 B9C8            	  4420: 	CMPA.l	a0,a4				* was it on the descriptor stack
01:0000D5D2 6610            	  4421: 	BNE.s		LAB_22E6			* branch if it wasn't
                            	  4422: 
01:0000D5D4 B3EB0446        	  4423: 	CMPA.l	Sstorl(a3),a1		* compare string address with bottom of string
                            	  4424: 							* space
01:0000D5D8 660A            	  4425: 	BNE.s		LAB_22E6			* branch if <>
                            	  4426: 
01:0000D5DA 7201            	  4427: 	MOVEQ		#1,d1				* mask for odd bit
01:0000D5DC C240            	  4428: 	AND.w		d0,d1				* AND length
01:0000D5DE D280            	  4429: 	ADD.l		d0,d1				* make it fit word aligned length
                            	  4430: 
01:0000D5E0 D3AB0446        	  4431: 	ADD.l		d1,Sstorl(a3)		* add to bottom of string space
                            	  4432: LAB_22E6
01:0000D5E4 2049            	  4433: 	MOVEA.l	a1,a0				* copy to a0
01:0000D5E6 4CDF0202        	  4434: 	MOVEM.l	(sp)+,a1/d1			* restore other regs
01:0000D5EA 4A80            	  4435: 	TST.l		d0				* set flags on length
01:0000D5EC 4E75            	  4436: 	RTS
                            	  4437: 
                            	  4438: 
                            	  4439: *************************************************************************************
                            	  4440: *
                            	  4441: * perform CHR$()
                            	  4442: 
                            	  4443: LAB_CHRS
01:0000D5EE 61000130        	  4444: 	BSR		LAB_EVBY			* evaluate byte expression, result in d0 and
                            	  4445: 							* Itemp
                            	  4446: LAB_MKCHR
01:0000D5F2 7201            	  4447: 	MOVEQ		#1,d1				* string is single byte
01:0000D5F4 6100FE3A        	  4448: 	BSR		LAB_2115			* make string space d1 bytes long
                            	  4449: 							* return a0/Sutill = pointer, others unchanged
01:0000D5F8 1080            	  4450: 	MOVE.b	d0,(a0)			* save byte in string (byte IS string!)
01:0000D5FA 6000FE1A        	  4451: 	BRA		LAB_RTST			* push string on descriptor stack
                            	  4452: 							* a0 = pointer, d1 = length
                            	  4453: 
                            	  4454: 
                            	  4455: *************************************************************************************
                            	  4456: *
                            	  4457: * perform LEFT$()
                            	  4458: 
                            	  4459: * enter with a0 is descriptor, d0 & Itemp is word 1
                            	  4460: 
                            	  4461: LAB_LEFT
01:0000D5FE C141            	  4462: 	EXG		d0,d1				* word in d1
01:0000D600 6100F7A8        	  4463: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
                            	  4464: 
01:0000D604 4A81            	  4465: 	TST.l		d1				* test returned length
01:0000D606 6722            	  4466: 	BEQ.s		LAB_231C			* branch if null return
                            	  4467: 
01:0000D608 7000            	  4468: 	MOVEQ		#0,d0				* clear start offset
01:0000D60A B2680004        	  4469: 	CMP.w		4(a0),d1			* compare word parameter with string length
01:0000D60E 651A            	  4470: 	BCS.s		LAB_231C			* branch if string length > word parameter
                            	  4471: 
01:0000D610 6014            	  4472: 	BRA.s		LAB_2317			* go copy whole string
                            	  4473: 
                            	  4474: 
                            	  4475: *************************************************************************************
                            	  4476: *
                            	  4477: * perform RIGHT$()
                            	  4478: 
                            	  4479: * enter with a0 is descriptor, d0 & Itemp is word 1
                            	  4480: 
                            	  4481: LAB_RIGHT
01:0000D612 C141            	  4482: 	EXG		d0,d1				* word in d1
01:0000D614 6100F794        	  4483: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
                            	  4484: 
01:0000D618 4A81            	  4485: 	TST.l		d1				* test returned length
01:0000D61A 670E            	  4486: 	BEQ.s		LAB_231C			* branch if null return
                            	  4487: 
01:0000D61C 30280004        	  4488: 	MOVE.w	4(a0),d0			* get string length
01:0000D620 9081            	  4489: 	SUB.l		d1,d0				* subtract word
01:0000D622 6406            	  4490: 	BCC.s		LAB_231C			* branch if string length > word parameter
                            	  4491: 
                            	  4492: 							* else copy whole string
                            	  4493: LAB_2316
01:0000D624 7000            	  4494: 	MOVEQ		#0,d0				* clear start offset
                            	  4495: LAB_2317
01:0000D626 32280004        	  4496: 	MOVE.w	4(a0),d1			* else make parameter = length
                            	  4497: 
                            	  4498: * get here with ...
                            	  4499: *   a0 - points to descriptor
                            	  4500: *   d0 - is offset from string start
                            	  4501: *   d1 - is required string length
                            	  4502: 
                            	  4503: LAB_231C
01:0000D62A 2248            	  4504: 	MOVEA.l	a0,a1				* save string descriptor pointer
01:0000D62C 6100FE02        	  4505: 	BSR		LAB_2115			* make string space d1 bytes long
                            	  4506: 							* return a0/Sutill = pointer, others unchanged
01:0000D630 2049            	  4507: 	MOVEA.l	a1,a0				* restore string descriptor pointer
01:0000D632 2F00            	  4508: 	MOVE.l	d0,-(sp)			* save start offset (longword)
01:0000D634 618A            	  4509: 	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  4510: 							* d0 = length, a0 = pointer
01:0000D636 D1DF            	  4511: 	ADDA.l	(sp)+,a0			* adjust pointer to start of wanted string
01:0000D638 3001            	  4512: 	MOVE.w	d1,d0				* length to d0
01:0000D63A 6100FF66        	  4513: 	BSR		LAB_229E			* store string d0 bytes long from (a0) to
                            	  4514: 							* (Sutill) return with a0 = pointer,
                            	  4515: 							* d1 = length
01:0000D63E 6000FDD6        	  4516: 	BRA		LAB_RTST			* push string on descriptor stack
                            	  4517: 							* a0 = pointer, d1 = length
                            	  4518: 
                            	  4519: 
                            	  4520: *************************************************************************************
                            	  4521: *
                            	  4522: * perform MID$()
                            	  4523: 
                            	  4524: * enter with a0 is descriptor, d0 & Itemp is word 1
                            	  4525: 
                            	  4526: LAB_MIDS
01:0000D642 7E00            	  4527: 	MOVEQ		#0,d7				* clear longword
01:0000D644 5347            	  4528: 	SUBQ.w	#1,d7				* set default length = 65535
01:0000D646 2F00            	  4529: 	MOVE.l	d0,-(sp)			* save word 1
01:0000D648 6100F774        	  4530: 	BSR		LAB_GBYT			* scan memory
01:0000D64C B03C002C        	  4531: 	CMP.b		#',',d0			* was it ","
01:0000D650 660C            	  4532: 	BNE.s		LAB_2358			* branch if not "," (skip second byte get)
                            	  4533: 
01:0000D652 101D            	  4534: 	MOVE.b	(a5)+,d0			* increment pointer past ","
01:0000D654 2F08            	  4535: 	MOVE.l	a0,-(sp)			* save descriptor pointer
01:0000D656 610000D8        	  4536: 	BSR		LAB_GTWO			* get word parameter, result in d0 and Itemp
01:0000D65A 205F            	  4537: 	MOVEA.l	(sp)+,a0			* restore descriptor pointer
01:0000D65C 2E00            	  4538: 	MOVE.l	d0,d7				* copy length
                            	  4539: LAB_2358
01:0000D65E 6100F74A        	  4540: 	BSR		LAB_1BFB			* scan for ")", else do syntax error then warm
                            	  4541: 							* start
01:0000D662 201F            	  4542: 	MOVE.l	(sp)+,d0			* restore word 1
01:0000D664 7200            	  4543: 	MOVEQ		#0,d1				* null length
01:0000D666 5380            	  4544: 	SUBQ.l	#1,d0				* decrement start index (word 1)
01:0000D668 6B00EB0A        	  4545: 	BMI		LAB_FCER			* if was null do function call error then warm
                            	  4546: 							* start
                            	  4547: 
01:0000D66C B0680004        	  4548: 	CMP.w		4(a0),d0			* compare string length with start index
01:0000D670 64B8            	  4549: 	BCC.s		LAB_231C			* if start not in string do null string (d1=0)
                            	  4550: 
01:0000D672 2207            	  4551: 	MOVE.l	d7,d1				* get length back
01:0000D674 DE40            	  4552: 	ADD.w		d0,d7				* d7 now = MID$() end
01:0000D676 6506            	  4553: 	BCS.s		LAB_2368			* already too long so do RIGHT$ equivalent
                            	  4554: 
01:0000D678 BE680004        	  4555: 	CMP.w		4(a0),d7			* compare string length with start index+length
01:0000D67C 65AC            	  4556: 	BCS.s		LAB_231C			* if end in string go do string
                            	  4557: 
                            	  4558: LAB_2368
01:0000D67E 32280004        	  4559: 	MOVE.w	4(a0),d1			* get string length
01:0000D682 9240            	  4560: 	SUB.w		d0,d1				* subtract start offset
01:0000D684 60A4            	  4561: 	BRA.s		LAB_231C			* go do string (effectively RIGHT$)
                            	  4562: 
                            	  4563: 
                            	  4564: *************************************************************************************
                            	  4565: *
                            	  4566: * perform LCASE$()
                            	  4567: 
                            	  4568: LAB_LCASE
01:0000D686 6100FF34        	  4569: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4570: 							* returns with d0 = length, a0 = pointer
01:0000D68A 2200            	  4571: 	MOVE.l	d0,d1				* copy the string length
01:0000D68C 6756            	  4572: 	BEQ.s		NoString			* if null go return a null string
                            	  4573: 
                            	  4574: * else copy and change the string
                            	  4575: 
01:0000D68E 2248            	  4576: 	MOVEA.l	a0,a1				* copy the string address
01:0000D690 6100FD9E        	  4577: 	BSR		LAB_2115			* make a string space d1 bytes long
01:0000D694 D1C1            	  4578: 	ADDA.l	d1,a0				* new string end
01:0000D696 D3C1            	  4579: 	ADDA.l	d1,a1				* old string end
01:0000D698 3401            	  4580: 	MOVE.w	d1,d2				* copy length for loop
01:0000D69A 5342            	  4581: 	SUBQ.w	#1,d2				* -1 for DBF loop
                            	  4582: LC_loop
01:0000D69C 1021            	  4583: 	MOVE.b	-(a1),d0			* get byte from string
                            	  4584: 
01:0000D69E B03C005B        	  4585: 	CMP.b		#$5B,d0			* compare with "Z"+1
01:0000D6A2 640A            	  4586: 	BCC.s		NoUcase			* if > "Z" skip change
                            	  4587: 
01:0000D6A4 B03C0041        	  4588: 	CMP.b		#$41,d0			* compare with "A"
01:0000D6A8 6504            	  4589: 	BCS.s		NoUcase			* if < "A" skip change
                            	  4590: 
01:0000D6AA 00000020        	  4591: 	ORI.b		#$20,d0			* convert upper case to lower case
                            	  4592: NoUcase
01:0000D6AE 1100            	  4593: 	MOVE.b	d0,-(a0)			* copy upper case byte back to string
01:0000D6B0 51CAFFEA        	  4594: 	DBF		d2,LC_loop			* decrement and loop if not all done
                            	  4595: 
01:0000D6B4 602E            	  4596: 	BRA.s		NoString			* tidy up & exit (branch always)
                            	  4597: 
                            	  4598: 
                            	  4599: *************************************************************************************
                            	  4600: *
                            	  4601: * perform UCASE$()
                            	  4602: 
                            	  4603: LAB_UCASE
01:0000D6B6 6100FF04        	  4604: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4605: 							* returns with d0 = length, a0 = pointer
01:0000D6BA 2200            	  4606: 	MOVE.l	d0,d1				* copy the string length
01:0000D6BC 6726            	  4607: 	BEQ.s		NoString			* if null go return a null string
                            	  4608: 
                            	  4609: * else copy and change the string
                            	  4610: 
01:0000D6BE 2248            	  4611: 	MOVEA.l	a0,a1				* copy the string address
01:0000D6C0 6100FD6E        	  4612: 	BSR		LAB_2115			* make a string space d1 bytes long
01:0000D6C4 D1C1            	  4613: 	ADDA.l	d1,a0				* new string end
01:0000D6C6 D3C1            	  4614: 	ADDA.l	d1,a1				* old string end
01:0000D6C8 3401            	  4615: 	MOVE.w	d1,d2				* copy length for loop
01:0000D6CA 5342            	  4616: 	SUBQ.w	#1,d2				* -1 for DBF loop
                            	  4617: UC_loop
01:0000D6CC 1021            	  4618: 	MOVE.b	-(a1),d0			* get a byte from the string
                            	  4619: 
01:0000D6CE B03C0061        	  4620: 	CMP.b		#$61,d0			* compare with "a"
01:0000D6D2 650A            	  4621: 	BCS.s		NoLcase			* if < "a" skip change
                            	  4622: 
01:0000D6D4 B03C007B        	  4623: 	CMP.b		#$7B,d0			* compare with "z"+1
01:0000D6D8 6404            	  4624: 	BCC.s		NoLcase			* if > "z" skip change
                            	  4625: 
01:0000D6DA 020000DF        	  4626: 	ANDI.b	#$DF,d0			* convert lower case to upper case
                            	  4627: NoLcase
01:0000D6DE 1100            	  4628: 	MOVE.b	d0,-(a0)			* copy upper case byte back to string
01:0000D6E0 51CAFFEA        	  4629: 	DBF		d2,UC_loop			* decrement and loop if not all done
                            	  4630: 
                            	  4631: NoString
01:0000D6E4 6000FD30        	  4632: 	BRA		LAB_RTST			* push string on descriptor stack
                            	  4633: 							* a0 = pointer, d1 = length
                            	  4634: 
                            	  4635: 
                            	  4636: *************************************************************************************
                            	  4637: *
                            	  4638: * perform SADD()
                            	  4639: 
                            	  4640: LAB_SADD
01:0000D6E8 101D            	  4641: 	MOVE.b	(a5)+,d0			* increment pointer
01:0000D6EA 6100F8DE        	  4642: 	BSR		LAB_GVAR			* get variable address in a0
01:0000D6EE 6100F6BA        	  4643: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
01:0000D6F2 4A2B05B5        	  4644: 	TST.b		Dtypef(a3)			* test data type flag
01:0000D6F6 6A00EA5C        	  4645: 	BPL		LAB_TMER			* if numeric do Type missmatch Error
                            	  4646: 
                            	  4647: * if you want a non existant variable to return a null value then set the novar
                            	  4648: * value at the top of this file to some non zero value
                            	  4649: 
                            	  4650:  ifne	novar
                            	  4651: 
                            	  4652: 	MOVE.l	a0,d0				* test the variable found flag
                            	  4653: 	BEQ		LAB_AYFC			* if not found go return null
                            	  4654: 
                            	  4655:  endc
                            	  4656: 
01:0000D6FA 2010            	  4657: 	MOVE.l	(a0),d0			* get string address
01:0000D6FC 6000FBBC        	  4658: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  4659: 
                            	  4660: 
                            	  4661: *************************************************************************************
                            	  4662: *
                            	  4663: * perform LEN()
                            	  4664: 
                            	  4665: LAB_LENS
01:0000D700 487AFBB8        	  4666: 	PEA		LAB_AYFC(pc)		* set return address to convert d0 to signed
                            	  4667: 							* longword in FAC1
01:0000D704 6000FEB6        	  4668: 	BRA		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4669: 							* returns with d0 = length, a0 = pointer
                            	  4670: 
                            	  4671: 
                            	  4672: *************************************************************************************
                            	  4673: *
                            	  4674: * perform ASC()
                            	  4675: 
                            	  4676: LAB_ASC
01:0000D708 6100FEB2        	  4677: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4678: 							* returns with d0 = length, a0 = pointer
01:0000D70C 4A40            	  4679: 	TST.w		d0				* test length
01:0000D70E 6700EA64        	  4680: 	BEQ		LAB_FCER			* if null do function call error then warm start
                            	  4681: 
01:0000D712 1010            	  4682: 	MOVE.b	(a0),d0			* get first character byte
01:0000D714 6000FBC4        	  4683: 	BRA		LAB_1FD0			* convert d0 to unsigned byte in FAC1 & return
                            	  4684: 
                            	  4685: 
                            	  4686: *************************************************************************************
                            	  4687: *
                            	  4688: * increment and get byte, result in d0 and Itemp
                            	  4689: 
                            	  4690: LAB_SGBY
01:0000D718 6100F6A2        	  4691: 	BSR		LAB_IGBY			* increment & scan memory
                            	  4692: 
                            	  4693: 
                            	  4694: *************************************************************************************
                            	  4695: *
                            	  4696: * get byte parameter, result in d0 and Itemp
                            	  4697: 
                            	  4698: LAB_GTBY
01:0000D71C 6100F526        	  4699: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4700: 							* else do type mismatch
                            	  4701: 
                            	  4702: 
                            	  4703: *************************************************************************************
                            	  4704: *
                            	  4705: * evaluate byte expression, result in d0 and Itemp
                            	  4706: 
                            	  4707: LAB_EVBY
01:0000D720 6100F9DC        	  4708: 	BSR		LAB_EVPI			* evaluate positive integer expression
                            	  4709: 							* result in d0 and Itemp
01:0000D724 7280            	  4710: 	MOVEQ		#$80,d1			* set mask/2
01:0000D726 D281            	  4711: 	ADD.l		d1,d1				* =$FFFFFF00
01:0000D728 C280            	  4712: 	AND.l		d0,d1				* check top 24 bits
01:0000D72A 6600EA48        	  4713: 	BNE		LAB_FCER			* if <> 0 do function call error/warm start
                            	  4714: 
01:0000D72E 4E75            	  4715: 	RTS
                            	  4716: 
                            	  4717: 
                            	  4718: *************************************************************************************
                            	  4719: *
                            	  4720: * get word parameter, result in d0 and Itemp
                            	  4721: 
                            	  4722: LAB_GTWO
01:0000D730 6100F512        	  4723: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4724: 							* else do type mismatch
01:0000D734 6100F9C8        	  4725: 	BSR		LAB_EVPI			* evaluate positive integer expression
                            	  4726: 							* result in d0 and Itemp
01:0000D738 4840            	  4727: 	SWAP		d0				* copy high word to low word
01:0000D73A 4A40            	  4728: 	TST.w		d0				* set flags
01:0000D73C 6600EA36        	  4729: 	BNE		LAB_FCER			* if <> 0 do function call error/warm start
                            	  4730: 
01:0000D740 4840            	  4731: 	SWAP		d0				* copy high word to low word
01:0000D742 4E75            	  4732: 	RTS
                            	  4733: 
                            	  4734: 
                            	  4735: *************************************************************************************
                            	  4736: *
                            	  4737: * perform VAL()
                            	  4738: 
                            	  4739: LAB_VAL
01:0000D744 6100FE76        	  4740: 	BSR		LAB_22B6			* pop string off descriptor stack or from memory
                            	  4741: 							* returns with d0 = length, a0 = pointer
01:0000D748 6722            	  4742: 	BEQ.s		LAB_VALZ			* string was null so set result = $00
                            	  4743: 							* clear FAC1 exponent & sign & return
                            	  4744: 
01:0000D74A 2C4D            	  4745: 	MOVEA.l	a5,a6				* save BASIC execute pointer
01:0000D74C 2A48            	  4746: 	MOVEA.l	a0,a5				* copy string pointer to execute pointer
01:0000D74E D1C0            	  4747: 	ADDA.l	d0,a0				* string end+1
01:0000D750 1010            	  4748: 	MOVE.b	(a0),d0			* get byte from string+1
01:0000D752 3F00            	  4749: 	MOVE.w	d0,-(sp)			* save it
01:0000D754 2F08            	  4750: 	MOVE.l	a0,-(sp)			* save address
01:0000D756 10BC0000        	  4751: 	MOVE.b	#0,(a0)			* null terminate string
01:0000D75A 6100F662        	  4752: 	BSR		LAB_GBYT			* scan memory
01:0000D75E 61001136        	  4753: 	BSR		LAB_2887			* get FAC1 from string
01:0000D762 205F            	  4754: 	MOVEA.l	(sp)+,a0			* restore pointer
01:0000D764 301F            	  4755: 	MOVE.w	(sp)+,d0			* pop byte
01:0000D766 1080            	  4756: 	MOVE.b	d0,(a0)			* restore to memory
01:0000D768 2A4E            	  4757: 	MOVEA.l	a6,a5				* restore BASIC execute pointer
01:0000D76A 4E75            	  4758: 	RTS
                            	  4759: 
                            	  4760: LAB_VALZ
01:0000D76C 37400594        	  4761: 	MOVE.w	d0,FAC1_e(a3)		* clear FAC1 exponent & sign
01:0000D770 4E75            	  4762: 	RTS
                            	  4763: 
                            	  4764: 
                            	  4765: *************************************************************************************
                            	  4766: *
                            	  4767: * get two parameters for POKE or WAIT, first parameter in a0, second in d0
                            	  4768: 
                            	  4769: LAB_GADB
01:0000D772 6100F4D0        	  4770: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4771: 							* else do type mismatch
01:0000D776 6100F98E        	  4772: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4773: 							* (does FC error not OF error if out of range)
01:0000D77A 2F00            	  4774: 	MOVE.l	d0,-(sp)			* copy to stack
01:0000D77C 6100F634        	  4775: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
01:0000D780 619A            	  4776: 	BSR.s		LAB_GTBY			* get byte parameter, result in d0 and Itemp
01:0000D782 205F            	  4777: 	MOVEA.l	(sp)+,a0			* pull address
01:0000D784 4E75            	  4778: 	RTS
                            	  4779: 
                            	  4780: 
                            	  4781: *************************************************************************************
                            	  4782: *
                            	  4783: * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
                            	  4784: 
                            	  4785: LAB_GADW
01:0000D786 611E            	  4786: 	BSR.s		LAB_GEAD			* get even address for word/long memory actions
                            	  4787: 							* address returned in d0 and on the stack
01:0000D788 6100F628        	  4788: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
01:0000D78C 6100F4B6        	  4789: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4790: 							* else do type mismatch
01:0000D790 6100F974        	  4791: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4792: 							* result in d0 and Itemp
01:0000D794 4840            	  4793: 	SWAP		d0				* swap words
01:0000D796 4A40            	  4794: 	TST.w		d0				* test high word
01:0000D798 6706            	  4795: 	BEQ.s		LAB_XGADW			* exit if null
                            	  4796: 
01:0000D79A 5240            	  4797: 	ADDQ.w	#1,d0				* increment word
01:0000D79C 6600E9D6        	  4798: 	BNE		LAB_FCER			* if <> 0 do function call error/warm start
                            	  4799: 
                            	  4800: LAB_XGADW
01:0000D7A0 4840            	  4801: 	SWAP		d0				* swap words back
01:0000D7A2 205F            	  4802: 	MOVEA.l	(sp)+,a0			* pull address
01:0000D7A4 4E75            	  4803: 	RTS
                            	  4804: 
                            	  4805: 
                            	  4806: *************************************************************************************
                            	  4807: *
                            	  4808: * get even address (for word or longword memory actions)
                            	  4809: * address returned in d0 and on the stack
                            	  4810: * does address error if the address is odd
                            	  4811: 
                            	  4812: LAB_GEAD
01:0000D7A6 6100F49C        	  4813: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4814: 							* else do type mismatch
01:0000D7AA 6100F95A        	  4815: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4816: 							* (does FC error not OF error if out of range)
01:0000D7AE 08000000        	  4817: 	BTST		#0,d0				* test low bit of longword
01:0000D7B2 6600E97C        	  4818: 	BNE		LAB_ADER			* if address is odd do address error/warm start
                            	  4819: 
01:0000D7B6 2057            	  4820: 	MOVEA.l	(sp),a0			* copy return address
01:0000D7B8 2E80            	  4821: 	MOVE.l	d0,(sp)			* even address on stack
01:0000D7BA 4ED0            	  4822: 	JMP		(a0)				* effectively RTS
                            	  4823: 
                            	  4824: 
                            	  4825: *************************************************************************************
                            	  4826: *
                            	  4827: * perform PEEK()
                            	  4828: 
                            	  4829: LAB_PEEK
01:0000D7BC 6100F948        	  4830: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4831: 							* (does FC error not OF error if out of range)
01:0000D7C0 2040            	  4832: 	MOVEA.l	d0,a0				* copy to address register
01:0000D7C2 1010            	  4833: 	MOVE.b	(a0),d0			* get byte
01:0000D7C4 6000FB14        	  4834: 	BRA		LAB_1FD0			* convert d0 to unsigned byte in FAC1 & return
                            	  4835: 
                            	  4836: 
                            	  4837: *************************************************************************************
                            	  4838: *
                            	  4839: * perform POKE
                            	  4840: 
                            	  4841: LAB_POKE
01:0000D7C8 61A8            	  4842: 	BSR.s		LAB_GADB			* get two parameters for POKE or WAIT
                            	  4843: 							* first parameter in a0, second in d0
01:0000D7CA 1080            	  4844: 	MOVE.b	d0,(a0)			* put byte in memory
01:0000D7CC 4E75            	  4845: 	RTS
                            	  4846: 
                            	  4847: 
                            	  4848: *************************************************************************************
                            	  4849: *
                            	  4850: * perform DEEK()
                            	  4851: 
                            	  4852: LAB_DEEK
01:0000D7CE 6100F936        	  4853: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4854: 							* (does FC error not OF error if out of range)
01:0000D7D2 E208            	  4855: 	LSR.b		#1,d0				* shift bit 0 to carry
01:0000D7D4 6500E95A        	  4856: 	BCS		LAB_ADER			* if address is odd do address error/warm start
                            	  4857: 
01:0000D7D8 D000            	  4858: 	ADD.b		d0,d0				* shift byte back
01:0000D7DA C188            	  4859: 	EXG		d0,a0				* copy to address register
01:0000D7DC 7000            	  4860: 	MOVEQ		#0,d0				* clear top bits
01:0000D7DE 3010            	  4861: 	MOVE.w	(a0),d0			* get word
01:0000D7E0 6000FAD8        	  4862: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  4863: 
                            	  4864: 
                            	  4865: *************************************************************************************
                            	  4866: *
                            	  4867: * perform LEEK()
                            	  4868: 
                            	  4869: LAB_LEEK
01:0000D7E4 6100F920        	  4870: 	BSR		LAB_EVIR			* evaluate integer expression
                            	  4871: 							* (does FC error not OF error if out of range)
01:0000D7E8 E208            	  4872: 	LSR.b		#1,d0				* shift bit 0 to carry
01:0000D7EA 6500E944        	  4873: 	BCS		LAB_ADER			* if address is odd do address error/warm start
                            	  4874: 
01:0000D7EE D000            	  4875: 	ADD.b		d0,d0				* shift byte back
01:0000D7F0 C188            	  4876: 	EXG		d0,a0				* copy to address register
01:0000D7F2 2010            	  4877: 	MOVE.l	(a0),d0			* get longword
01:0000D7F4 6000FAC4        	  4878: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  4879: 
                            	  4880: 
                            	  4881: *************************************************************************************
                            	  4882: *
                            	  4883: * perform DOKE
                            	  4884: 
                            	  4885: LAB_DOKE
01:0000D7F8 618C            	  4886: 	BSR.s		LAB_GADW			* get two parameters for DOKE or WAIT
                            	  4887: 							* first parameter in a0, second in d0
01:0000D7FA 3080            	  4888: 	MOVE.w	d0,(a0)			* put word in memory
01:0000D7FC 4E75            	  4889: 	RTS
                            	  4890: 
                            	  4891: 
                            	  4892: *************************************************************************************
                            	  4893: *
                            	  4894: * perform LOKE
                            	  4895: 
                            	  4896: LAB_LOKE
01:0000D7FE 61A6            	  4897: 	BSR.s		LAB_GEAD			* get even address for word/long memory actions
                            	  4898: 							* address returned in d0 and on the stack
01:0000D800 6100F5B0        	  4899: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
01:0000D804 6100F43E        	  4900: 	BSR		LAB_EVNM			* evaluate expression & check is numeric,
                            	  4901: 							* else do type mismatch
01:0000D808 6100F8FC        	  4902: 	BSR		LAB_EVIR			* evaluate integer value (no sign check)
01:0000D80C 205F            	  4903: 	MOVEA.l	(sp)+,a0			* pull address
01:0000D80E 2080            	  4904: 	MOVE.l	d0,(a0)			* put longword in memory
                            	  4905: RTS_015
01:0000D810 4E75            	  4906: 	RTS
                            	  4907: 
                            	  4908: 
                            	  4909: *************************************************************************************
                            	  4910: *
                            	  4911: * perform SWAP
                            	  4912: 
                            	  4913: LAB_SWAP
01:0000D812 6100F7B6        	  4914: 	BSR		LAB_GVAR			* get variable 1 address in a0
01:0000D816 2F08            	  4915: 	MOVE.l	a0,-(sp)			* save variable 1 address
01:0000D818 182B05B5        	  4916: 	MOVE.b	Dtypef(a3),d4		* copy variable 1 data type, $80=string,
                            	  4917: 							* $40=inetger, $00=float
                            	  4918: 
01:0000D81C 6100F594        	  4919: 	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
01:0000D820 6100F7A8        	  4920: 	BSR		LAB_GVAR			* get variable 2 address in a0
01:0000D824 245F            	  4921: 	MOVEA.l	(sp)+,a2			* restore variable 1 address
01:0000D826 B82B05B5        	  4922: 	CMP.b		Dtypef(a3),d4		* compare variable 1 data type with variable 2
                            	  4923: 							* data type
01:0000D82A 6600E928        	  4924: 	BNE		LAB_TMER			* if not both the same type do "Type mismatch"
                            	  4925: 							* error then warm start
                            	  4926: 
                            	  4927: * if you do want a non existant variable to return an error then leave the novar
                            	  4928: * value at the top of this file set to zero
                            	  4929: 
                            	  4930:  ifeq	novar
                            	  4931: 
01:0000D82E 2010            	  4932: 	MOVE.l	(a0),d0			* get variable 2
01:0000D830 20D2            	  4933: 	MOVE.l	(a2),(a0)+			* copy variable 1 to variable 2
01:0000D832 24C0            	  4934: 	MOVE.l	d0,(a2)+			* save variable 2 to variable 1
                            	  4935: 
01:0000D834 4A04            	  4936: 	TST.b		d4				* check data type
01:0000D836 6AD8            	  4937: 	BPL.s		RTS_015			* exit if not string
                            	  4938: 
01:0000D838 3010            	  4939: 	MOVE.w	(a0),d0			* get string 2 length
01:0000D83A 3092            	  4940: 	MOVE.w	(a2),(a0)			* copy string 1 length to string 2 length
01:0000D83C 3480            	  4941: 	MOVE.w	d0,(a2)			* save string 2 length to string 1 length
                            	  4942: 
                            	  4943:  endc
                            	  4944: 
                            	  4945: 
                            	  4946: * if you want a non existant variable to return a null value then set the novar
                            	  4947: * value at the top of this file to some non zero value
                            	  4948: 
                            	  4949:  ifne	novar
                            	  4950: 
                            	  4951: 	MOVE.l	a2,d2				* copy the variable 1 pointer
                            	  4952: 	MOVE.l	d2,d3				* and again for any length
                            	  4953: 	BEQ.s		no_variable1		* if variable 1 doesn't exist skip the
                            	  4954: 							* value get
                            	  4955: 
                            	  4956: 	MOVE.l	(a2),d2			* get variable 1 value
                            	  4957: 	TST.b		d4				* check the data type
                            	  4958: 	BPL.s		no_variable1		* if not string skip the length get
                            	  4959: 
                            	  4960: 	MOVE.w	4(a2),d3			* else get variable 1 string length
                            	  4961: no_variable1
                            	  4962: 	MOVE.l	a0,d0				* copy the variable 2 pointer
                            	  4963: 	MOVE.l	d0,d1				* and again for any length
                            	  4964: 	BEQ.s		no_variable2		* if variable 2 doesn't exist skip the
                            	  4965: 							* value get and the new value save
                            	  4966: 
                            	  4967: 	MOVE.l	(a0),d0			* get variable 2 value
                            	  4968: 	MOVE.l	d2,(a0)+			* save variable 2 new value
                            	  4969: 	TST.b		d4				* check the data type
                            	  4970: 	BPL.s		no_variable2		* if not string skip the length get and
                            	  4971: 							* new length save
                            	  4972: 
                            	  4973: 	MOVE.w	(a0),d1			* else get variable 2 string length
                            	  4974: 	MOVE.w	d3,(a0)			* save variable 2 new string length
                            	  4975: no_variable2
                            	  4976: 	TST.l		d2				* test if variable 1 exists
                            	  4977: 	BEQ.s		EXIT_SWAP			* if variable 1 doesn't exist skip the
                            	  4978: 							* new value save
                            	  4979: 
                            	  4980: 	MOVE.l	d0,(a2)+			* save variable 1 new value
                            	  4981: 	TST.b		d4				* check the data type
                            	  4982: 	BPL.s		EXIT_SWAP			* if not string skip the new length save
                            	  4983: 
                            	  4984: 	MOVE.w	d1,(a2)			* save variable 1 new string length
                            	  4985: EXIT_SWAP
                            	  4986: 
                            	  4987:  endc
                            	  4988: 
01:0000D83E 4E75            	  4989: 	RTS
                            	  4990: 
                            	  4991: 
                            	  4992: *************************************************************************************
                            	  4993: *
                            	  4994: * perform USR
                            	  4995: 
                            	  4996: LAB_USR
01:0000D840 4EAB0406        	  4997: 	JSR		Usrjmp(a3)			* do user vector
01:0000D844 6000F564        	  4998: 	BRA		LAB_1BFB			* scan for ")", else do syntax error/warm start
                            	  4999: 
                            	  5000: 
                            	  5001: *************************************************************************************
                            	  5002: *
                            	  5003: * perform LOAD
                            	  5004: 
                            	  5005: LAB_LOAD
01:0000D848 4EEB0418        	  5006: 	JMP		V_LOAD(a3)			* do load vector
                            	  5007: 
                            	  5008: 
                            	  5009: *************************************************************************************
                            	  5010: *
                            	  5011: * perform SAVE
                            	  5012: 
                            	  5013: LAB_SAVE
01:0000D84C 4EEB041E        	  5014: 	JMP		V_SAVE(a3)			* do save vector
                            	  5015: 
                            	  5016: 
                            	  5017: *************************************************************************************
                            	  5018: *
                            	  5019: * perform CALL
                            	  5020: 
                            	  5021: LAB_CALL
01:0000D850 487AF56C        	  5022: 	PEA		LAB_GBYT(pc)		* put return address on stack
01:0000D854 6100FF50        	  5023: 	BSR		LAB_GEAD			* get even address for word/long memory actions
                            	  5024: 							* address returned in d0 and on the stack
01:0000D858 4E75            	  5025: 	RTS						* effectively calls the routine
                            	  5026: 
                            	  5027: * if the called routine exits correctly then it will return via the get byte routine.
                            	  5028: * this will then get the next byte for the interpreter and return
                            	  5029: 
                            	  5030: 
                            	  5031: *************************************************************************************
                            	  5032: *
                            	  5033: * perform WAIT
                            	  5034: 
                            	  5035: LAB_WAIT
01:0000D85A 6100FF16        	  5036: 	BSR		LAB_GADB			* get two parameters for POKE or WAIT
                            	  5037: 							* first parameter in a0, second in d0
01:0000D85E 2F08            	  5038: 	MOVE.l	a0,-(sp)			* save address
01:0000D860 3F00            	  5039: 	MOVE.w	d0,-(sp)			* save byte
01:0000D862 7400            	  5040: 	MOVEQ		#0,d2				* clear mask
01:0000D864 6100F558        	  5041: 	BSR		LAB_GBYT			* scan memory
01:0000D868 6706            	  5042: 	BEQ.s		LAB_2441			* skip if no third argument
                            	  5043: 
01:0000D86A 6100F542        	  5044: 	BSR		LAB_SCGB			* scan for "," & get byte,
                            	  5045: 							* else do syntax error/warm start
01:0000D86E 2400            	  5046: 	MOVE.l	d0,d2				* copy mask
                            	  5047: LAB_2441
01:0000D870 321F            	  5048: 	MOVE.w	(sp)+,d1			* get byte
01:0000D872 205F            	  5049: 	MOVEA.l	(sp)+,a0			* get address
                            	  5050: LAB_2445
01:0000D874 1010            	  5051: 	MOVE.b	(a0),d0			* read memory byte
01:0000D876 B500            	  5052: 	EOR.b		d2,d0				* EOR with second argument (mask)
01:0000D878 C001            	  5053: 	AND.b		d1,d0				* AND with first argument (byte)
01:0000D87A 67F8            	  5054: 	BEQ.s		LAB_2445			* loop if result is zero
                            	  5055: 
01:0000D87C 4E75            	  5056: 	RTS
                            	  5057: 
                            	  5058: 
                            	  5059: *************************************************************************************
                            	  5060: *
                            	  5061: * perform subtraction, FAC1 from FAC2
                            	  5062: 
                            	  5063: LAB_SUBTRACT
01:0000D87E 0A2B00800595    	  5064: 	EORI.b	#$80,FAC1_s(a3)		* complement FAC1 sign
01:0000D884 176B059D059E    	  5065: 	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* copy FAC2 sign byte
                            	  5066: 
01:0000D88A 102B0595        	  5067: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign byte
01:0000D88E B12B059E        	  5068: 	EOR.b		d0,FAC_sc(a3)		* EOR with FAC2 sign
                            	  5069: 
                            	  5070: 
                            	  5071: *************************************************************************************
                            	  5072: *
                            	  5073: * add FAC2 to FAC1
                            	  5074: 
                            	  5075: LAB_ADD
01:0000D892 102B0594        	  5076: 	MOVE.b	FAC1_e(a3),d0		* get exponent
01:0000D896 67000336        	  5077: 	BEQ		LAB_279B			* FAC1 was zero so copy FAC2 to FAC1 & return
                            	  5078: 
                            	  5079: 							* FAC1 is non zero
01:0000D89A 41EB0598        	  5080: 	LEA		FAC2_m(a3),a0		* set pointer1 to FAC2 mantissa
01:0000D89E 102B059C        	  5081: 	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
01:0000D8A2 6746            	  5082: 	BEQ.s		RTS_016			* exit if zero
                            	  5083: 
01:0000D8A4 902B0594        	  5084: 	SUB.b		FAC1_e(a3),d0		* subtract FAC1 exponent
01:0000D8A8 6722            	  5085: 	BEQ.s		LAB_24A8			* branch if = (go add mantissa)
                            	  5086: 
01:0000D8AA 650A            	  5087: 	BCS.s		LAB_249C			* branch if FAC2 < FAC1
                            	  5088: 
                            	  5089: 							* FAC2 > FAC1
01:0000D8AC 376B059C0594    	  5090: 	MOVE.w	FAC2_e(a3),FAC1_e(a3)	* copy sign and exponent of FAC2
01:0000D8B2 4400            	  5091: 	NEG.b		d0				* negate exponent difference (make diff -ve)
01:0000D8B4 5148            	  5092: 	SUBQ.w	#8,a0				* pointer1 to FAC1
                            	  5093: 
                            	  5094: LAB_249C
01:0000D8B6 4400            	  5095: 	NEG.b		d0				* negate exponent difference (make diff +ve)
01:0000D8B8 2F01            	  5096: 	MOVE.l	d1,-(sp)			* save d1
01:0000D8BA B03C0020        	  5097: 	CMP.b		#32,d0			* compare exponent diff with 32
01:0000D8BE 6D04            	  5098: 	BLT.s		LAB_2467			* branch if range >= 32
                            	  5099: 
01:0000D8C0 7200            	  5100: 	MOVEQ		#0,d1				* clear d1
01:0000D8C2 6004            	  5101: 	BRA.s		LAB_2468			* go clear smaller mantissa
                            	  5102: 
                            	  5103: LAB_2467
01:0000D8C4 2210            	  5104: 	MOVE.l	(a0),d1			* get FACx mantissa
01:0000D8C6 E0A9            	  5105: 	LSR.l		d0,d1				* shift d0 times right
                            	  5106: LAB_2468
01:0000D8C8 2081            	  5107: 	MOVE.l	d1,(a0)			* save it back
01:0000D8CA 221F            	  5108: 	MOVE.l	(sp)+,d1			* restore d1
                            	  5109: 
                            	  5110: 							* exponents are equal now do mantissa add or
                            	  5111: 							* subtract
                            	  5112: LAB_24A8
01:0000D8CC 4A2B059E        	  5113: 	TST.b		FAC_sc(a3)			* test sign compare (FAC1 EOR FAC2)
01:0000D8D0 6B1A            	  5114: 	BMI.s		LAB_24F8			* if <> go do subtract
                            	  5115: 
01:0000D8D2 202B0598        	  5116: 	MOVE.l	FAC2_m(a3),d0		* get FAC2 mantissa
01:0000D8D6 D0AB0590        	  5117: 	ADD.l		FAC1_m(a3),d0		* add FAC1 mantissa
01:0000D8DA 640A            	  5118: 	BCC.s		LAB_24F7			* save and exit if no carry (FAC1 is normal)
                            	  5119: 
01:0000D8DC E290            	  5120: 	ROXR.l	#1,d0				* else shift carry back into mantissa
01:0000D8DE 522B0594        	  5121: 	ADDQ.b	#1,FAC1_e(a3)		* increment FAC1 exponent
01:0000D8E2 6500E88C        	  5122: 	BCS		LAB_OFER			* if carry do overflow error & warm start
                            	  5123: 
                            	  5124: LAB_24F7
01:0000D8E6 27400590        	  5125: 	MOVE.l	d0,FAC1_m(a3)		* save mantissa
                            	  5126: RTS_016
01:0000D8EA 4E75            	  5127: 	RTS
                            	  5128: 							* signs are different
                            	  5129: LAB_24F8
01:0000D8EC 43EB0590        	  5130: 	LEA		FAC1_m(a3),a1		* pointer 2 to FAC1
01:0000D8F0 B3C8            	  5131: 	CMPA.l	a0,a1				* compare pointers
01:0000D8F2 6602            	  5132: 	BNE.s		LAB_24B4			* branch if <>
                            	  5133: 
01:0000D8F4 5049            	  5134: 	ADDQ.w	#8,a1				* else pointer2 to FAC2
                            	  5135: 
                            	  5136: 							* take smaller from bigger (take sign of bigger)
                            	  5137: LAB_24B4
01:0000D8F6 2011            	  5138: 	MOVE.l	(a1),d0			* get larger mantissa
01:0000D8F8 2210            	  5139: 	MOVE.l	(a0),d1			* get smaller mantissa
01:0000D8FA 27400590        	  5140: 	MOVE.l	d0,FAC1_m(a3)		* save larger mantissa
01:0000D8FE 93AB0590        	  5141: 	SUB.l		d1,FAC1_m(a3)		* subtract smaller
                            	  5142: 
                            	  5143: 
                            	  5144: *************************************************************************************
                            	  5145: *
                            	  5146: * do +/- (carry is sign) & normalise FAC1
                            	  5147: 
                            	  5148: LAB_24D0
01:0000D902 6408            	  5149: 	BCC.s		LAB_24D5			* branch if result is +ve
                            	  5150: 
                            	  5151: 							* erk! subtract is the wrong way round so
                            	  5152: 							* negate everything
01:0000D904 462B0595        	  5153: 	EORI.b	#$FF,FAC1_s(a3)		* complement FAC1 sign
01:0000D908 44AB0590        	  5154: 	NEG.l		FAC1_m(a3)			* negate FAC1 mantissa
                            	  5155: 
                            	  5156: 
                            	  5157: *************************************************************************************
                            	  5158: *
                            	  5159: * normalise FAC1
                            	  5160: 
                            	  5161: LAB_24D5
01:0000D90C 202B0590        	  5162: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:0000D910 6B2E            	  5163: 	BMI.s		LAB_24DA			* mantissa is normal so just exit
                            	  5164: 
01:0000D912 6606            	  5165: 	BNE.s		LAB_24D9			* mantissa is not zero so go normalise FAC1
                            	  5166: 
01:0000D914 37400594        	  5167: 	MOVE.w	d0,FAC1_e(a3)		* else make FAC1 = +zero
01:0000D918 4E75            	  5168: 	RTS
                            	  5169: 
                            	  5170: LAB_24D9
01:0000D91A 2F01            	  5171: 	MOVE.l	d1,-(sp)			* save d1
01:0000D91C 2200            	  5172: 	MOVE.l	d0,d1				* mantissa to d1
01:0000D91E 7000            	  5173: 	MOVEQ		#0,d0				* clear d0
01:0000D920 102B0594        	  5174: 	MOVE.b	FAC1_e(a3),d0		* get exponent byte
01:0000D924 6714            	  5175: 	BEQ.s		LAB_24D8			* if exponent is zero then clean up and exit
                            	  5176: LAB_24D6
01:0000D926 D281            	  5177: 	ADD.l		d1,d1				* shift mantissa, ADD is quicker for a single
                            	  5178: 							* shift
01:0000D928 5BC8FFFC        	  5179: 	DBMI		d0,LAB_24D6			* decrement exponent and loop if mantissa and
                            	  5180: 							* exponent +ve
                            	  5181: 
01:0000D92C 4A40            	  5182: 	TST.w		d0				* test exponent
01:0000D92E 670A            	  5183: 	BEQ.s		LAB_24D8			* if exponent is zero make FAC1 zero
                            	  5184: 
01:0000D930 6A02            	  5185: 	BPL.s		LAB_24D7			* if exponent is >zero go save FAC1
                            	  5186: 
01:0000D932 7001            	  5187: 	MOVEQ		#1,d0				* else set for zero after correction
                            	  5188: LAB_24D7
01:0000D934 5300            	  5189: 	SUBQ.b	#1,d0				* adjust exponent for loop
01:0000D936 27410590        	  5190: 	MOVE.l	d1,FAC1_m(a3)		* save normalised mantissa
                            	  5191: LAB_24D8
01:0000D93A 221F            	  5192: 	MOVE.l	(sp)+,d1			* restore d1
01:0000D93C 17400594        	  5193: 	MOVE.b	d0,FAC1_e(a3)		* save corrected exponent
                            	  5194: LAB_24DA
01:0000D940 4E75            	  5195: 	RTS
                            	  5196: 
                            	  5197: 
                            	  5198: *************************************************************************************
                            	  5199: *
                            	  5200: * perform LOG()
                            	  5201: 
                            	  5202: LAB_LOG
01:0000D942 4A2B0595        	  5203: 	TST.b		FAC1_s(a3)			* test sign
01:0000D946 6B00E82C        	  5204: 	BMI		LAB_FCER			* if -ve do function call error/warm start
                            	  5205: 
01:0000D94A 7E00            	  5206: 	MOVEQ		#0,d7				* clear d7
01:0000D94C 1747059E        	  5207: 	MOVE.b	d7,FAC_sc(a3)		* clear sign compare
01:0000D950 1E2B0594        	  5208: 	MOVE.b	FAC1_e(a3),d7		* get exponent
01:0000D954 6700E81E        	  5209: 	BEQ		LAB_FCER			* if 0 do function call error/warm start
                            	  5210: 
01:0000D958 9EBC00000081    	  5211: 	SUB.l		#$81,d7			* normalise exponent
01:0000D95E 177C00810594    	  5212: 	MOVE.b	#$81,FAC1_e(a3)		* force a value between 1 and 2
01:0000D964 2C2B0590        	  5213: 	MOVE.l	FAC1_m(a3),d6		* copy mantissa
                            	  5214: 
01:0000D968 277C800000000598	  5215: 	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 1
01:0000D970 377C8100059C    	  5216: 	MOVE.w	#$8100,FAC2_e(a3)		* set exponent for 1
01:0000D976 6100FF1A        	  5217: 	BSR		LAB_ADD			* find arg+1
01:0000D97A 7000            	  5218: 	MOVEQ		#0,d0				* setup for calc skip
01:0000D97C 3740059C        	  5219: 	MOVE.w	d0,FAC2_e(a3)		* set FAC1 for zero result
01:0000D980 DC86            	  5220: 	ADD.l		d6,d6				* shift 1 bit out
01:0000D982 27460598        	  5221: 	MOVE.l	d6,FAC2_m(a3)		* put back FAC2
01:0000D986 6758            	  5222: 	BEQ.s		LAB_LONN			* if 0 skip calculation
                            	  5223: 
01:0000D988 377C8000059C    	  5224: 	MOVE.w	#$8000,FAC2_e(a3)		* set exponent for .5
01:0000D98E 61000130        	  5225: 	BSR		LAB_DIVIDE			* do (arg-1)/(arg+1)
01:0000D992 4A2B0594        	  5226: 	TST.b		FAC1_e(a3)			* test exponent
01:0000D996 6748            	  5227: 	BEQ.s		LAB_LONN			* if 0 skip calculation
                            	  5228: 
01:0000D998 122B0594        	  5229: 	MOVE.b	FAC1_e(a3),d1		* get exponent
01:0000D99C 923C0082        	  5230: 	SUB.b		#$82,d1			* normalise and two integer bits
01:0000D9A0 4401            	  5231: 	NEG.b		d1				* negate for shift
                            	  5232: **	CMP.b		#$1F,d1			* will mantissa vanish?
                            	  5233: **	BGT.s		LAB_dunno			* if so do ???
                            	  5234: 
01:0000D9A2 202B0590        	  5235: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:0000D9A6 E2A8            	  5236: 	LSR.l		d1,d0				* shift in two integer bits
                            	  5237: 
                            	  5238: * d0 = arg
                            	  5239: * d0 = x, d1 = y
                            	  5240: * d2 = x1, d3 = y1
                            	  5241: * d4 = shift count
                            	  5242: * d5 = loop count
                            	  5243: * d6 = z
                            	  5244: * a0 = table pointer
                            	  5245: 
01:0000D9A8 7C00            	  5246: 	MOVEQ		#0,d6				* z = 0
01:0000D9AA 223C40000000    	  5247: 	MOVE.l	#1<<30,d1			* y = 1
01:0000D9B0 41FA13F4        	  5248: 	LEA		TAB_HTHET(pc),a0		* get pointer to hyperbolic tangent table
01:0000D9B4 7A1E            	  5249: 	MOVEQ		#30,d5			* loop 31 times
01:0000D9B6 7801            	  5250: 	MOVEQ		#1,d4				* set shift count
01:0000D9B8 6006            	  5251: 	BRA.s		LAB_LOCC			* entry point for loop
                            	  5252: 
                            	  5253: LAB_LAAD
01:0000D9BA E8A2            	  5254: 	ASR.l		d4,d2				* x1 >> i
01:0000D9BC 9282            	  5255: 	SUB.l		d2,d1				* y = y - x1
01:0000D9BE DC90            	  5256: 	ADD.l		(a0),d6			* z = z + tanh(i)
                            	  5257: LAB_LOCC
01:0000D9C0 2400            	  5258: 	MOVE.l	d0,d2				* x1 = x
01:0000D9C2 2601            	  5259: 	MOVE.l	d1,d3				* y1 = Y
01:0000D9C4 E8A3            	  5260: 	ASR.l		d4,d3				* y1 >> i
01:0000D9C6 6402            	  5261: 	BCC.s		LAB_LOLP
                            	  5262: 
01:0000D9C8 5283            	  5263: 	ADDQ.l	#1,d3
                            	  5264: LAB_LOLP
01:0000D9CA 9083            	  5265: 	SUB.l		d3,d0				* x = x - y1
01:0000D9CC 6AEC            	  5266: 	BPL.s		LAB_LAAD			* branch if > 0
                            	  5267: 
01:0000D9CE 2002            	  5268: 	MOVE.l	d2,d0				* get x back
01:0000D9D0 5848            	  5269: 	ADDQ.w	#4,a0				* next entry
01:0000D9D2 5284            	  5270: 	ADDQ.l	#1,d4				* next i
01:0000D9D4 E28B            	  5271: 	LSR.l		#1,d3				* /2
01:0000D9D6 6704            	  5272: 	BEQ.s		LAB_LOCX			* branch y1 = 0
                            	  5273: 
01:0000D9D8 51CDFFF0        	  5274: 	DBF		d5,LAB_LOLP			* decrement and loop if not done
                            	  5275: 
                            	  5276: 							* now sort out the result
                            	  5277: LAB_LOCX
01:0000D9DC DC86            	  5278: 	ADD.l		d6,d6				* *2
01:0000D9DE 2006            	  5279: 	MOVE.l	d6,d0				* setup for d7 = 0
                            	  5280: LAB_LONN
01:0000D9E0 2800            	  5281: 	MOVE.l	d0,d4				* save cordic result
01:0000D9E2 7A00            	  5282: 	MOVEQ		#0,d5				* set default exponent sign
01:0000D9E4 4A87            	  5283: 	TST.l		d7				* check original exponent sign
01:0000D9E6 6716            	  5284: 	BEQ.s		LAB_LOXO			* branch if original was 0
                            	  5285: 
01:0000D9E8 6A04            	  5286: 	BPL.s		LAB_LOXP			* branch if was +ve
                            	  5287: 
01:0000D9EA 4487            	  5288: 	NEG.l		d7				* make original exponent +ve
01:0000D9EC 7A80            	  5289: 	MOVEQ		#$80-$100,d5		* make sign -ve
                            	  5290: LAB_LOXP
01:0000D9EE 17450595        	  5291: 	MOVE.b	d5,FAC1_s(a3)		* save original exponent sign
01:0000D9F2 4847            	  5292: 	SWAP		d7				* 16 bit shift
01:0000D9F4 E18F            	  5293: 	LSL.l		#8,d7				* easy first part
01:0000D9F6 7A88            	  5294: 	MOVEQ		#$88-$100,d5		* start with byte
                            	  5295: LAB_LONE
01:0000D9F8 5385            	  5296: 	SUBQ.l	#1,d5				* decrement exponent
01:0000D9FA DE87            	  5297: 	ADD.l		d7,d7				* shift mantissa
01:0000D9FC 6AFA            	  5298: 	BPL.s		LAB_LONE			* loop if not normal
                            	  5299: 
                            	  5300: LAB_LOXO
01:0000D9FE 27470590        	  5301: 	MOVE.l	d7,FAC1_m(a3)		* save original exponent as mantissa
01:0000DA02 17450594        	  5302: 	MOVE.b	d5,FAC1_e(a3)		* save exponent for this
01:0000DA06 277CB17217F80598	  5303: 	MOVE.l	#$B17217F8,FAC2_m(a3)	* LOG(2) mantissa
01:0000DA0E 377C8000059C    	  5304: 	MOVE.w	#$8000,FAC2_e(a3)		* LOG(2) exponent & sign
01:0000DA14 176B0595059E    	  5305: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make sign compare = FAC1 sign
01:0000DA1A 6118            	  5306: 	BSR.s		LAB_MULTIPLY		* do multiply
01:0000DA1C 27440598        	  5307: 	MOVE.l	d4,FAC2_m(a3)		* save cordic result
01:0000DA20 6710            	  5308: 	BEQ.s		LAB_LOWZ			* branch if zero
                            	  5309: 
01:0000DA22 377C8200059C    	  5310: 	MOVE.w	#$8200,FAC2_e(a3)		* set exponent & sign
01:0000DA28 176B0595059E    	  5311: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* clear sign compare
01:0000DA2E 6100FE62        	  5312: 	BSR		LAB_ADD			* and add for final result
                            	  5313: 
                            	  5314: LAB_LOWZ
01:0000DA32 4E75            	  5315: 	RTS
                            	  5316: 
                            	  5317: 
                            	  5318: *************************************************************************************
                            	  5319: *
                            	  5320: * multiply FAC1 by FAC2
                            	  5321: 
                            	  5322: LAB_MULTIPLY
01:0000DA34 48E7F800        	  5323: 	MOVEM.l	d0-d4,-(sp)			* save registers
01:0000DA38 4A2B0594        	  5324: 	TST.b		FAC1_e(a3)			* test FAC1 exponent
01:0000DA3C 6776            	  5325: 	BEQ.s		LAB_MUUF			* if exponent zero go make result zero
                            	  5326: 
01:0000DA3E 102B059C        	  5327: 	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
01:0000DA42 6770            	  5328: 	BEQ.s		LAB_MUUF			* if exponent zero go make result zero
                            	  5329: 
01:0000DA44 176B059E0595    	  5330: 	MOVE.b	FAC_sc(a3),FAC1_s(a3)	* sign compare becomes sign
                            	  5331: 
01:0000DA4A D02B0594        	  5332: 	ADD.b		FAC1_e(a3),d0		* multiply exponents by adding
01:0000DA4E 640A            	  5333: 	BCC.s		LAB_MNOC			* branch if no carry
                            	  5334: 
01:0000DA50 903C0080        	  5335: 	SUB.b		#$80,d0			* normalise result
01:0000DA54 6400E71A        	  5336: 	BCC		LAB_OFER			* if no carry do overflow
                            	  5337: 
01:0000DA58 6006            	  5338: 	BRA.s		LAB_MADD			* branch
                            	  5339: 
                            	  5340: 							* no carry for exponent add
                            	  5341: LAB_MNOC
01:0000DA5A 903C0080        	  5342: 	SUB.b		#$80,d0			* normalise result
01:0000DA5E 6554            	  5343: 	BCS.s		LAB_MUUF			* return zero if underflow
                            	  5344: 
                            	  5345: LAB_MADD
01:0000DA60 17400594        	  5346: 	MOVE.b	d0,FAC1_e(a3)		* save exponent
                            	  5347: 
                            	  5348: 							* d1 (FAC1) x d2 (FAC2)
01:0000DA64 222B0590        	  5349: 	MOVE.l	FAC1_m(a3),d1		* get FAC1 mantissa
01:0000DA68 242B0598        	  5350: 	MOVE.l	FAC2_m(a3),d2		* get FAC2 mantissa
                            	  5351: 
01:0000DA6C 3801            	  5352: 	MOVE.w	d1,d4				* copy low word FAC1
01:0000DA6E 2001            	  5353: 	MOVE.l	d1,d0				* copy long word FAC1
01:0000DA70 4840            	  5354: 	SWAP		d0				* high word FAC1 to low word FAC1
01:0000DA72 3600            	  5355: 	MOVE.w	d0,d3				* copy high word FAC1
                            	  5356: 
01:0000DA74 C2C2            	  5357: 	MULU		d2,d1				* low word FAC2 x low word FAC1
01:0000DA76 C0C2            	  5358: 	MULU		d2,d0				* low word FAC2 x high word FAC1
01:0000DA78 4842            	  5359: 	SWAP		d2				* high word FAC2 to low word FAC2
01:0000DA7A C8C2            	  5360: 	MULU		d2,d4				* high word FAC2 x low word FAC1
01:0000DA7C C6C2            	  5361: 	MULU		d2,d3				* high word FAC2 x high word FAC1
                            	  5362: 
                            	  5363: * done multiply, now add partial products
                            	  5364: 
                            	  5365: *			d1 =					aaaa  ----	FAC2_L x FAC1_L
                            	  5366: *			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
                            	  5367: *			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
                            	  5368: *			d3 =			cccc  bbbb			FAC2_H x FAC1_H
                            	  5369: *			product =		mmmm  mmmm
                            	  5370: 
01:0000DA7E D2BC00008000    	  5371: 	ADD.L		#$8000,d1			* round up lowest word
01:0000DA84 4241            	  5372: 	CLR.w		d1				* clear low word, don't need it
01:0000DA86 4841            	  5373: 	SWAP		d1				* align high word
01:0000DA88 D280            	  5374: 	ADD.l		d0,d1				* add FAC2_L x FAC1_H (can't be carry)
                            	  5375: LAB_MUF1
01:0000DA8A D284            	  5376: 	ADD.l		d4,d1				* now add intermediate (FAC2_H x FAC1_L)
01:0000DA8C 6406            	  5377: 	BCC.s		LAB_MUF2			* branch if no carry
                            	  5378: 
01:0000DA8E D6BC00010000    	  5379: 	ADD.l		#$10000,d3			* else correct result
                            	  5380: LAB_MUF2
01:0000DA94 D2BC00008000    	  5381: 	ADD.l		#$8000,d1			* round up low word
01:0000DA9A 4241            	  5382: 	CLR.w		d1				* clear low word
01:0000DA9C 4841            	  5383: 	SWAP		d1				* align for final add
01:0000DA9E D283            	  5384: 	ADD.l		d3,d1				* add FAC2_H x FAC1_H, result
01:0000DAA0 6B08            	  5385: 	BMI.s		LAB_MUF3			* branch if normalisation not needed
                            	  5386: 
01:0000DAA2 D281            	  5387: 	ADD.l		d1,d1				* shift mantissa
01:0000DAA4 532B0594        	  5388: 	SUBQ.b	#1,FAC1_e(a3)		* adjust exponent
01:0000DAA8 670A            	  5389: 	BEQ.s		LAB_MUUF			* branch if underflow
                            	  5390: 
                            	  5391: LAB_MUF3
01:0000DAAA 27410590        	  5392: 	MOVE.l	d1,FAC1_m(a3)		* save mantissa
                            	  5393: LAB_MUEX
01:0000DAAE 4CDF001F        	  5394: 	MOVEM.l	(sp)+,d0-d4			* restore registers
01:0000DAB2 4E75            	  5395: 	RTS
                            	  5396: 							* either zero or underflow result
                            	  5397: LAB_MUUF
01:0000DAB4 7000            	  5398: 	MOVEQ		#0,d0				* quick clear
01:0000DAB6 27400590        	  5399: 	MOVE.l	d0,FAC1_m(a3)		* clear mantissa
01:0000DABA 37400594        	  5400: 	MOVE.w	d0,FAC1_e(a3)		* clear sign and exponent
01:0000DABE 60EE            	  5401: 	BRA.s		LAB_MUEX			* restore regs & exit
                            	  5402: 
                            	  5403: 
                            	  5404: *************************************************************************************
                            	  5405: *
                            	  5406: * do FAC2/FAC1, result in FAC1
                            	  5407: * fast hardware divide version
                            	  5408: 
                            	  5409: LAB_DIVIDE
01:0000DAC0 2F07            	  5410: 	MOVE.l	d7,-(sp)			* save d7
01:0000DAC2 7000            	  5411: 	MOVEQ		#0,d0				* clear FAC2 exponent
01:0000DAC4 2400            	  5412: 	MOVE.l	d0,d2				* clear FAC1 exponent
                            	  5413: 
01:0000DAC6 142B0594        	  5414: 	MOVE.b	FAC1_e(a3),d2		* get FAC1 exponent
01:0000DACA 6700E690        	  5415: 	BEQ		LAB_DZER			* if zero go do /0 error
                            	  5416: 
01:0000DACE 102B059C        	  5417: 	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
01:0000DAD2 6766            	  5418: 	BEQ.s		LAB_DIV0			* if zero return zero
                            	  5419: 
01:0000DAD4 9042            	  5420: 	SUB.w		d2,d0				* get result exponent by subtracting
01:0000DAD6 D07C0080        	  5421: 	ADD.w		#$80,d0			* correct 16 bit exponent result
                            	  5422: 
01:0000DADA 176B059E0595    	  5423: 	MOVE.b	FAC_sc(a3),FAC1_s(a3)	* sign compare is result sign
                            	  5424: 
                            	  5425: * now to do 32/32 bit mantissa divide
                            	  5426: 
01:0000DAE0 422B059F        	  5427: 	CLR.b		flag(a3)			* clear 'flag' byte
01:0000DAE4 262B0590        	  5428: 	MOVE.l	FAC1_m(a3),d3		* get FAC1 mantissa
01:0000DAE8 282B0598        	  5429: 	MOVE.l	FAC2_m(a3),d4		* get FAC2 mantissa
01:0000DAEC B883            	  5430: 	CMP.l		d3,d4				* compare FAC2 with FAC1 mantissa
01:0000DAEE 6744            	  5431: 	BEQ.s		LAB_MAN1			* set mantissa result = 1 if equal
                            	  5432: 
01:0000DAF0 6506            	  5433: 	BCS.s		AC1gtAC2			* branch if FAC1 > FAC2
                            	  5434: 
01:0000DAF2 9883            	  5435: 	SUB.l		d3,d4				* subtract FAC1 from FAC2, result now must be <1
01:0000DAF4 562B059F        	  5436: 	ADDQ.b	#3,flag(a3)			* FAC2>FAC1 so set 'flag' byte
                            	  5437: AC1gtAC2
01:0000DAF8 6146            	  5438: 	BSR.s		LAB_32_16			* do 32/16 divide
01:0000DAFA 4841            	  5439: 	SWAP		d1				* move 16 bit result to high word
01:0000DAFC 2802            	  5440: 	MOVE.l	d2,d4				* copy remainder longword
01:0000DAFE 6142            	  5441: 	BSR.s		LAB_3216			* do 32/16 divide again (skip copy d4 to d2)
01:0000DB00 84C5            	  5442: 	DIVU.w	d5,d2				* now divide remainder to make guard word
01:0000DB02 1E2B059F        	  5443: 	MOVE.b	flag(a3),d7			* now normalise, get flag byte back
01:0000DB06 6708            	  5444: 	BEQ.s		LAB_DIVX			* skip add if null
                            	  5445: 
                            	  5446: * else result was >1 so we need to add 1 to result mantissa and adjust exponent
                            	  5447: 
01:0000DB08 E20F            	  5448: 	LSR.b		#1,d7				* shift 1 into eXtend
01:0000DB0A E291            	  5449: 	ROXR.l	#1,d1				* shift extend result >>
01:0000DB0C E252            	  5450: 	ROXR.w	#1,d2				* shift extend guard word >>
01:0000DB0E 5200            	  5451: 	ADDQ.b	#1,d0				* adjust exponent
                            	  5452: 
                            	  5453: * now round result to 32 bits
                            	  5454: 
                            	  5455: LAB_DIVX
01:0000DB10 D442            	  5456: 	ADD.w		d2,d2				* guard bit into eXtend bit
01:0000DB12 6408            	  5457: 	BCC.s		L_DIVRND			* branch if guard=0
                            	  5458: 
01:0000DB14 5281            	  5459: 	ADDQ.l	#1,d1				* add guard to mantissa
01:0000DB16 6404            	  5460: 	BCC.s		L_DIVRND			* branch if no overflow
                            	  5461: 
                            	  5462: LAB_SET1
01:0000DB18 E291            	  5463: 	ROXR.l	#1,d1				* shift extend result >>
01:0000DB1A 5240            	  5464: 	ADDQ.w	#1,d0				* adjust exponent
                            	  5465: 
                            	  5466: 							* test for over/under flow
                            	  5467: L_DIVRND
01:0000DB1C 3600            	  5468: 	MOVE.w	d0,d3				* copy exponent
01:0000DB1E 6B1A            	  5469: 	BMI.s		LAB_DIV0			* if -ve return zero
                            	  5470: 
01:0000DB20 0243FF00        	  5471: 	ANDI.w	#$FF00,d3			* mask word high byte
01:0000DB24 6600E64A        	  5472: 	BNE		LAB_OFER			* branch if overflow
                            	  5473: 
                            	  5474: 							* move result into FAC1
                            	  5475: LAB_XDIV
01:0000DB28 2E1F            	  5476: 	MOVE.l	(sp)+,d7			* restore d7
01:0000DB2A 17400594        	  5477: 	MOVE.b	d0,FAC1_e(a3)		* save result exponent
01:0000DB2E 27410590        	  5478: 	MOVE.l	d1,FAC1_m(a3)		* save result mantissa
01:0000DB32 4E75            	  5479: 	RTS
                            	  5480: 
                            	  5481: * FAC1 mantissa = FAC2 mantissa so set result mantissa
                            	  5482: 
                            	  5483: LAB_MAN1
01:0000DB34 7201            	  5484: 	MOVEQ		#1,d1				* set bit
01:0000DB36 E2A9            	  5485: 	LSR.l		d1,d1				* bit into eXtend
01:0000DB38 60DE            	  5486: 	BRA.s		LAB_SET1			* set mantissa, adjust exponent and exit
                            	  5487: 
                            	  5488: * result is zero
                            	  5489: 
                            	  5490: LAB_DIV0
01:0000DB3A 7000            	  5491: 	MOVEQ		#0,d0				* zero exponent & sign
01:0000DB3C 2200            	  5492: 	MOVE.l	d0,d1				* zero mantissa
01:0000DB3E 60E8            	  5493: 	BRA		LAB_XDIV			* exit divide
                            	  5494: 
                            	  5495: * divide 16 bits into 32, AB/Ex
                            	  5496: *
                            	  5497: * d4			AAAA	BBBB			* 32 bit numerator
                            	  5498: * d3			EEEE	xxxx			* 16 bit denominator
                            	  5499: *
                            	  5500: * returns -
                            	  5501: *
                            	  5502: * d1			xxxx	DDDD			* 16 bit result
                            	  5503: * d2				HHHH	IIII		* 32 bit remainder
                            	  5504: 
                            	  5505: LAB_32_16
01:0000DB40 2404            	  5506: 	MOVE.l	d4,d2				* copy FAC2 mantissa		(AB)
                            	  5507: LAB_3216
01:0000DB42 2A03            	  5508: 	MOVE.l	d3,d5				* copy FAC1 mantissa		(EF)
01:0000DB44 4245            	  5509: 	CLR.w		d5				* clear low word d1		(Ex)
01:0000DB46 4845            	  5510: 	SWAP		d5				* swap high word to low word	(xE)
                            	  5511: 
                            	  5512: * d3			EEEE	FFFF			* denominator copy
                            	  5513: * d5		0000	EEEE				* denominator high word
                            	  5514: * d2			AAAA	BBBB			* numerator copy
                            	  5515: * d4			AAAA	BBBB			* numerator
                            	  5516: 
01:0000DB48 88C5            	  5517: 	DIVU.w	d5,d4				* do FAC2/FAC1 high word	(AB/E)
01:0000DB4A 6802            	  5518: 	BVC.s		LAB_LT_1			* if no overflow DIV was ok
                            	  5519: 
01:0000DB4C 78FF            	  5520: 	MOVEQ		#-1,d4			* else set default value
                            	  5521: 
                            	  5522: * done the divide, now check the result, we have ...
                            	  5523: 
                            	  5524: * d3			EEEE	FFFF			* denominator copy
                            	  5525: * d5		0000	EEEE				* denominator high word
                            	  5526: * d2			AAAA	BBBB			* numerator copy
                            	  5527: * d4			MMMM	DDDD			* result MOD and DIV
                            	  5528: 
                            	  5529: LAB_LT_1
01:0000DB4E 3C04            	  5530: 	MOVE.w	d4,d6				* copy 16 bit result
01:0000DB50 3204            	  5531: 	MOVE.w	d4,d1				* copy 16 bit result again
                            	  5532: 
                            	  5533: * we now have ..
                            	  5534: * d3			EEEE	FFFF			* denominator copy
                            	  5535: * d5		0000	EEEE				* denominator high word
                            	  5536: * d6			xxxx  DDDD			* result DIV copy
                            	  5537: * d1			xxxx  DDDD			* result DIV copy
                            	  5538: * d2			AAAA	BBBB			* numerator copy
                            	  5539: * d4			MMMM	DDDD			* result MOD and DIV
                            	  5540: 
                            	  5541: * now multiply out 32 bit denominator by 16 bit result
                            	  5542: * QRS = AB*D
                            	  5543: 
01:0000DB52 CCC3            	  5544: 	MULU.w	d3,d6				* FFFF * DDDD =       rrrr  SSSS
01:0000DB54 C8C5            	  5545: 	MULU.w	d5,d4				* EEEE * DDDD = QQQQ  rrrr
                            	  5546: 
                            	  5547: * we now have ..
                            	  5548: * d3			EEEE	FFFF			* denominator copy
                            	  5549: * d5		0000	EEEE				* denominator high word
                            	  5550: * d6				rrrr  SSSS		* 48 bit result partial low
                            	  5551: * d1			xxxx  DDDD			* result DIV copy
                            	  5552: * d2			AAAA	BBBB			* numerator copy
                            	  5553: * d4			QQQQ	rrrr			* 48 bit result partial
                            	  5554: 
01:0000DB56 3E06            	  5555: 	MOVE.w	d6,d7				* copy low word of low multiply
                            	  5556: 
                            	  5557: * d7				xxxx	SSSS		* 48 bit result partial low
                            	  5558: 
01:0000DB58 4246            	  5559: 	CLR.w		d6				* clear low word of low multiply
01:0000DB5A 4846            	  5560: 	SWAP		d6				* high word of low multiply to low word
                            	  5561: 
                            	  5562: * d6			0000	rrrr			* high word of 48 bit result partial low
                            	  5563: 
01:0000DB5C D886            	  5564: 	ADD.l		d6,d4
                            	  5565: 
                            	  5566: * d4			QQQQ	RRRR			* 48 bit result partial high longword
                            	  5567: 
01:0000DB5E 7C00            	  5568: 	MOVEQ		#0,d6				* clear to extend numerator to 48 bits
                            	  5569: 
                            	  5570: * now do GHI = AB0 - QRS (which is the remainder)
                            	  5571: 
01:0000DB60 9C47            	  5572: 	SUB.w		d7,d6				* low word subtract
                            	  5573: 
                            	  5574: * d6				xxxx	IIII		* remainder low word
                            	  5575: 
01:0000DB62 9584            	  5576: 	SUBX.l	d4,d2				* high longword subtract
                            	  5577: 
                            	  5578: * d2			GGGG	HHHH			* remainder high longword
                            	  5579: 
                            	  5580: * now if we got the divide correct then the remainder high longword will be +ve
                            	  5581: 
01:0000DB64 6A08            	  5582: 	BPL.s		L_DDIV			* branch if result is ok (<needed)
                            	  5583: 
                            	  5584: * remainder was -ve so DDDD is too big
                            	  5585: 
                            	  5586: LAB_REMM
01:0000DB66 5341            	  5587: 	SUBQ.w	#1,d1				* adjust DDDD
                            	  5588: 
                            	  5589: * d3				xxxx	FFFF		* denominator copy
                            	  5590: * d6				xxxx	IIII		* remainder low word
                            	  5591: 
01:0000DB68 DC43            	  5592: 	ADD.w		d3,d6				* add EF*1 low remainder low word
                            	  5593: 
                            	  5594: * d5			0000	EEEE			* denominator high word
                            	  5595: * d2			GGGG	HHHH			* remainder high longword
                            	  5596: 
01:0000DB6A D585            	  5597: 	ADDX.l	d5,d2				* add extend EF*1 to remainder high longword
01:0000DB6C 6BF8            	  5598: 	BMI.s		LAB_REMM			* loop if result still too big
                            	  5599: 
                            	  5600: * all done and result correct or <
                            	  5601: 
                            	  5602: L_DDIV
01:0000DB6E 4842            	  5603: 	SWAP		d2				* remainder mid word to high word
                            	  5604: 
                            	  5605: * d2			HHHH	GGGG			* (high word /should/ be $0000)
                            	  5606: 
01:0000DB70 3406            	  5607: 	MOVE.w	d6,d2				* remainder in high word
                            	  5608: 
                            	  5609: * d2				HHHH	IIII		* now is 32 bit remainder
                            	  5610: * d1			xxxx	DDDD			* 16 bit result
                            	  5611: 
01:0000DB72 4E75            	  5612: 	RTS
                            	  5613: 
                            	  5614: 
                            	  5615: *************************************************************************************
                            	  5616: *
                            	  5617: * unpack memory (a0) into FAC1
                            	  5618: 
                            	  5619: LAB_UFAC
01:0000DB74 2010            	  5620: 	MOVE.l	(a0),d0			* get packed value
01:0000DB76 4840            	  5621: 	SWAP		d0				* exponent and sign into least significant word
01:0000DB78 37400594        	  5622: 	MOVE.w	d0,FAC1_e(a3)		* save exponent and sign
01:0000DB7C 6708            	  5623: 	BEQ.s		LAB_NB1T			* branch if exponent (and the rest) zero
                            	  5624: 
01:0000DB7E 807C0080        	  5625: 	OR.w		#$80,d0			* set MSb
01:0000DB82 4840            	  5626: 	SWAP		d0				* word order back to normal
01:0000DB84 E180            	  5627: 	ASL.l		#8,d0				* shift exponent & clear guard byte
                            	  5628: LAB_NB1T
01:0000DB86 27400590        	  5629: 	MOVE.l	d0,FAC1_m(a3)		* move into FAC1
                            	  5630: 
01:0000DB8A 102B0594        	  5631: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:0000DB8E 4E75            	  5632: 	RTS
                            	  5633: 
                            	  5634: 
                            	  5635: *************************************************************************************
                            	  5636: *
                            	  5637: * set numeric variable, pack FAC1 into Lvarpl
                            	  5638: 
                            	  5639: LAB_PFAC
01:0000DB90 2F08            	  5640: 	MOVE.l	a0,-(sp)			* save pointer
01:0000DB92 206B0472        	  5641: 	MOVEA.l	Lvarpl(a3),a0		* get destination pointer
01:0000DB96 082B000605B5    	  5642: 	BTST		#6,Dtypef(a3)		* test data type
01:0000DB9C 670C            	  5643: 	BEQ.s		LAB_277C			* branch if floating
                            	  5644: 
01:0000DB9E 610000C6        	  5645: 	BSR		LAB_2831			* convert FAC1 floating to fixed
                            	  5646: 							* result in d0 and Itemp
01:0000DBA2 2080            	  5647: 	MOVE.l	d0,(a0)			* save in var
01:0000DBA4 205F            	  5648: 	MOVE.l	(sp)+,a0			* restore pointer
01:0000DBA6 4E75            	  5649: 	RTS
                            	  5650: 
                            	  5651: 
                            	  5652: *************************************************************************************
                            	  5653: *
                            	  5654: * normalise round and pack FAC1 into (a0)
                            	  5655: 
                            	  5656: LAB_2778
01:0000DBA8 2F08            	  5657: 	MOVE.l	a0,-(sp)			* save pointer
                            	  5658: LAB_277C
01:0000DBAA 6100FD60        	  5659: 	BSR		LAB_24D5			* normalise FAC1
01:0000DBAE 612C            	  5660: 	BSR.s		LAB_27BA			* round FAC1
01:0000DBB0 202B0590        	  5661: 	MOVE.l	FAC1_m(a3),d0		* get FAC1 mantissa
01:0000DBB4 E098            	  5662: 	ROR.l		#8,d0				* align 24/32 bit mantissa
01:0000DBB6 4840            	  5663: 	SWAP		d0				* exponent/sign into 0-15
01:0000DBB8 C07C007F        	  5664: 	AND.w		#$7F,d0			* clear exponent and sign bit
01:0000DBBC 022B00800595    	  5665: 	ANDI.b	#$80,FAC1_s(a3)		* clear non sign bits in sign
01:0000DBC2 806B0594        	  5666: 	OR.w		FAC1_e(a3),d0		* OR in exponent and sign
01:0000DBC6 4840            	  5667: 	SWAP		d0				* move exponent and sign back to 16-31
01:0000DBC8 2080            	  5668: 	MOVE.l	d0,(a0)			* store in destination
01:0000DBCA 205F            	  5669: 	MOVE.l	(sp)+,a0			* restore pointer
01:0000DBCC 4E75            	  5670: 	RTS
                            	  5671: 
                            	  5672: 
                            	  5673: *************************************************************************************
                            	  5674: *
                            	  5675: * copy FAC2 to FAC1
                            	  5676: 
                            	  5677: LAB_279B
01:0000DBCE 376B059C0594    	  5678: 	MOVE.w	FAC2_e(a3),FAC1_e(a3)	* copy exponent & sign
01:0000DBD4 276B05980590    	  5679: 	MOVE.l	FAC2_m(a3),FAC1_m(a3)	* copy mantissa
01:0000DBDA 4E75            	  5680: 	RTS
                            	  5681: 
                            	  5682: 
                            	  5683: *************************************************************************************
                            	  5684: *
                            	  5685: * round FAC1
                            	  5686: 
                            	  5687: LAB_27BA
01:0000DBDC 102B0594        	  5688: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:0000DBE0 6720            	  5689: 	BEQ.s		LAB_27C4			* branch if zero
                            	  5690: 
01:0000DBE2 202B0590        	  5691: 	MOVE.l	FAC1_m(a3),d0		* get FAC1
01:0000DBE6 D0BC00000080    	  5692: 	ADD.l		#$80,d0			* round to 24 bit
01:0000DBEC 640A            	  5693: 	BCC.s		LAB_27C3			* branch if no overflow
                            	  5694: 
01:0000DBEE E290            	  5695: 	ROXR.l	#1,d0				* shift FAC1 mantissa
01:0000DBF0 522B0594        	  5696: 	ADDQ.b	#1,FAC1_e(a3)		* correct exponent
01:0000DBF4 6500E57A        	  5697: 	BCS		LAB_OFER			* if carry do overflow error & warm start
                            	  5698: 
                            	  5699: LAB_27C3
01:0000DBF8 C03C0000        	  5700: 	AND.b		#$00,d0			* clear guard byte
01:0000DBFC 27400590        	  5701: 	MOVE.l	d0,FAC1_m(a3)		* save back to FAC1
01:0000DC00 4E75            	  5702: 	RTS
                            	  5703: 
                            	  5704: LAB_27C4
01:0000DC02 17400595        	  5705: 	MOVE.b	d0,FAC1_s(a3)		* make zero always +ve
                            	  5706: RTS_017
01:0000DC06 4E75            	  5707: 	RTS
                            	  5708: 
                            	  5709: 
                            	  5710: *************************************************************************************
                            	  5711: *
                            	  5712: * get FAC1 sign
                            	  5713: * return d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5714: 
                            	  5715: LAB_27CA
01:0000DC08 7000            	  5716: 	MOVEQ		#0,d0				* clear d0
01:0000DC0A 102B0594        	  5717: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:0000DC0E 67F6            	  5718: 	BEQ.s		RTS_017			* exit if zero (already correct SGN(0)=0)
                            	  5719: 
                            	  5720: 
                            	  5721: *************************************************************************************
                            	  5722: *
                            	  5723: * return d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5724: * no = 0 check
                            	  5725: 
                            	  5726: LAB_27CE
01:0000DC10 102B0595        	  5727: 	MOVE.b	FAC1_s(a3),d0		* else get FAC1 sign (b7)
                            	  5728: 
                            	  5729: 
                            	  5730: *************************************************************************************
                            	  5731: *
                            	  5732: * return d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5733: * no = 0 check, sign in d0
                            	  5734: 
                            	  5735: LAB_27D0
01:0000DC14 4880            	  5736: 	EXT.w		d0				* make word
01:0000DC16 48C0            	  5737: 	EXT.l		d0				* make longword
01:0000DC18 E080            	  5738: 	ASR.l		#8,d0				* move sign bit through byte to carry
01:0000DC1A 65EA            	  5739: 	BCS.s		RTS_017			* exit if carry set
                            	  5740: 
01:0000DC1C 7001            	  5741: 	MOVEQ		#1,d0				* set result for +ve sign
01:0000DC1E 4E75            	  5742: 	RTS
                            	  5743: 
                            	  5744: 
                            	  5745: *************************************************************************************
                            	  5746: *
                            	  5747: * perform SGN()
                            	  5748: 
                            	  5749: LAB_SGN
01:0000DC20 61E6            	  5750: 	BSR.s		LAB_27CA			* get FAC1 sign
                            	  5751: 							* return d0=-1/-ve d0=+1/+ve
                            	  5752: 
                            	  5753: 
                            	  5754: *************************************************************************************
                            	  5755: *
                            	  5756: * save d0 as integer longword
                            	  5757: 
                            	  5758: LAB_27DB
01:0000DC22 27400590        	  5759: 	MOVE.l	d0,FAC1_m(a3)		* save FAC1 mantissa
01:0000DC26 377CA0000594    	  5760: 	MOVE.w	#$A000,FAC1_e(a3)		* set FAC1 exponent & sign
01:0000DC2C D080            	  5761: 	ADD.l		d0,d0				* top bit into carry
01:0000DC2E 6000FCD2        	  5762: 	BRA		LAB_24D0			* do +/- (carry is sign) & normalise FAC1
                            	  5763: 
                            	  5764: 
                            	  5765: *************************************************************************************
                            	  5766: *
                            	  5767: * perform ABS()
                            	  5768: 
                            	  5769: LAB_ABS
01:0000DC32 177C00000595    	  5770: 	MOVE.b	#0,FAC1_s(a3)		* clear FAC1 sign
01:0000DC38 4E75            	  5771: 	RTS
                            	  5772: 
                            	  5773: 
                            	  5774: *************************************************************************************
                            	  5775: *
                            	  5776: * compare FAC1 with FAC2
                            	  5777: * returns d0=+1 Cb=0 if FAC1 > FAC2
                            	  5778: * returns d0= 0 Cb=0 if FAC1 = FAC2
                            	  5779: * returns d0=-1 Cb=1 if FAC1 < FAC2
                            	  5780: 
                            	  5781: LAB_27FA
01:0000DC3A 122B059C        	  5782: 	MOVE.b	FAC2_e(a3),d1		* get FAC2 exponent
01:0000DC3E 67C8            	  5783: 	BEQ.s		LAB_27CA			* branch if FAC2 exponent=0 & get FAC1 sign
                            	  5784: 							* d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5785: 
01:0000DC40 102B059E        	  5786: 	MOVE.b	FAC_sc(a3),d0		* get FAC sign compare
01:0000DC44 6BCA            	  5787: 	BMI.s		LAB_27CE			* if signs <> do return d0=-1,C=1/-ve
                            	  5788: 							* d0=+1,C=0/+ve & return
                            	  5789: 
01:0000DC46 102B0595        	  5790: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:0000DC4A B22B0594        	  5791: 	CMP.b		FAC1_e(a3),d1		* compare FAC1 exponent with FAC2 exponent
01:0000DC4E 660A            	  5792: 	BNE.s		LAB_2828			* branch if different
                            	  5793: 
01:0000DC50 222B0598        	  5794: 	MOVE.l	FAC2_m(a3),d1		* get FAC2 mantissa
01:0000DC54 B2AB0590        	  5795: 	CMP.l		FAC1_m(a3),d1		* compare mantissas
01:0000DC58 6708            	  5796: 	BEQ.s		LAB_282F			* exit if mantissas equal
                            	  5797: 
                            	  5798: * gets here if number <> FAC1
                            	  5799: 
                            	  5800: LAB_2828
01:0000DC5A 65B8            	  5801: 	BCS.s		LAB_27D0			* if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
                            	  5802: 							* C=0/+ve
                            	  5803: 
01:0000DC5C 0A000080        	  5804: 	EORI.b	#$80,d0			* else toggle FAC1 sign
                            	  5805: LAB_282E
01:0000DC60 60B2            	  5806: 	BRA.s		LAB_27D0			* return d0=-1,C=1/-ve d0=+1,C=0/+ve
                            	  5807: 
                            	  5808: LAB_282F
01:0000DC62 7000            	  5809: 	MOVEQ		#0,d0				* clear result
01:0000DC64 4E75            	  5810: 	RTS
                            	  5811: 
                            	  5812: 
                            	  5813: *************************************************************************************
                            	  5814: *
                            	  5815: * convert FAC1 floating to fixed
                            	  5816: * result in d0 and Itemp, sets flags correctly
                            	  5817: 
                            	  5818: LAB_2831
01:0000DC66 202B0590        	  5819: 	MOVE.l	FAC1_m(a3),d0		* copy mantissa
01:0000DC6A 6730            	  5820: 	BEQ.s		LAB_284J			* branch if mantissa = 0
                            	  5821: 
01:0000DC6C 2F01            	  5822: 	MOVE.l	d1,-(sp)			* save d1
01:0000DC6E 72A0            	  5823: 	MOVEQ		#$A0,d1			* set for no floating bits
01:0000DC70 922B0594        	  5824: 	SUB.b		FAC1_e(a3),d1		* subtract FAC1 exponent
01:0000DC74 6500E4FA        	  5825: 	BCS		LAB_OFER			* do overflow if too big
                            	  5826: 
01:0000DC78 660E            	  5827: 	BNE.s		LAB_284G			* branch if exponent was not $A0
                            	  5828: 
01:0000DC7A 4A2B0595        	  5829: 	TST.b		FAC1_s(a3)			* test FAC1 sign
01:0000DC7E 6A1A            	  5830: 	BPL.s		LAB_284H			* branch if FAC1 +ve
                            	  5831: 
01:0000DC80 4480            	  5832: 	NEG.l		d0
01:0000DC82 6916            	  5833: 	BVS.s		LAB_284H			* branch if was $80000000
                            	  5834: 
01:0000DC84 6000E4EA        	  5835: 	BRA		LAB_OFER			* do overflow if too big
                            	  5836: 
                            	  5837: LAB_284G
01:0000DC88 B23C0020        	  5838: 	CMP.b		#$20,d1			* compare with minimum result for integer
01:0000DC8C 6502            	  5839: 	BCS.s		LAB_284L			* if < minimum just do shift
                            	  5840: 
01:0000DC8E 7000            	  5841: 	MOVEQ		#0,d0				* else return zero
                            	  5842: LAB_284L
01:0000DC90 E2A8            	  5843: 	LSR.l		d1,d0				* shift integer
                            	  5844: 
01:0000DC92 4A2B0595        	  5845: 	TST.b		FAC1_s(a3)			* test FAC1 sign (b7)
01:0000DC96 6A02            	  5846: 	BPL.s		LAB_284H			* branch if FAC1 +ve
                            	  5847: 
01:0000DC98 4480            	  5848: 	NEG.l		d0				* negate integer value
                            	  5849: LAB_284H
01:0000DC9A 221F            	  5850: 	MOVE.l	(sp)+,d1			* restore d1
                            	  5851: LAB_284J
01:0000DC9C 2740042A        	  5852: 	MOVE.l	d0,Itemp(a3)		* save result to Itemp
01:0000DCA0 4E75            	  5853: 	RTS
                            	  5854: 
                            	  5855: 
                            	  5856: *************************************************************************************
                            	  5857: *
                            	  5858: * perform INT()
                            	  5859: 
                            	  5860: LAB_INT
01:0000DCA2 70A0            	  5861: 	MOVEQ		#$A0,d0			* set for no floating bits
01:0000DCA4 902B0594        	  5862: 	SUB.b		FAC1_e(a3),d0		* subtract FAC1 exponent
01:0000DCA8 6310            	  5863: 	BLS.s		LAB_IRTS			* exit if exponent >= $A0
                            	  5864: 							* (too big for fraction part!)
                            	  5865: 
01:0000DCAA B03C0020        	  5866: 	CMP.b		#$20,d0			* compare with minimum result for integer
01:0000DCAE 6400025E        	  5867: 	BCC		LAB_POZE			* if >= minimum go return 0
                            	  5868: 							* (too small for integer part!)
                            	  5869: 
01:0000DCB2 72FF            	  5870: 	MOVEQ		#-1,d1			* set integer mask
01:0000DCB4 E1A1            	  5871: 	ASL.l		d0,d1				* shift mask [8+2*d0]
01:0000DCB6 C3AB0590        	  5872: 	AND.l		d1,FAC1_m(a3)		* mask mantissa
                            	  5873: LAB_IRTS
01:0000DCBA 4E75            	  5874: 	RTS
                            	  5875: 
                            	  5876: 
                            	  5877: *************************************************************************************
                            	  5878: *
                            	  5879: * print " in line [LINE #]"
                            	  5880: 
                            	  5881: LAB_2953
01:0000DCBC 41FA17F0        	  5882: 	LEA		LAB_LMSG(pc),a0		* point to " in line " message
01:0000DCC0 6100ED30        	  5883: 	BSR		LAB_18C3			* print null terminated string
                            	  5884: 
                            	  5885: 							* Print Basic line #
01:0000DCC4 202B0452        	  5886: 	MOVE.l	Clinel(a3),d0		* get current line
                            	  5887: 
                            	  5888: 
                            	  5889: *************************************************************************************
                            	  5890: *
                            	  5891: * print d0 as unsigned integer
                            	  5892: 
                            	  5893: LAB_295E
01:0000DCC8 43FA0DDE        	  5894: 	LEA		Bin2dec(pc),a1		* get table address
01:0000DCCC 7200            	  5895: 	MOVEQ		#0,d1				* table index
01:0000DCCE 41EB05CC        	  5896: 	LEA		Usdss(a3),a0		* output string start
01:0000DCD2 2401            	  5897: 	MOVE.l	d1,d2				* output string index
                            	  5898: LAB_2967
01:0000DCD4 26311000        	  5899: 	MOVE.l	(a1,d1.w),d3		* get table value
01:0000DCD8 6714            	  5900: 	BEQ.s		LAB_2969			* exit if end marker
                            	  5901: 
01:0000DCDA 782F            	  5902: 	MOVEQ		#'0'-1,d4			* set character to "0"-1
                            	  5903: LAB_2968
01:0000DCDC 5244            	  5904: 	ADDQ.w	#1,d4				* next numeric character
01:0000DCDE 9083            	  5905: 	SUB.l		d3,d0				* subtract table value
01:0000DCE0 6AFA            	  5906: 	BPL.s		LAB_2968			* not overdone so loop
                            	  5907: 
01:0000DCE2 D083            	  5908: 	ADD.l		d3,d0				* correct value
01:0000DCE4 11842000        	  5909: 	MOVE.b	d4,(a0,d2.w)		* character out to string
01:0000DCE8 5841            	  5910: 	ADDQ.w	#4,d1				* increment table pointer
01:0000DCEA 5242            	  5911: 	ADDQ.w	#1,d2				* increment output string pointer
01:0000DCEC 60E6            	  5912: 	BRA.s		LAB_2967			* loop
                            	  5913: 
                            	  5914: LAB_2969
01:0000DCEE D03C0030        	  5915: 	ADD.b		#'0',d0			* make last character
01:0000DCF2 11802000        	  5916: 	MOVE.b	d0,(a0,d2.w)		* character out to string
01:0000DCF6 5348            	  5917: 	SUBQ.w	#1,a0				* decrement a0 (allow simple loop)
                            	  5918: 
                            	  5919: 							* now find non zero start of string
                            	  5920: LAB_296A
01:0000DCF8 5248            	  5921: 	ADDQ.w	#1,a0				* increment a0 (this will never carry to b16)
01:0000DCFA 43EB05D5        	  5922: 	LEA		BHsend-1(a3),a1		* get string end
01:0000DCFE B1C9            	  5923: 	CMPA.l	a1,a0				* are we at end
01:0000DD00 6700ECF0        	  5924: 	BEQ		LAB_18C3			* if so print null terminated string and RETURN
                            	  5925: 
01:0000DD04 0C100030        	  5926: 	CMPI.b	#'0',(a0)			* is character "0" ?
01:0000DD08 67EE            	  5927: 	BEQ.s		LAB_296A			* loop if so
                            	  5928: 
01:0000DD0A 6000ECE6        	  5929: 	BRA		LAB_18C3			* print null terminated string from memory & RET
                            	  5930: 
                            	  5931: 
                            	  5932: *************************************************************************************
                            	  5933: *
                            	  5934: * convert FAC1 to ASCII string result in (a0)
                            	  5935: * STR$() function enters here
                            	  5936: 
                            	  5937: * now outputs 7 significant digits
                            	  5938: 
                            	  5939: * d0 is character out
                            	  5940: * d1 is save index
                            	  5941: * d2 is gash
                            	  5942: 
                            	  5943: * a0 is output string pointer
                            	  5944: 
                            	  5945: LAB_2970
01:0000DD0E 43EB05C6        	  5946: 	LEA		Decss(a3),a1		* set output string start
                            	  5947: 
01:0000DD12 7420            	  5948: 	MOVEQ		#' ',d2			* character = " ", assume +ve
01:0000DD14 08AB00070595    	  5949: 	BCLR.b	#7,FAC1_s(a3)		* test and clear FAC1 sign (b7)
01:0000DD1A 6702            	  5950: 	BEQ.s		LAB_2978			* branch if +ve
                            	  5951: 
01:0000DD1C 742D            	  5952: 	MOVEQ		#'-',d2			* else character = "-"
                            	  5953: LAB_2978
01:0000DD1E 1282            	  5954: 	MOVE.b	d2,(a1)			* save the sign character
01:0000DD20 142B0594        	  5955: 	MOVE.b	FAC1_e(a3),d2		* get FAC1 exponent
01:0000DD24 6608            	  5956: 	BNE.s		LAB_2989			* branch if FAC1<>0
                            	  5957: 
                            	  5958: 							* exponent was $00 so FAC1 is 0
01:0000DD26 7030            	  5959: 	MOVEQ		#'0',d0			* set character = "0"
01:0000DD28 7201            	  5960: 	MOVEQ		#1,d1				* set output string index
01:0000DD2A 600001A4        	  5961: 	BRA		LAB_2A89			* save last character, [EOT] & exit
                            	  5962: 
                            	  5963: 							* FAC1 is some non zero value
                            	  5964: LAB_2989
01:0000DD2E 177C000005AC    	  5965: 	MOVE.b	#0,numexp(a3)		* clear number exponent count
01:0000DD34 B43C0081        	  5966: 	CMP.b		#$81,d2			* compare FAC1 exponent with $81 (>1.00000)
                            	  5967: 
01:0000DD38 6448            	  5968: 	BCC.s		LAB_299C			* branch if FAC1=>1
                            	  5969: 
                            	  5970: 							* else FAC1 < 1
01:0000DD3A 277C989680000598	  5971: 	MOVE.l	#$98968000,FAC2_m(a3)	* 10000000 mantissa
01:0000DD42 377C9800059C    	  5972: 	MOVE.w	#$9800,FAC2_e(a3)		* 10000000 exponent & sign
01:0000DD48 176B0595059E    	  5973: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make FAC1 sign sign compare
01:0000DD4E 6100FCE4        	  5974: 	BSR		LAB_MULTIPLY		* do FAC2*FAC1
                            	  5975: 
01:0000DD52 177C00F905AC    	  5976: 	MOVE.b	#$F9,numexp(a3)		* set number exponent count (-7)
01:0000DD58 6028            	  5977: 	BRA.s		LAB_299C			* go test for fit
                            	  5978: 
                            	  5979: LAB_29B9
01:0000DD5A 376B0594059C    	  5980: 	MOVE.w	FAC1_e(a3),FAC2_e(a3)	* copy exponent & sign from FAC1 to FAC2
01:0000DD60 276B05900598    	  5981: 	MOVE.l	FAC1_m(a3),FAC2_m(a3)	* copy FAC1 mantissa to FAC2 mantissa
01:0000DD66 176B0595059E    	  5982: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* save FAC1_s as sign compare
                            	  5983: 
01:0000DD6C 277CCCCCCCCD0590	  5984: 	MOVE.l	#$CCCCCCCD,FAC1_m(a3)	* 1/10 mantissa
01:0000DD74 377C7D000594    	  5985: 	MOVE.w	#$7D00,FAC1_e(a3)		* 1/10 exponent & sign
01:0000DD7A 6100FCB8        	  5986: 	BSR		LAB_MULTIPLY		* do FAC2*FAC1, effectively divide by 10 but
                            	  5987: 							* faster
                            	  5988: 
01:0000DD7E 522B05AC        	  5989: 	ADDQ.b	#1,numexp(a3)		* increment number exponent count
                            	  5990: LAB_299C
01:0000DD82 277C98967F700598	  5991: 	MOVE.l	#$98967F70,FAC2_m(a3)	* 9999999.4375 mantissa
01:0000DD8A 377C9800059C    	  5992: 	MOVE.w	#$9800,FAC2_e(a3)		* 9999999.4375 exponent & sign
                            	  5993: 							* (max before scientific notation)
01:0000DD90 6100014C        	  5994: 	BSR		LAB_27F0			* fast compare FAC1 with FAC2
                            	  5995: 							* returns d0=+1 C=0 if FAC1 > FAC2
                            	  5996: 							* returns d0= 0 C=0 if FAC1 = FAC2
                            	  5997: 							* returns d0=-1 C=1 if FAC1 < FAC2
01:0000DD94 62C4            	  5998: 	BHI.s		LAB_29B9			* go do /10 if FAC1 > 9999999.4375
                            	  5999: 
01:0000DD96 6750            	  6000: 	BEQ.s		LAB_29C3			* branch if FAC1 = 9999999.4375
                            	  6001: 
                            	  6002: 							* FAC1 < 9999999.4375
01:0000DD98 277CF423F8000598	  6003: 	MOVE.l	#$F423F800,FAC2_m(a3)	* set mantissa for 999999.5
01:0000DDA0 377C9400059C    	  6004: 	MOVE.w	#$9400,FAC2_e(a3)		* set exponent for 999999.5
                            	  6005: 
01:0000DDA6 41EB0590        	  6006: 	LEA		FAC1_m(a3),a0		* set pointer for x10
                            	  6007: LAB_29A7
01:0000DDAA 61000132        	  6008: 	BSR		LAB_27F0			* fast compare FAC1 with FAC2
                            	  6009: 							* returns d0=+1 C=0 if FAC1 > FAC2
                            	  6010: 							* returns d0= 0 C=0 if FAC1 = FAC2
                            	  6011: 							* returns d0=-1 C=1 if FAC1 < FAC2
01:0000DDAE 6220            	  6012: 	BHI.s		LAB_29C0			* branch if FAC1 > 99999.9375,no decimal places
                            	  6013: 
                            	  6014: 							* FAC1 <= 999999.5 so do x 10
01:0000DDB0 2010            	  6015: 	MOVE.l	(a0),d0			* get FAC1 mantissa
01:0000DDB2 12280004        	  6016: 	MOVE.b	4(a0),d1			* get FAC1 exponent
01:0000DDB6 2400            	  6017: 	MOVE.l	d0,d2				* copy it
01:0000DDB8 E488            	  6018: 	LSR.l		#2,d0				* /4
01:0000DDBA D082            	  6019: 	ADD.l		d2,d0				* add FAC1 (x1.125)
01:0000DDBC 6404            	  6020: 	BCC.s		LAB_29B7			* branch if no carry
                            	  6021: 
01:0000DDBE E290            	  6022: 	ROXR.l	#1,d0				* shift carry back in
01:0000DDC0 5201            	  6023: 	ADDQ.b	#1,d1				* increment exponent (never overflows)
                            	  6024: LAB_29B7
01:0000DDC2 5601            	  6025: 	ADDQ.b	#3,d1				* correct exponent ( 8 x 1.125 = 10 )
                            	  6026: 							* (never overflows)
01:0000DDC4 2080            	  6027: 	MOVE.l	d0,(a0)			* save new mantissa
01:0000DDC6 11410004        	  6028: 	MOVE.b	d1,4(a0)			* save new exponent
01:0000DDCA 532B05AC        	  6029: 	SUBQ.b	#1,numexp(a3)		* decrement number exponent count
01:0000DDCE 60DA            	  6030: 	BRA.s		LAB_29A7			* go test again
                            	  6031: 
                            	  6032: 							* now we have just the digits to do
                            	  6033: LAB_29C0
01:0000DDD0 277C800000000598	  6034: 	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 0.5
01:0000DDD8 377C8000059C    	  6035: 	MOVE.w	#$8000,FAC2_e(a3)		* set exponent for 0.5
01:0000DDDE 176B0595059E    	  6036: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign compare = sign
01:0000DDE4 6100FAAC        	  6037: 	BSR		LAB_ADD			* add the 0.5 to FAC1 (round FAC1)
                            	  6038: 
                            	  6039: LAB_29C3
01:0000DDE8 6100FE7C        	  6040: 	BSR		LAB_2831			* convert FAC1 floating to fixed
                            	  6041: 							* result in d0 and Itemp
01:0000DDEC 7401            	  6042: 	MOVEQ		#$01,d2			* set default digits before dp = 1
01:0000DDEE 102B05AC        	  6043: 	MOVE.b	numexp(a3),d0		* get number exponent count
01:0000DDF2 5000            	  6044: 	ADD.b		#8,d0				* allow 7 digits before point
01:0000DDF4 6B0C            	  6045: 	BMI.s		LAB_29D9			* if -ve then 1 digit before dp
                            	  6046: 
01:0000DDF6 B03C0009        	  6047: 	CMP.b		#$09,d0			* d0>=9 if n>=1E7
01:0000DDFA 6406            	  6048: 	BCC.s		LAB_29D9			* branch if >= $09
                            	  6049: 
                            	  6050: 							* < $08
01:0000DDFC 5300            	  6051: 	SUBQ.b	#1,d0				* take 1 from digit count
01:0000DDFE 1400            	  6052: 	MOVE.b	d0,d2				* copy byte
01:0000DE00 7002            	  6053: 	MOVEQ		#$02,d0			* set exponent adjust
                            	  6054: LAB_29D9
01:0000DE02 7200            	  6055: 	MOVEQ		#0,d1				* set output string index
01:0000DE04 5500            	  6056: 	SUBQ.b	#2,d0				* -2
01:0000DE06 174005AD        	  6057: 	MOVE.b	d0,expcnt(a3)		* save exponent adjust
01:0000DE0A 174205AC        	  6058: 	MOVE.b	d2,numexp(a3)		* save digits before dp count
01:0000DE0E 1002            	  6059: 	MOVE.b	d2,d0				* copy digits before dp count
01:0000DE10 6702            	  6060: 	BEQ.s		LAB_29E4			* branch if no digits before dp
                            	  6061: 
01:0000DE12 6A14            	  6062: 	BPL.s		LAB_29F7			* branch if digits before dp
                            	  6063: 
                            	  6064: LAB_29E4
01:0000DE14 5281            	  6065: 	ADDQ.l	#1,d1				* increment index
01:0000DE16 13BC002E1000    	  6066: 	MOVE.b	#'.',(a1,d1.w)		* save to output string
                            	  6067: 
01:0000DE1C 4A02            	  6068: 	TST.b		d2				* test digits before dp count
01:0000DE1E 6708            	  6069: 	BEQ.s		LAB_29F7			* branch if no digits before dp
                            	  6070: 
01:0000DE20 5281            	  6071: 	ADDQ.l	#1,d1				* increment index
01:0000DE22 13BC00301000    	  6072: 	MOVE.b	#'0',(a1,d1.w)		* save to output string
                            	  6073: LAB_29F7
01:0000DE28 7400            	  6074: 	MOVEQ		#0,d2				* clear index (point to 1,000,000)
01:0000DE2A 7080            	  6075: 	MOVEQ		#$80-$100,d0		* set output character
                            	  6076: LAB_29FB
01:0000DE2C 41FA1114        	  6077: 	LEA		LAB_2A9A(pc),a0		* get base of table
01:0000DE30 26302000        	  6078: 	MOVE.l	(a0,d2.w),d3		* get table value
                            	  6079: LAB_29FD
01:0000DE34 5200            	  6080: 	ADDQ.b	#1,d0				* increment output character
01:0000DE36 D7AB042A        	  6081: 	ADD.l		d3,Itemp(a3)		* add to (now fixed) mantissa
01:0000DE3A 08000007        	  6082: 	BTST		#7,d0				* set test sense (z flag only)
01:0000DE3E 6504            	  6083: 	BCS.s		LAB_2A18			* did carry so has wrapped past zero
                            	  6084: 
01:0000DE40 67F2            	  6085: 	BEQ.s		LAB_29FD			* no wrap and +ve test so try again
                            	  6086: 
01:0000DE42 6002            	  6087: 	BRA.s		LAB_2A1A			* found this digit
                            	  6088: 
                            	  6089: LAB_2A18
01:0000DE44 66EE            	  6090: 	BNE.s		LAB_29FD			* wrap and -ve test so try again
                            	  6091: 
                            	  6092: LAB_2A1A
01:0000DE46 6406            	  6093: 	BCC.s		LAB_2A21			* branch if +ve test result
                            	  6094: 
01:0000DE48 4400            	  6095: 	NEG.b		d0				* negate the digit number
01:0000DE4A D03C000B        	  6096: 	ADD.b		#$0B,d0			* and subtract from 11 decimal
                            	  6097: LAB_2A21
01:0000DE4E D03C002F        	  6098: 	ADD.b		#$2F,d0			* add "0"-1 to result
01:0000DE52 5842            	  6099: 	ADDQ.w	#4,d2				* increment index to next less power of ten
01:0000DE54 5241            	  6100: 	ADDQ.w	#1,d1				* increment output string index
01:0000DE56 1600            	  6101: 	MOVE.b	d0,d3				* copy character to d3
01:0000DE58 C63C007F        	  6102: 	AND.b		#$7F,d3			* mask out top bit
01:0000DE5C 13831000        	  6103: 	MOVE.b	d3,(a1,d1.w)		* save to output string
01:0000DE60 532B05AC        	  6104: 	SUB.b		#1,numexp(a3)		* decrement # of characters before the dp
01:0000DE64 6608            	  6105: 	BNE.s		LAB_2A3B			* branch if still characters to do
                            	  6106: 
                            	  6107: 							* else output the point
01:0000DE66 5281            	  6108: 	ADDQ.l	#1,d1				* increment index
01:0000DE68 13BC002E1000    	  6109: 	MOVE.b	#'.',(a1,d1.w)		* save to output string
                            	  6110: LAB_2A3B
01:0000DE6E C03C0080        	  6111: 	AND.b		#$80,d0			* mask test sense bit
01:0000DE72 0A000080        	  6112: 	EORI.b	#$80,d0			* invert it
01:0000DE76 B43C001C        	  6113: 	CMP.b		#LAB_2A9B-LAB_2A9A,d2	* compare table index with max+4
01:0000DE7A 66B0            	  6114: 	BNE.s		LAB_29FB			* loop if not max
                            	  6115: 
                            	  6116: 							* now remove trailing zeroes
                            	  6117: LAB_2A4B
01:0000DE7C 10311000        	  6118: 	MOVE.b	(a1,d1.w),d0		* get character from output string
01:0000DE80 5381            	  6119: 	SUBQ.l	#1,d1				* decrement output string index
01:0000DE82 B03C0030        	  6120: 	CMP.b		#'0',d0			* compare with "0"
01:0000DE86 67F4            	  6121: 	BEQ.s		LAB_2A4B			* loop until non "0" character found
                            	  6122: 
01:0000DE88 B03C002E        	  6123: 	CMP.b		#'.',d0			* compare with "."
01:0000DE8C 6702            	  6124: 	BEQ.s		LAB_2A58			* branch if was dp
                            	  6125: 
                            	  6126: 							* else restore last character
01:0000DE8E 5281            	  6127: 	ADDQ.l	#1,d1				* increment output string index
                            	  6128: LAB_2A58
01:0000DE90 13BC002B1002    	  6129: 	MOVE.b	#'+',2(a1,d1.w)		* save character "+" to output string
01:0000DE96 4A2B05AD        	  6130: 	TST.b		expcnt(a3)			* test exponent count
01:0000DE9A 6738            	  6131: 	BEQ.s		LAB_2A8C			* if zero go set null terminator & exit
                            	  6132: 
                            	  6133: 							* exponent isn't zero so write exponent
01:0000DE9C 6A0A            	  6134: 	BPL.s		LAB_2A68			* branch if exponent count +ve
                            	  6135: 
01:0000DE9E 13BC002D1002    	  6136: 	MOVE.b	#'-',2(a1,d1.w)		* save character "-" to output string
01:0000DEA4 442B05AD        	  6137: 	NEG.b		expcnt(a3)			* convert -ve to +ve
                            	  6138: LAB_2A68
01:0000DEA8 13BC00451001    	  6139: 	MOVE.b	#'E',1(a1,d1.w)		* save character "E" to output string
01:0000DEAE 142B05AD        	  6140: 	MOVE.b	expcnt(a3),d2		* get exponent count
01:0000DEB2 702F            	  6141: 	MOVEQ		#$2F,d0			* one less than "0" character
                            	  6142: LAB_2A74
01:0000DEB4 5200            	  6143: 	ADDQ.b	#1,d0				* increment 10's character
01:0000DEB6 943C000A        	  6144: 	SUB.b		#$0A,d2			* subtract 10 from exponent count
01:0000DEBA 64F8            	  6145: 	BCC.s		LAB_2A74			* loop while still >= 0
                            	  6146: 
01:0000DEBC D43C003A        	  6147: 	ADD.b		#$3A,d2			* add character ":", $30+$0A, result is 10-value
01:0000DEC0 13801003        	  6148: 	MOVE.b	d0,3(a1,d1.w)		* save 10's character to output string
01:0000DEC4 13821004        	  6149: 	MOVE.b	d2,4(a1,d1.w)		* save 1's character to output string
01:0000DEC8 13BC00001005    	  6150: 	MOVE.b	#0,5(a1,d1.w)		* save null terminator after last character
01:0000DECE 600A            	  6151: 	BRA.s		LAB_2A91			* go set string pointer (a0) and exit
                            	  6152: 
                            	  6153: LAB_2A89
01:0000DED0 13801000        	  6154: 	MOVE.b	d0,(a1,d1.w)		* save last character to output string
                            	  6155: LAB_2A8C
01:0000DED4 13BC00001001    	  6156: 	MOVE.b	#0,1(a1,d1.w)		* save null terminator after last character
                            	  6157: LAB_2A91
01:0000DEDA 2049            	  6158: 	MOVEA.l	a1,a0				* set result string pointer (a0)
01:0000DEDC 4E75            	  6159: 	RTS
                            	  6160: 
                            	  6161: 
                            	  6162: *************************************************************************************
                            	  6163: *
                            	  6164: * fast compare FAC1 with FAC2
                            	  6165: * assumes both are +ve and FAC2>0
                            	  6166: * returns d0=+1 C=0 if FAC1 > FAC2
                            	  6167: * returns d0= 0 C=0 if FAC1 = FAC2
                            	  6168: * returns d0=-1 C=1 if FAC1 < FAC2
                            	  6169: 
                            	  6170: LAB_27F0
01:0000DEDE 7000            	  6171: 	MOVEQ		#0,d0				* set for FAC1 = FAC2
01:0000DEE0 122B059C        	  6172: 	MOVE.b	FAC2_e(a3),d1		* get FAC2 exponent
01:0000DEE4 B22B0594        	  6173: 	CMP.b		FAC1_e(a3),d1		* compare FAC1 exponent with FAC2 exponent
01:0000DEE8 660A            	  6174: 	BNE.s		LAB_27F1			* branch if different
                            	  6175: 
01:0000DEEA 222B0598        	  6176: 	MOVE.l	FAC2_m(a3),d1		* get FAC2 mantissa
01:0000DEEE B2AB0590        	  6177: 	CMP.l		FAC1_m(a3),d1		* compare mantissas
01:0000DEF2 6708            	  6178: 	BEQ.s		LAB_27F3			* exit if mantissas equal
                            	  6179: 
                            	  6180: LAB_27F1
01:0000DEF4 6504            	  6181: 	BCS.s		LAB_27F2			* if FAC1 > FAC2 return d0=+1,C=0
                            	  6182: 
01:0000DEF6 5380            	  6183: 	SUBQ.l	#1,d0				* else FAC1 < FAC2 return d0=-1,C=1
01:0000DEF8 4E75            	  6184: 	RTS
                            	  6185: 
                            	  6186: LAB_27F2
01:0000DEFA 5280            	  6187: 	ADDQ.l	#1,d0
                            	  6188: LAB_27F3
01:0000DEFC 4E75            	  6189: 	RTS
                            	  6190: 
                            	  6191: 
                            	  6192: *************************************************************************************
                            	  6193: *
                            	  6194: * make FAC1 = 1
                            	  6195: 
                            	  6196: LAB_POON
01:0000DEFE 277C800000000590	  6197: 	MOVE.l	#$80000000,FAC1_m(a3)	* 1 mantissa
01:0000DF06 377C81000594    	  6198: 	MOVE.w	#$8100,FAC1_e(a3)		* 1 exonent & sign
01:0000DF0C 4E75            	  6199: 	RTS
                            	  6200: 
                            	  6201: 
                            	  6202: *************************************************************************************
                            	  6203: *
                            	  6204: * make FAC1 = 0
                            	  6205: 
                            	  6206: LAB_POZE
01:0000DF0E 7000            	  6207: 	MOVEQ		#0,d0				* clear longword
01:0000DF10 27400590        	  6208: 	MOVE.l	d0,FAC1_m(a3)		* 0 mantissa
01:0000DF14 37400594        	  6209: 	MOVE.w	d0,FAC1_e(a3)		* 0 exonent & sign
01:0000DF18 4E75            	  6210: 	RTS
                            	  6211: 
                            	  6212: 
                            	  6213: *************************************************************************************
                            	  6214: *
                            	  6215: * perform power function
                            	  6216: * the number is in FAC2, the power is in FAC1
                            	  6217: * no longer trashes Itemp
                            	  6218: 
                            	  6219: LAB_POWER
01:0000DF1A 4A2B0594        	  6220: 	TST.b		FAC1_e(a3)			* test power
01:0000DF1E 67DE            	  6221: 	BEQ.s		LAB_POON			* if zero go return 1
                            	  6222: 
01:0000DF20 4A2B059C        	  6223: 	TST.b		FAC2_e(a3)			* test number
01:0000DF24 67E8            	  6224: 	BEQ.s		LAB_POZE			* if zero go return 0
                            	  6225: 
01:0000DF26 1F2B059D        	  6226: 	MOVE.b	FAC2_s(a3),-(sp)		* save number sign
01:0000DF2A 6A20            	  6227: 	BPL.s		LAB_POWP			* power of positive number
                            	  6228: 
01:0000DF2C 7200            	  6229: 	MOVEQ		#0,d1				* clear d1
01:0000DF2E 1741059D        	  6230: 	MOVE.b	d1,FAC2_s(a3)		* make sign +ve
                            	  6231: 
                            	  6232: 							* number sign was -ve and can only be raised to
                            	  6233: 							* an integer power which gives an x +j0 result,
                            	  6234: 							* else do 'function call' error
01:0000DF32 122B0594        	  6235: 	MOVE.b	FAC1_e(a3),d1		* get power exponent
01:0000DF36 927C0080        	  6236: 	SUB.w		#$80,d1			* normalise to .5
01:0000DF3A 6300E238        	  6237: 	BLS		LAB_FCER			* if 0<power<1 then do 'function call' error
                            	  6238: 
                            	  6239: 							* now shift all the integer bits out
01:0000DF3E 202B0590        	  6240: 	MOVE.l	FAC1_m(a3),d0		* get power mantissa
01:0000DF42 E3A0            	  6241: 	ASL.l		d1,d0				* shift mantissa
01:0000DF44 6600E22E        	  6242: 	BNE		LAB_FCER			* if power<>INT(power) then do 'function call'
                            	  6243: 							* error
                            	  6244: 
01:0000DF48 6502            	  6245: 	BCS.s		LAB_POWP			* if integer value odd then leave result -ve
                            	  6246: 
01:0000DF4A 1E80            	  6247: 	MOVE.b	d0,(sp)			* save result sign +ve
                            	  6248: LAB_POWP
01:0000DF4C 2F2B0590        	  6249: 	MOVE.l	FAC1_m(a3),-(sp)		* save power mantissa
01:0000DF50 3F2B0594        	  6250: 	MOVE.w	FAC1_e(a3),-(sp)		* save power sign & exponent
                            	  6251: 
01:0000DF54 6100FC78        	  6252: 	BSR		LAB_279B			* copy number to FAC1
01:0000DF58 6100F9E8        	  6253: 	BSR		LAB_LOG			* find log of number
                            	  6254: 
01:0000DF5C 301F            	  6255: 	MOVE.w	(sp)+,d0			* get power sign & exponent
01:0000DF5E 275F0598        	  6256: 	MOVE.l	(sp)+,FAC2_m(a3)		* get power mantissa
01:0000DF62 3740059C        	  6257: 	MOVE.w	d0,FAC2_e(a3)		* save sign & exponent to FAC2
01:0000DF66 1740059E        	  6258: 	MOVE.b	d0,FAC_sc(a3)		* save sign as sign compare
01:0000DF6A 102B0595        	  6259: 	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
01:0000DF6E B12B059E        	  6260: 	EOR.b		d0,FAC_sc(a3)		* make sign compare (FAC1_s EOR FAC2_s)
                            	  6261: 
01:0000DF72 6100FAC0        	  6262: 	BSR		LAB_MULTIPLY		* multiply by power
01:0000DF76 6158            	  6263: 	BSR.s		LAB_EXP			* find exponential
01:0000DF78 175F0595        	  6264: 	MOVE.b	(sp)+,FAC1_s(a3)		* restore number sign
01:0000DF7C 4E75            	  6265: 	RTS
                            	  6266: 
                            	  6267: 
                            	  6268: *************************************************************************************
                            	  6269: *
                            	  6270: * do - FAC1
                            	  6271: 
                            	  6272: LAB_GTHAN
01:0000DF7E 4A2B0594        	  6273: 	TST.b		FAC1_e(a3)			* test for non zero FAC1
01:0000DF82 6706            	  6274: 	BEQ.s		RTS_020			* branch if null
                            	  6275: 
01:0000DF84 0A2B00800595    	  6276: 	EORI.b	#$80,FAC1_s(a3)		* (else) toggle FAC1 sign bit
                            	  6277: RTS_020
01:0000DF8A 4E75            	  6278: 	RTS
                            	  6279: 
                            	  6280: 
                            	  6281: *************************************************************************************
                            	  6282: *
                            	  6283: 							* return +1
                            	  6284: LAB_EX1
01:0000DF8C 277C800000000590	  6285: 	MOVE.l	#$80000000,FAC1_m(a3)	* +1 mantissa
01:0000DF94 377C81000594    	  6286: 	MOVE.w	#$8100,FAC1_e(a3)		* +1 sign & exponent
01:0000DF9A 4E75            	  6287: 	RTS
                            	  6288: 							* do over/under flow
                            	  6289: LAB_EXOU
01:0000DF9C 4A2B0595        	  6290: 	TST.b		FAC1_s(a3)			* test sign
01:0000DFA0 6A00E1CE        	  6291: 	BPL		LAB_OFER			* was +ve so do overflow error
                            	  6292: 
                            	  6293: 							* else underflow so return zero
01:0000DFA4 7000            	  6294: 	MOVEQ		#0,d0				* clear longword
01:0000DFA6 27400590        	  6295: 	MOVE.l	d0,FAC1_m(a3)		* 0 mantissa
01:0000DFAA 37400594        	  6296: 	MOVE.w	d0,FAC1_e(a3)		* 0 sign & exponent
01:0000DFAE 4E75            	  6297: 	RTS
                            	  6298: 							* fraction was zero so do 2^n
                            	  6299: LAB_EXOF
01:0000DFB0 277C800000000590	  6300: 	MOVE.l	#$80000000,FAC1_m(a3)	* +n mantissa
01:0000DFB8 177C00000595    	  6301: 	MOVE.b	#0,FAC1_s(a3)		* clear sign
01:0000DFBE 4A2B05B4        	  6302: 	TST.b		cosout(a3)			* test sign flag
01:0000DFC2 6A02            	  6303: 	BPL.s		LAB_EXOL			* branch if +ve
                            	  6304: 
01:0000DFC4 4481            	  6305: 	NEG.l		d1				* else do 1/2^n
                            	  6306: LAB_EXOL
01:0000DFC6 D23C0081        	  6307: 	ADD.b		#$81,d1			* adjust exponent
01:0000DFCA 17410594        	  6308: 	MOVE.b	d1,FAC1_e(a3)		* save exponent
01:0000DFCE 4E75            	  6309: 	RTS
                            	  6310: 
                            	  6311: * perform EXP()	(x^e)
                            	  6312: * valid input range is -88 to +88
                            	  6313: 
                            	  6314: LAB_EXP
01:0000DFD0 102B0594        	  6315: 	MOVE.b	FAC1_e(a3),d0		* get exponent
01:0000DFD4 67B6            	  6316: 	BEQ.s		LAB_EX1			* return 1 for zero in
                            	  6317: 
01:0000DFD6 B03C0064        	  6318: 	CMP.b		#$64,d0			* compare exponent with min
01:0000DFDA 65B0            	  6319: 	BCS.s		LAB_EX1			* if smaller just return 1
                            	  6320: 
                            	  6321: **	MOVEM.l	d1-d6/a0,-(sp)		* save the registers
01:0000DFDC 177C000005B4    	  6322: 	MOVE.b	#0,cosout(a3)		* flag +ve number
01:0000DFE2 222B0590        	  6323: 	MOVE.l	FAC1_m(a3),d1		* get mantissa
01:0000DFE6 B03C0087        	  6324: 	CMP.b		#$87,d0			* compare exponent with max
01:0000DFEA 62B0            	  6325: 	BHI.s		LAB_EXOU			* go do over/under flow if greater
                            	  6326: 
01:0000DFEC 6608            	  6327: 	BNE.s		LAB_EXCM			* branch if less
                            	  6328: 
                            	  6329: 							* else is 2^7
01:0000DFEE B2BCB00F33C7    	  6330: 	CMP.l		#$B00F33C7,d1		* compare mantissa with n*2^7 max
01:0000DFF4 64A6            	  6331: 	BCC.s		LAB_EXOU			* if => go over/underflow
                            	  6332: 
                            	  6333: LAB_EXCM
01:0000DFF6 4A2B0595        	  6334: 	TST.b		FAC1_s(a3)			* test sign
01:0000DFFA 6A0C            	  6335: 	BPL.s		LAB_EXPS			* branch if arg +ve
                            	  6336: 
01:0000DFFC 177C00FF05B4    	  6337: 	MOVE.b	#$FF,cosout(a3)		* flag -ve number
01:0000E002 177C00000595    	  6338: 	MOVE.b	#0,FAC1_s(a3)		* take absolute value
                            	  6339: LAB_EXPS
                            	  6340: 							* now do n/LOG(2)
01:0000E008 277CB8AA3B290598	  6341: 	MOVE.l	#$B8AA3B29,FAC2_m(a3)	* 1/LOG(2) mantissa
01:0000E010 377C8100059C    	  6342: 	MOVE.w	#$8100,FAC2_e(a3)		* 1/LOG(2) exponent & sign
01:0000E016 177C0000059E    	  6343: 	MOVE.b	#0,FAC_sc(a3)		* we know they're both +ve
01:0000E01C 6100FA16        	  6344: 	BSR		LAB_MULTIPLY		* effectively divide by log(2)
                            	  6345: 
                            	  6346: 							* max here is +/- 127
                            	  6347: 							* now separate integer and fraction
01:0000E020 177C000005D9    	  6348: 	MOVE.b	#0,tpower(a3)		* clear exponent add byte
01:0000E026 1A2B0594        	  6349: 	MOVE.b	FAC1_e(a3),d5		* get exponent
01:0000E02A 9A3C0080        	  6350: 	SUB.b		#$80,d5			* normalise
01:0000E02E 6324            	  6351: 	BLS.s		LAB_ESML			* branch if < 1 (d5 is 0 or -ve)
                            	  6352: 
                            	  6353: 							* result is > 1
01:0000E030 202B0590        	  6354: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:0000E034 2200            	  6355: 	MOVE.l	d0,d1				* copy it
01:0000E036 2C05            	  6356: 	MOVE.l	d5,d6				* copy normalised exponent
                            	  6357: 
01:0000E038 4446            	  6358: 	NEG.w		d6				* make -ve
01:0000E03A DC7C0020        	  6359: 	ADD.w		#32,d6			* is now 32-d6
01:0000E03E ECA9            	  6360: 	LSR.l		d6,d1				* just integer bits
01:0000E040 174105D9        	  6361: 	MOVE.b	d1,tpower(a3)		* set exponent add byte
                            	  6362: 
01:0000E044 EBA8            	  6363: 	LSL.l		d5,d0				* shift out integer bits
01:0000E046 6700FF68        	  6364: 	BEQ		LAB_EXOF			* fraction is zero so do 2^n
                            	  6365: 
01:0000E04A 27400590        	  6366: 	MOVE.l	d0,FAC1_m(a3)		* fraction to FAC1
01:0000E04E 377C80000594    	  6367: 	MOVE.w	#$8000,FAC1_e(a3)		* set exponent & sign
                            	  6368: 
                            	  6369: 							* multiple was < 1
                            	  6370: LAB_ESML
01:0000E054 277CB17217F80598	  6371: 	MOVE.l	#$B17217F8,FAC2_m(a3)	* LOG(2) mantissa
01:0000E05C 377C8000059C    	  6372: 	MOVE.w	#$8000,FAC2_e(a3)		* LOG(2) exponent & sign
01:0000E062 177C0000059E    	  6373: 	MOVE.b	#0,FAC_sc(a3)		* clear sign compare
01:0000E068 6100F9CA        	  6374: 	BSR		LAB_MULTIPLY		* multiply by log(2)
                            	  6375: 
01:0000E06C 202B0590        	  6376: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:0000E070 1A2B0594        	  6377: 	MOVE.b	FAC1_e(a3),d5		* get exponent
01:0000E074 9A7C0082        	  6378: 	SUB.w		#$82,d5			* normalise and -2 (result is -1 to -30)
01:0000E078 4445            	  6379: 	NEG.w		d5				* make +ve
01:0000E07A EAA8            	  6380: 	LSR.l		d5,d0				* shift for 2 integer bits
                            	  6381: 
                            	  6382: * d0 = arg
                            	  6383: * d6 = x, d1 = y
                            	  6384: * d2 = x1, d3 = y1
                            	  6385: * d4 = shift count
                            	  6386: * d5 = loop count
                            	  6387: 							* now do cordic set-up
01:0000E07C 7200            	  6388: 	MOVEQ		#0,d1				* y = 0
01:0000E07E 2C3C26A3D110    	  6389: 	MOVE.l	#KFCTSEED,d6		* x = 1 with jkh inverse factored out
01:0000E084 41FA0D20        	  6390: 	LEA		TAB_HTHET(pc),a0		* get pointer to hyperbolic arctan table
01:0000E088 7800            	  6391: 	MOVEQ		#0,d4				* clear shift count
                            	  6392:  
                            	  6393: 							* cordic loop, shifts 4 and 13 (and 39
                            	  6394: 							* if it went that far) need to be repeated
01:0000E08A 7A03            	  6395: 	MOVEQ		#3,d5				* 4 loops
01:0000E08C 6136            	  6396: 	BSR.s		LAB_EXCC			* do loops 1 through 4
01:0000E08E 5948            	  6397: 	SUBQ.w	#4,a0				* do table entry again
01:0000E090 5384            	  6398: 	SUBQ.l	#1,d4				* do shift count again
01:0000E092 7A09            	  6399: 	MOVEQ		#9,d5				* 10 loops
01:0000E094 612E            	  6400: 	BSR.s		LAB_EXCC			* do loops 4 (again) through 13
01:0000E096 5948            	  6401: 	SUBQ.w	#4,a0				* do table entry again
01:0000E098 5384            	  6402: 	SUBQ.l	#1,d4				* do shift count again
01:0000E09A 7A12            	  6403: 	MOVEQ		#18,d5			* 19 loops
01:0000E09C 6126            	  6404: 	BSR.s		LAB_EXCC			* do loops 13 (again) through 31
                            	  6405:  
                            	  6406: 							* now get the result
01:0000E09E 4A2B05B4        	  6407: 	TST.b		cosout(a3)			* test sign flag
01:0000E0A2 6A06            	  6408: 	BPL.s		LAB_EXPL			* branch if +ve
                            	  6409: 
01:0000E0A4 4481            	  6410: 	NEG.l		d1				* do -y
01:0000E0A6 442B05D9        	  6411: 	NEG.b		tpower(a3)			* do -exp
                            	  6412: LAB_EXPL
01:0000E0AA 7083            	  6413: 	MOVEQ		#$83-$100,d0		* set exponent
01:0000E0AC DC81            	  6414: 	ADD.l		d1,d6				* y = y +/- x
01:0000E0AE 6B06            	  6415: 	BMI.s		LAB_EXRN			* branch if result normal
                            	  6416: 
                            	  6417: LAB_EXNN
01:0000E0B0 5380            	  6418: 	SUBQ.l	#1,d0				* decrement exponent
01:0000E0B2 DC86            	  6419: 	ADD.l		d6,d6				* shift mantissa
01:0000E0B4 6AFA            	  6420: 	BPL.s		LAB_EXNN			* loop if not normal
                            	  6421: 
                            	  6422: LAB_EXRN
01:0000E0B6 27460590        	  6423: 	MOVE.l	d6,FAC1_m(a3)		* save exponent result
01:0000E0BA D02B05D9        	  6424: 	ADD.b		tpower(a3),d0		* add integer part
01:0000E0BE 17400594        	  6425: 	MOVE.b	d0,FAC1_e(a3)		* save exponent
                            	  6426: **	MOVEM.l	(sp)+,d1-d6/a0		* restore registers
01:0000E0C2 4E75            	  6427: 	RTS
                            	  6428:  
                            	  6429: 							* cordic loop
                            	  6430: LAB_EXCC
01:0000E0C4 5284            	  6431: 	ADDQ.l	#1,d4				* increment shift count
01:0000E0C6 2406            	  6432: 	MOVE.l	d6,d2				* x1 = x
01:0000E0C8 E8A2            	  6433: 	ASR.l		d4,d2				* x1 >> n
01:0000E0CA 2601            	  6434: 	MOVE.l	d1,d3				* y1 = y
01:0000E0CC E8A3            	  6435: 	ASR.l		d4,d3				* y1 >> n
01:0000E0CE 4A80            	  6436: 	TST.l		d0				* test arg
01:0000E0D0 6B0C            	  6437: 	BMI.s		LAB_EXAD			* branch if -ve
                            	  6438: 
01:0000E0D2 D282            	  6439: 	ADD.l		d2,d1				* y = y + x1
01:0000E0D4 DC83            	  6440: 	ADD.l		d3,d6				* x = x + y1
01:0000E0D6 9098            	  6441: 	SUB.l		(a0)+,d0			* arg = arg - atnh(a0)
01:0000E0D8 51CDFFEA        	  6442: 	DBF		d5,LAB_EXCC			* decrement and loop if not done
                            	  6443: 
01:0000E0DC 4E75            	  6444: 	RTS
                            	  6445: 
                            	  6446: LAB_EXAD
01:0000E0DE 9282            	  6447: 	SUB.l		d2,d1				* y = y - x1
01:0000E0E0 9C83            	  6448: 	SUB.l		d3,d6				* x = x + y1
01:0000E0E2 D098            	  6449: 	ADD.l		(a0)+,d0			* arg = arg + atnh(a0)
01:0000E0E4 51CDFFDE        	  6450: 	DBF		d5,LAB_EXCC			* decrement and loop if not done
                            	  6451: 
01:0000E0E8 4E75            	  6452: 	RTS
                            	  6453: 
                            	  6454: 
                            	  6455: *************************************************************************************
                            	  6456: *
                            	  6457: * RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
                            	  6458: * to get 19th next number in sequence after seed n. This version of the PRNG uses
                            	  6459: * the Galois method and a sample of 65536 bytes produced gives the following values.
                            	  6460: 
                            	  6461: * Entropy = 7.997442 bits per byte
                            	  6462: * Optimum compression would reduce these 65536 bytes by 0 percent
                            	  6463: 
                            	  6464: * Chi square distribution for 65536 samples is 232.01, and
                            	  6465: * randomly would exceed this value 75.00 percent of the time
                            	  6466: 
                            	  6467: * Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
                            	  6468: * Monte Carlo value for Pi is 3.122871269, error 0.60 percent
                            	  6469: * Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
                            	  6470: 
                            	  6471: LAB_RND
01:0000E0EA 4A2B0594        	  6472: 	TST.b		FAC1_e(a3)			* get FAC1 exponent
01:0000E0EE 6708            	  6473: 	BEQ.s		NextPRN			* do next random number if zero
                            	  6474: 
                            	  6475: 							* else get seed into random number store
01:0000E0F0 41EB05A0        	  6476: 	LEA		PRNlword(a3),a0		* set PRNG pointer
01:0000E0F4 6100FAB2        	  6477: 	BSR		LAB_2778			* pack FAC1 into (a0)
                            	  6478: NextPRN
01:0000E0F8 72AF            	  6479: 	MOVEQ		#$AF-$100,d1		* set EOR value
01:0000E0FA 7412            	  6480: 	MOVEQ		#18,d2			* do this 19 times
01:0000E0FC 202B05A0        	  6481: 	MOVE.l	PRNlword(a3),d0		* get current
                            	  6482: Ninc0
01:0000E100 D080            	  6483: 	ADD.l		d0,d0				* shift left 1 bit
01:0000E102 6402            	  6484: 	BCC.s		Ninc1				* branch if bit 32 not set
                            	  6485: 
01:0000E104 B300            	  6486: 	EOR.b		d1,d0				* do Galois LFSR feedback
                            	  6487: Ninc1
01:0000E106 51CAFFF8        	  6488: 	DBF		d2,Ninc0			* loop
                            	  6489: 
01:0000E10A 274005A0        	  6490: 	MOVE.l	d0,PRNlword(a3)		* save back to seed word
01:0000E10E 27400590        	  6491: 	MOVE.l	d0,FAC1_m(a3)		* copy to FAC1 mantissa
01:0000E112 377C80000594    	  6492: 	MOVE.w	#$8000,FAC1_e(a3)		* set the exponent and clear the sign
01:0000E118 6000F7F2        	  6493: 	BRA		LAB_24D5			* normalise FAC1 & return
                            	  6494: 
                            	  6495: 
                            	  6496: *************************************************************************************
                            	  6497: *
                            	  6498: * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
                            	  6499: * x = angle in radians
                            	  6500: 
                            	  6501: LAB_TAN
01:0000E11C 6138            	  6502: 	BSR.s		LAB_SIN			* go do SIN/COS cordic compute
01:0000E11E 376B0594059C    	  6503: 	MOVE.w	FAC1_e(a3),FAC2_e(a3)	* copy exponent & sign from FAC1 to FAC2
01:0000E124 276B05900598    	  6504: 	MOVE.l	FAC1_m(a3),FAC2_m(a3)	* copy FAC1 mantissa to FAC2 mantissa
01:0000E12A 27410590        	  6505: 	MOVE.l	d1,FAC1_m(a3)		* get COS(x) mantissa
01:0000E12E 17430594        	  6506: 	MOVE.b	d3,FAC1_e(a3)		* get COS(x) exponent
01:0000E132 6700E03C        	  6507: 	BEQ		LAB_OFER			* do overflow if COS = 0
                            	  6508: 
01:0000E136 6100F7D4        	  6509: 	BSR		LAB_24D5			* normalise FAC1
01:0000E13A 6000F984        	  6510: 	BRA		LAB_DIVIDE			* do FAC2/FAC1 and return, FAC_sc set by SIN
                            	  6511: 							* COS calculation
                            	  6512: 
                            	  6513: 
                            	  6514: *************************************************************************************
                            	  6515: *
                            	  6516: * cordic SIN(x), COS(x) routine
                            	  6517: * x = angle in radians
                            	  6518: 
                            	  6519: LAB_COS
01:0000E13E 277CC90FDAA30598	  6520: 	MOVE.l	#$C90FDAA3,FAC2_m(a3)	* pi/2 mantissa (LSB is rounded up so
                            	  6521: 							* COS(PI/2)=0)
01:0000E146 377C8100059C    	  6522: 	MOVE.w	#$8100,FAC2_e(a3)		* pi/2 exponent and sign
01:0000E14C 176B0595059E    	  6523: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign = FAC1 sign (b7)
01:0000E152 6100F73E        	  6524: 	BSR		LAB_ADD			* add FAC2 to FAC1, adjust for COS(x)
                            	  6525: 
                            	  6526: 
                            	  6527: *************************************************************************************
                            	  6528: *
                            	  6529: * SIN/COS cordic calculator
                            	  6530: 
                            	  6531: LAB_SIN
01:0000E156 177C000005B4    	  6532: 	MOVE.b	#0,cosout(a3)		* set needed result
                            	  6533: 
01:0000E15C 277CA2F9836F0598	  6534: 	MOVE.l	#$A2F9836F,FAC2_m(a3)	* 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
01:0000E164 377C7F00059C    	  6535: 	MOVE.w	#$7F00,FAC2_e(a3)		* 1/pi exponent & sign
01:0000E16A 176B0595059E    	  6536: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign = FAC1 sign (b7)
01:0000E170 6100F8C2        	  6537: 	BSR		LAB_MULTIPLY		* multiply by 1/pi
                            	  6538: 
01:0000E174 102B0594        	  6539: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:0000E178 671C            	  6540: 	BEQ.s		LAB_SCZE			* branch if zero
                            	  6541: 
01:0000E17A 41FA0B2A        	  6542: 	LEA		TAB_SNCO(pc),a0		* get pointer to constants table
01:0000E17E 2C2B0590        	  6543: 	MOVE.l	FAC1_m(a3),d6		* get FAC1 mantissa
01:0000E182 5300            	  6544: 	SUBQ.b	#1,d0				* 2 radians in 360 degrees so /2
01:0000E184 6710            	  6545: 	BEQ.s		LAB_SCZE			* branch if zero
                            	  6546: 
01:0000E186 903C0080        	  6547: 	SUB.b		#$80,d0			* normalise exponent
01:0000E18A 6B18            	  6548: 	BMI.s		LAB_SCL0			* branch if < 1
                            	  6549: 
                            	  6550: 							* X is > 1
01:0000E18C B03C0020        	  6551: 	CMP.b		#$20,d0			* is it >= 2^32
01:0000E190 6404            	  6552: 	BCC.s		LAB_SCZE			* may as well do zero
                            	  6553: 
01:0000E192 E1AE            	  6554: 	LSL.l		d0,d6				* shift out integer part bits
01:0000E194 6618            	  6555: 	BNE.s		LAB_CORD			* if fraction go test quadrant and adjust
                            	  6556: 
                            	  6557: 							* else no fraction so do zero
                            	  6558: LAB_SCZE
01:0000E196 7481            	  6559: 	MOVEQ		#$81-$100,d2		* set exponent for 1.0
01:0000E198 7600            	  6560: 	MOVEQ		#0,d3				* set exponent for 0.0
01:0000E19A 203C80000000    	  6561: 	MOVE.l	#$80000000,d0		* mantissa for 1.0
01:0000E1A0 2203            	  6562: 	MOVE.l	d3,d1				* mantissa for 0.0
01:0000E1A2 605C            	  6563: 	BRA.s		outloop			* go output it
                            	  6564: 
                            	  6565: 							* x is < 1
                            	  6566: LAB_SCL0
01:0000E1A4 4400            	  6567: 	NEG.b		d0				* make +ve
01:0000E1A6 B03C001E        	  6568: 	CMP.b		#$1E,d0			* is it <= 2^-30
01:0000E1AA 64EA            	  6569: 	BCC.s		LAB_SCZE			* may as well do zero
                            	  6570: 
01:0000E1AC E0AE            	  6571: 	LSR.l		d0,d6				* shift out <= 2^-32 bits
                            	  6572: 
                            	  6573: * cordic calculator, argument in d6
                            	  6574: * table pointer in a0, returns in d0-d3
                            	  6575: 
                            	  6576: LAB_CORD
01:0000E1AE 176B0595059E    	  6577: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* copy as sign compare for TAN
01:0000E1B4 DC86            	  6578: 	ADD.l		d6,d6				* shift 0.5 bit into carry
01:0000E1B6 6404            	  6579: 	BCC.s		LAB_LTPF			* branch if less than 0.5
                            	  6580: 
01:0000E1B8 462B0595        	  6581: 	EORI.b	#$FF,FAC1_s(a3)		* toggle result sign
                            	  6582: LAB_LTPF
01:0000E1BC DC86            	  6583: 	ADD.l		d6,d6				* shift 0.25 bit into carry
01:0000E1BE 6408            	  6584: 	BCC.s		LAB_LTPT			* branch if less than 0.25
                            	  6585: 
01:0000E1C0 462B05B4        	  6586: 	EORI.b	#$FF,cosout(a3)		* toggle needed result
01:0000E1C4 462B059E        	  6587: 	EORI.b	#$FF,FAC_sc(a3)		* toggle sign compare for TAN
                            	  6588: 
                            	  6589: LAB_LTPT
01:0000E1C8 E48E            	  6590: 	LSR.l		#2,d6				* shift the bits back (clear integer bits)
01:0000E1CA 67CA            	  6591: 	BEQ.s		LAB_SCZE			* no fraction so go do zero
                            	  6592: 
                            	  6593: 							* set start values
01:0000E1CC 7A01            	  6594: 	MOVEQ		#1,d5				* set bit count
01:0000E1CE 2028FFFC        	  6595: 	MOVE.l	-4(a0),d0			* get multiply constant (1st itteration d0)
01:0000E1D2 2200            	  6596: 	MOVE.l	d0,d1				* 1st itteration d1
01:0000E1D4 9C98            	  6597: 	SUB.l		(a0)+,d6			* 1st always +ve so do 1st step
01:0000E1D6 6008            	  6598: 	BRA.s		mainloop			* jump into routine
                            	  6599: 
                            	  6600: subloop
01:0000E1D8 9C98            	  6601: 	SUB.l		(a0)+,d6			* z = z - arctan(i)/2pi
01:0000E1DA 9083            	  6602: 	SUB.l		d3,d0				* x = x - y1
01:0000E1DC D282            	  6603: 	ADD.l		d2,d1				* y = y + x1
01:0000E1DE 6012            	  6604: 	BRA.s		nexta				* back to main loop
                            	  6605: 
                            	  6606: mainloop
01:0000E1E0 2400            	  6607: 	MOVE.l	d0,d2				* x1 = x
01:0000E1E2 EAA2            	  6608: 	ASR.l		d5,d2				* / (2 ^ i)
01:0000E1E4 2601            	  6609: 	MOVE.l	d1,d3				* y1 = y
01:0000E1E6 EAA3            	  6610: 	ASR.l		d5,d3				* / (2 ^ i)
01:0000E1E8 4A86            	  6611: 	TST.l		d6				* test sign (is 2^0 bit)
01:0000E1EA 6AEC            	  6612: 	BPL.s		subloop			* go do subtract if > 1
                            	  6613: 
01:0000E1EC DC98            	  6614: 	ADD.l		(a0)+,d6			* z = z + arctan(i)/2pi
01:0000E1EE D083            	  6615: 	ADD.l		d3,d0				* x = x + y1
01:0000E1F0 9282            	  6616: 	SUB.l		d2,d1				* y = y + x1
                            	  6617: nexta
01:0000E1F2 5285            	  6618: 	ADDQ.l	#1,d5				* i = i + 1
01:0000E1F4 BABC0000001E    	  6619: 	CMP.l		#$1E,d5			* check end condition
01:0000E1FA 66E4            	  6620: 	BNE.s		mainloop			* loop if not all done
                            	  6621: 
                            	  6622: 							* now untangle output value
01:0000E1FC 7481            	  6623: 	MOVEQ		#$81-$100,d2		* set exponent for 0 to .99 rec.
01:0000E1FE 2602            	  6624: 	MOVE.l	d2,d3				* copy it for cos output
                            	  6625: outloop
01:0000E200 4A2B05B4        	  6626: 	TST.b		cosout(a3)			* did we want cos output?
01:0000E204 6B04            	  6627: 	BMI.s		subexit			* if so skip
                            	  6628: 
01:0000E206 C141            	  6629: 	EXG		d0,d1				* swap SIN and COS mantissas
01:0000E208 C543            	  6630: 	EXG		d2,d3				* swap SIN and COS exponents
                            	  6631: subexit
01:0000E20A 27400590        	  6632: 	MOVE.l	d0,FAC1_m(a3)		* set result mantissa
01:0000E20E 17420594        	  6633: 	MOVE.b	d2,FAC1_e(a3)		* set result exponent
01:0000E212 6000F6F8        	  6634: 	BRA		LAB_24D5			* normalise FAC1 & return
                            	  6635: 
                            	  6636: 
                            	  6637: 
                            	  6638: *************************************************************************************
                            	  6639: *
                            	  6640: * perform ATN()
                            	  6641: 
                            	  6642: LAB_ATN
01:0000E216 102B0594        	  6643: 	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
01:0000E21A 670000AA        	  6644: 	BEQ		RTS_021			* ATN(0) = 0 so skip calculation
                            	  6645: 
01:0000E21E 177C000005B4    	  6646: 	MOVE.b	#0,cosout(a3)		* set result needed
01:0000E224 B03C0081        	  6647: 	CMP.b		#$81,d0			* compare exponent with 1
01:0000E228 6528            	  6648: 	BCS.s		LAB_ATLE			* branch if n<1
                            	  6649: 
01:0000E22A 6608            	  6650: 	BNE.s		LAB_ATGO			* branch if n>1
                            	  6651: 
01:0000E22C 202B0590        	  6652: 	MOVE.l	FAC1_m(a3),d0		* get mantissa
01:0000E230 D080            	  6653: 	ADD.l		d0,d0				* shift left
01:0000E232 671E            	  6654: 	BEQ.s		LAB_ATLE			* branch if n=1
                            	  6655: 
                            	  6656: LAB_ATGO
01:0000E234 277C800000000598	  6657: 	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 1
01:0000E23C 377C8100059C    	  6658: 	MOVE.w	#$8100,FAC2_e(a3)		* set exponent for 1
01:0000E242 176B0595059E    	  6659: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign compare = sign
01:0000E248 6100F876        	  6660: 	BSR		LAB_DIVIDE			* do 1/n
01:0000E24C 177C00FF05B4    	  6661: 	MOVE.b	#$FF,cosout(a3)		* set inverse result needed
                            	  6662: LAB_ATLE
01:0000E252 202B0590        	  6663: 	MOVE.l	FAC1_m(a3),d0		* get FAC1 mantissa
01:0000E256 7282            	  6664: 	MOVEQ		#$82,d1			* set to correct exponent
01:0000E258 922B0594        	  6665: 	SUB.b		FAC1_e(a3),d1		* subtract FAC1 exponent (always <= 1)
01:0000E25C E2A8            	  6666: 	LSR.l		d1,d0				* shift in two integer part bits
01:0000E25E 41FA0AC6        	  6667: 	LEA		TAB_ATNC(pc),a0		* get pointer to arctan table
01:0000E262 7C00            	  6668: 	MOVEQ		#0,d6				* Z = 0
01:0000E264 223C40000000    	  6669: 	MOVE.l	#1<<30,d1			* y = 1
01:0000E26A 7A1D            	  6670: 	MOVEQ		#29,d5			* loop 30 times
01:0000E26C 7801            	  6671: 	MOVEQ		#1,d4				* shift counter
01:0000E26E 6006            	  6672: 	BRA.s		LAB_ATCD			* enter loop
                            	  6673: 
                            	  6674: LAB_ATNP
01:0000E270 E8A2            	  6675: 	ASR.l		d4,d2				* x1 / 2^i
01:0000E272 D282            	  6676: 	ADD.l		d2,d1				* y = y + x1
01:0000E274 DC90            	  6677: 	ADD.l		(a0),d6			* z = z + atn(i)
                            	  6678: LAB_ATCD
01:0000E276 2400            	  6679: 	MOVE.l	d0,d2				* x1 = x
01:0000E278 2601            	  6680: 	MOVE.l	d1,d3				* y1 = y
01:0000E27A E8A3            	  6681: 	ASR.l		d4,d3				* y1 / 2^i
                            	  6682: LAB_CATN
01:0000E27C 9083            	  6683: 	SUB.l		d3,d0				* x = x - y1
01:0000E27E 6AF0            	  6684: 	BPL.s		LAB_ATNP			* branch if x >= 0
                            	  6685: 
01:0000E280 2002            	  6686: 	MOVE.l	d2,d0				* else get x back
01:0000E282 5848            	  6687: 	ADDQ.w	#4,a0				* increment pointer
01:0000E284 5284            	  6688: 	ADDQ.l	#1,d4				* increment i
01:0000E286 E283            	  6689: 	ASR.l		#1,d3				* y1 / 2^i
01:0000E288 51CDFFF2        	  6690: 	DBF		d5,LAB_CATN			* decrement and loop if not done
                            	  6691: 
01:0000E28C 177C00820594    	  6692: 	MOVE.b	#$82,FAC1_e(a3)		* set new exponent
01:0000E292 27460590        	  6693: 	MOVE.l	d6,FAC1_m(a3)		* save mantissa
01:0000E296 6100F674        	  6694: 	BSR		LAB_24D5			* normalise FAC1
                            	  6695: 
01:0000E29A 4A2B05B4        	  6696: 	TST.b		cosout(a3)			* was it > 1 ?
01:0000E29E 6A26            	  6697: 	BPL.s		RTS_021			* branch if not
                            	  6698: 
01:0000E2A0 1E2B0595        	  6699: 	MOVE.b	FAC1_s(a3),d7		* get sign
01:0000E2A4 177C00000595    	  6700: 	MOVE.b	#0,FAC1_s(a3)		* clear sign
01:0000E2AA 277CC90FDAA20598	  6701: 	MOVE.l	#$C90FDAA2,FAC2_m(a3)	* set -(pi/2)
01:0000E2B2 377C8180059C    	  6702: 	MOVE.w	#$8180,FAC2_e(a3)		* set exponent and sign
01:0000E2B8 177C00FF059E    	  6703: 	MOVE.b	#$FF,FAC_sc(a3)		* set sign compare
01:0000E2BE 6100F5D2        	  6704: 	BSR		LAB_ADD			* perform addition, FAC2 to FAC1
01:0000E2C2 17470595        	  6705: 	MOVE.b	d7,FAC1_s(a3)		* restore sign
                            	  6706: RTS_021
01:0000E2C6 4E75            	  6707: 	RTS
                            	  6708: 
                            	  6709: 
                            	  6710: *************************************************************************************
                            	  6711: *
                            	  6712: * perform BITSET
                            	  6713: 
                            	  6714: LAB_BITSET
01:0000E2C8 6100F4A8        	  6715: 	BSR		LAB_GADB			* get two parameters for POKE or WAIT
                            	  6716: 							* first parameter in a0, second in d0
01:0000E2CC B03C0008        	  6717: 	CMP.b		#$08,d0			* only 0 to 7 are allowed
01:0000E2D0 6400DEA2        	  6718: 	BCC		LAB_FCER			* branch if > 7
                            	  6719: 
01:0000E2D4 01D0            	  6720: 	BSET		d0,(a0)			* set bit
01:0000E2D6 4E75            	  6721: 	RTS
                            	  6722: 
                            	  6723: 
                            	  6724: *************************************************************************************
                            	  6725: *
                            	  6726: * perform BITCLR
                            	  6727: 
                            	  6728: LAB_BITCLR
01:0000E2D8 6100F498        	  6729: 	BSR		LAB_GADB			* get two parameters for POKE or WAIT
                            	  6730: 							* first parameter in a0, second in d0
01:0000E2DC B03C0008        	  6731: 	CMP.b		#$08,d0			* only 0 to 7 are allowed
01:0000E2E0 6400DE92        	  6732: 	BCC		LAB_FCER			* branch if > 7
                            	  6733: 
01:0000E2E4 0190            	  6734: 	BCLR		d0,(a0)			* clear bit
01:0000E2E6 4E75            	  6735: 	RTS
                            	  6736: 
                            	  6737: 
                            	  6738: *************************************************************************************
                            	  6739: *
                            	  6740: * perform BITTST()
                            	  6741: 
                            	  6742: LAB_BTST
01:0000E2E8 101D            	  6743: 	MOVE.b	(a5)+,d0			* increment BASIC pointer
01:0000E2EA 6100F486        	  6744: 	BSR		LAB_GADB			* get two parameters for POKE or WAIT
                            	  6745: 							* first parameter in a0, second in d0
01:0000E2EE B03C0008        	  6746: 	CMP.b		#$08,d0			* only 0 to 7 are allowed
01:0000E2F2 6400DE80        	  6747: 	BCC		LAB_FCER			* branch if > 7
                            	  6748: 
01:0000E2F6 2200            	  6749: 	MOVE.l	d0,d1				* copy bit # to test
01:0000E2F8 6100EAC4        	  6750: 	BSR		LAB_GBYT			* get next BASIC byte
01:0000E2FC B03C0029        	  6751: 	CMP.b		#')',d0			* is next character ")"
01:0000E300 6600DE7E        	  6752: 	BNE		LAB_SNER			* if not ")" go do syntax error, then warm start
                            	  6753: 
01:0000E304 6100EAB6        	  6754: 	BSR		LAB_IGBY			* update execute pointer (to character past ")")
01:0000E308 7000            	  6755: 	MOVEQ		#0,d0				* set the result as zero
01:0000E30A 0310            	  6756: 	BTST		d1,(a0)			* test bit
01:0000E30C 6700F914        	  6757: 	BEQ		LAB_27DB			* branch if zero (already correct)
                            	  6758: 
01:0000E310 70FF            	  6759: 	MOVEQ		#-1,d0			* set for -1 result
01:0000E312 6000F90E        	  6760: 	BRA		LAB_27DB			* go do SGN tail
                            	  6761: 
                            	  6762: 
                            	  6763: *************************************************************************************
                            	  6764: *
                            	  6765: * perform USING$()
                            	  6766: 
                            	  6767: fsd	EQU	 0					*   (sp) format string descriptor pointer
                            	  6768: fsti	EQU	 4					*  4(sp) format string this index
                            	  6769: fsli	EQU	 6					*  6(sp) format string last index
                            	  6770: fsdpi	EQU	 8					*  8(sp) format string decimal point index
                            	  6771: fsdc	EQU	10					* 10(sp) format string decimal characters
                            	  6772: fend	EQU	12-4					*  x(sp) end-4, fsd is popped by itself
                            	  6773: 
                            	  6774: ofchr	EQU	'#'					* the overflow character
                            	  6775: 
                            	  6776: LAB_USINGS
01:0000E316 4A2B05B5        	  6777: 	TST.b		Dtypef(a3)			* test data type, $80=string
01:0000E31A 6A00DE10        	  6778: 	BPL		LAB_FOER			* if not string type go do format error
                            	  6779: 
01:0000E31E 246B0590        	  6780: 	MOVEA.l	FAC1_m(a3),a2		* get the format string descriptor pointer
01:0000E322 3E2A0004        	  6781: 	MOVE.w	4(a2),d7			* get the format string length
01:0000E326 6700DE04        	  6782: 	BEQ		LAB_FOER			* if null string go do format error
                            	  6783: 
                            	  6784: * clear the format string values
                            	  6785: 
01:0000E32A 7000            	  6786: 	MOVEQ		#0,d0				* clear d0
01:0000E32C 3F00            	  6787: 	MOVE.w	d0,-(sp)			* clear the format string decimal characters
01:0000E32E 3F00            	  6788: 	MOVE.w	d0,-(sp)			* clear the format string decimal point index
01:0000E330 3F00            	  6789: 	MOVE.w	d0,-(sp)			* clear the format string last index
01:0000E332 3F00            	  6790: 	MOVE.w	d0,-(sp)			* clear the format string this index
01:0000E334 2F0A            	  6791: 	MOVE.l	a2,-(sp)			* save the format string descriptor pointer
                            	  6792: 
                            	  6793: * make a null return string for the first string add
                            	  6794: 
01:0000E336 7200            	  6795: 	MOVEQ		#0,d1				* make a null string
01:0000E338 2041            	  6796: 	MOVEA.l	d1,a0				* with a null pointer
01:0000E33A 6100F0DA        	  6797: 	BSR		LAB_RTST			* push a string on the descriptor stack
                            	  6798: 							* a0 = pointer, d1 = length
                            	  6799: 
                            	  6800: * do the USING$() function next value
                            	  6801: 
01:0000E33E 101D            	  6802: 	MOVE.b	(a5)+,d0			* get the next BASIC byte
                            	  6803: LAB_U002
01:0000E340 B03C002C        	  6804: 	CMP.b		#',',d0			* compare with comma
01:0000E344 6600DE3A        	  6805: 	BNE		LAB_SNER			* if not "," go do syntax error
                            	  6806: 
01:0000E348 6100028C        	  6807: 	BSR		LAB_ProcFo			* process the format string
01:0000E34C 4A02            	  6808: 	TST.b		d2				* test the special characters flag
01:0000E34E 6700DDDC        	  6809: 	BEQ		LAB_FOER			* if no special characters go do format error
                            	  6810: 
01:0000E352 6100E908        	  6811: 	BSR		LAB_EVEX			* evaluate the expression
01:0000E356 4A2B05B5        	  6812: 	TST.b		Dtypef(a3)			* test the data type
01:0000E35A 6B00DDF8        	  6813: 	BMI		LAB_TMER			* if string type go do type missmatch error
                            	  6814: 
01:0000E35E 4A2B0594        	  6815: 	TST.b		FAC1_e(a3)			* test FAC1 exponent
01:0000E362 6732            	  6816: 	BEQ.s		LAB_U004			* if FAC1 = 0 skip the rounding
                            	  6817: 
01:0000E364 322F000A        	  6818: 	MOVE.w	fsdc(sp),d1			* get the format string decimal character count
01:0000E368 B27C0008        	  6819: 	CMP.w		#8,d1				* compare the fraction digit count with 8
01:0000E36C 6428            	  6820: 	BCC.s		LAB_U004			* if >= 8 skip the rounding
                            	  6821: 
01:0000E36E 3001            	  6822: 	MOVE.w	d1,d0				* else copy the fraction digit count
01:0000E370 D241            	  6823: 	ADD.w		d1,d1				* * 2
01:0000E372 D240            	  6824: 	ADD.w		d0,d1				* * 3
01:0000E374 D241            	  6825: 	ADD.w		d1,d1				* * 6
01:0000E376 41FA0840        	  6826: 	LEA		LAB_P_10(pc),a0		* get the rounding table base
01:0000E37A 277010020598    	  6827: 	MOVE.l	2(a0,d1.w),FAC2_m(a3)	* get the rounding mantissa
01:0000E380 30301000        	  6828: 	MOVE.w	(a0,d1.w),d0		* get the rounding exponent
01:0000E384 907C0100        	  6829: 	SUB.w		#$100,d0			* effectively divide the mantissa by 2
01:0000E388 3740059C        	  6830: 	MOVE.w	d0,FAC2_e(a3)		* save the rounding exponent
01:0000E38C 177C0000059E    	  6831: 	MOVE.b	#$00,FAC_sc(a3)		* clear the sign compare
01:0000E392 6100F4FE        	  6832: 	BSR		LAB_ADD			* round the value to n places
                            	  6833: LAB_U004
01:0000E396 6100F976        	  6834: 	BSR		LAB_2970			* convert FAC1 to string - not on stack
                            	  6835: 
01:0000E39A 610001FC        	  6836: 	BSR		LAB_DupFmt			* duplicate the processed format string section
                            	  6837: 							* returns length in d1, pointer in a0
                            	  6838: 
                            	  6839: * process the number string, length in d6, decimal point index in d2
                            	  6840: 
01:0000E39E 45EB05C6        	  6841: 	LEA		Decss(a3),a2		* set the number string start
01:0000E3A2 7C00            	  6842: 	MOVEQ		#0,d6				* clear the number string index
01:0000E3A4 782E            	  6843: 	MOVEQ		#'.',d4			* set the decimal point character
                            	  6844: LAB_U005
01:0000E3A6 3406            	  6845: 	MOVE.w	d6,d2				* save the index to flag the decimal point
                            	  6846: LAB_U006
01:0000E3A8 5246            	  6847: 	ADDQ.w	#1,d6				* increment the number string index
01:0000E3AA 10326000        	  6848: 	MOVE.b	(a2,d6.w),d0		* get a number string character
01:0000E3AE 677A            	  6849: 	BEQ.s		LAB_U010			* if null then number complete
                            	  6850: 
01:0000E3B0 B03C0045        	  6851: 	CMP.b		#'E',d0			* compare the character with an "E"
01:0000E3B4 6706            	  6852: 	BEQ.s		LAB_U008			* was sx[.x]Esxx so go handle sci notation
                            	  6853: 
01:0000E3B6 B004            	  6854: 	CMP.b		d4,d0				* compare the character with "."
01:0000E3B8 66EE            	  6855: 	BNE.s		LAB_U006			* if not decimal point go get the next digit
                            	  6856: 
01:0000E3BA 60EA            	  6857: 	BRA.s		LAB_U005			* go save the index and get the next digit
                            	  6858: 
                            	  6859: * have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
                            	  6860: 
                            	  6861: LAB_U008
01:0000E3BC 3606            	  6862: 	MOVE.w	d6,d3				* copy the index to the "E"
01:0000E3BE 5343            	  6863: 	SUBQ.w	#1,d3				* -1 gives the last digit index
                            	  6864: 
01:0000E3C0 5246            	  6865: 	ADDQ.w	#1,d6				* increment the index to the exponent sign
01:0000E3C2 10326000        	  6866: 	MOVE.b	(a2,d6.w),d0		* get the exponent sign character
01:0000E3C6 B03C002D        	  6867: 	CMP.b		#'-',d0			* compare the exponent sign with "-"
01:0000E3CA 6600DDA8        	  6868: 	BNE		LAB_FCER			* if it wasn't sx[.x]E-xx go do function
                            	  6869: 							* call error
                            	  6870: 
                            	  6871: * found an sx[.x]E-xx number so check the exponent magnitude
                            	  6872: 
01:0000E3CE 5246            	  6873: 	ADDQ.w	#1,d6				* increment the index to the exponent 10s
01:0000E3D0 10326000        	  6874: 	MOVE.b	(a2,d6.w),d0		* get the exponent 10s character
01:0000E3D4 B03C0030        	  6875: 	CMP.b		#'0',d0			* compare the exponent 10s with "0"
01:0000E3D8 6704            	  6876: 	BEQ.s		LAB_U009			* if it was sx[.x]E-0x go get the exponent
                            	  6877: 							* 1s character
                            	  6878: 
01:0000E3DA 700A            	  6879: 	MOVEQ		#10,d0			* else start writing at index 10
01:0000E3DC 6008            	  6880: 	BRA.s		LAB_U00A			* go copy the digits
                            	  6881: 
                            	  6882: * found an sx[.x]E-0x number so get the exponent magnitude
                            	  6883: 
                            	  6884: LAB_U009
01:0000E3DE 5246            	  6885: 	ADDQ.w	#1,d6				* increment the index to the exponent 1s
01:0000E3E0 700F            	  6886: 	MOVEQ		#$0F,d0			* set the mask for the exponent 1s digit
01:0000E3E2 C0326000        	  6887: 	AND.b		(a2,d6.w),d0		* get and convert the exponent 1s digit
                            	  6888: LAB_U00A
01:0000E3E6 3403            	  6889: 	MOVE.w	d3,d2				* copy the number last digit index
01:0000E3E8 0C420001        	  6890: 	CMPI.w	#1,d2				* is the number of the form sxE-0x
01:0000E3EC 6602            	  6891: 	BNE.s		LAB_U00B			* if it is sx.xE-0x skip the increment
                            	  6892: 
                            	  6893: 							* else make room for the decimal point
01:0000E3EE 5242            	  6894: 	ADDQ.w	#1,d2				* add 1 to the write index
                            	  6895: LAB_U00B
01:0000E3F0 D440            	  6896: 	ADD.w		d0,d2				* add the exponent 1s to the write index
01:0000E3F2 700A            	  6897: 	MOVEQ		#10,d0			* set the maximum write index
01:0000E3F4 9042            	  6898: 	SUB.w		d2,d0				* compare the index with the maximum
01:0000E3F6 6E0C            	  6899: 	BGT.s		LAB_U00C			* if the index < the maximum continue
                            	  6900: 
01:0000E3F8 D440            	  6901: 	ADD.w		d0,d2				* else set the index to the maximum
01:0000E3FA D640            	  6902: 	ADD.w		d0,d3				* adjust the read index
01:0000E3FC 0C430001        	  6903: 	CMPI.w	#1,d3				* compare the adjusted index with 1
01:0000E400 6E02            	  6904: 	BGT.s		LAB_U00C			* if > 1 continue
                            	  6905: 
01:0000E402 7600            	  6906: 	MOVEQ		#0,d3				* else allow for the decimal point
                            	  6907: LAB_U00C
01:0000E404 3C02            	  6908: 	MOVE.w		d2,d6				* copy the write index as the number
                            	  6909: 							* string length
01:0000E406 7000            	  6910: 	MOVEQ		#0,d0				* clear d0 to null terminate the number
                            	  6911: 							* string
                            	  6912: LAB_U00D
01:0000E408 15802000        	  6913: 	MOVE.b	d0,(a2,d2.w)		* save the character to the number string
01:0000E40C 5342            	  6914: 	SUBQ.w	#1,d2				* decrement the number write index
01:0000E40E 0C420001        	  6915: 	CMPI.w	#1,d2				* compare the number write index with 1
01:0000E412 6712            	  6916: 	BEQ.s		LAB_U00F			* if at the decimal point go save it
                            	  6917: 
                            	  6918: 							* else write a digit to the number string
01:0000E414 7030            	  6919: 	MOVEQ		#'0',d0			* default to "0"
01:0000E416 4A43            	  6920: 	TST.w		d3				* test the number read index
01:0000E418 67EE            	  6921: 	BEQ.s		LAB_U00D			* if zero just go save the "0"
                            	  6922: 
                            	  6923: LAB_U00E
01:0000E41A 10323000        	  6924: 	MOVE.b	(a2,d3.w),d0		* read the next number digit
01:0000E41E 5343            	  6925: 	SUBQ.w	#1,d3				* decrement the read index
01:0000E420 B004            	  6926: 	CMP.b		d4,d0				* compare the digit with "."
01:0000E422 66E4            	  6927: 	BNE.s		LAB_U00D			* if not "." go save the digit
                            	  6928: 
01:0000E424 60F4            	  6929: 	BRA.s		LAB_U00E			* else go get the next digit
                            	  6930: 
                            	  6931: LAB_U00F
01:0000E426 15842000        	  6932: 	MOVE.b	d4,(a2,d2.w)		* save the decimal point
                            	  6933: LAB_U010
01:0000E42A 4A42            	  6934: 	TST.w		d2				* test the number string decimal point index
01:0000E42C 6602            	  6935: 	BNE.s		LAB_U014			* if dp present skip the reset
                            	  6936: 
01:0000E42E 3406            	  6937: 	MOVE.w	d6,d2				* make the decimal point index = the length
                            	  6938: 
                            	  6939: * copy the fractional digit characters from the number string
                            	  6940: 
                            	  6941: LAB_U014
01:0000E430 3602            	  6942: 	MOVE.w	d2,d3				* copy the number string decimal point index
01:0000E432 5243            	  6943: 	ADDQ.w	#1,d3				* increment the number string index
01:0000E434 382F0008        	  6944: 	MOVE.w	fsdpi(sp),d4		* get the new format string decimal point index
                            	  6945: LAB_U018
01:0000E438 5244            	  6946: 	ADDQ.w	#1,d4				* increment the new format string index
01:0000E43A B244            	  6947: 	CMP.w		d4,d1				* compare it with the new format string length
01:0000E43C 6322            	  6948: 	BLS.s		LAB_U022			* if done the fraction digits go do integer
                            	  6949: 
01:0000E43E 10304000        	  6950: 	MOVE.b	(a0,d4.w),d0		* get a new format string character
01:0000E442 B03C0025        	  6951: 	CMP.b		#'%',d0			* compare it with "%"
01:0000E446 6706            	  6952: 	BEQ.s		LAB_U01C			* if "%" go copy a number character
                            	  6953: 
01:0000E448 B03C0023        	  6954: 	CMP.b		#'#',d0			* compare it with "#"
01:0000E44C 66EA            	  6955: 	BNE.s		LAB_U018			* if not "#" go do the next new format character
                            	  6956: 
                            	  6957: LAB_U01C
01:0000E44E 7030            	  6958: 	MOVEQ		#'0',d0			* default to "0" character
01:0000E450 BC43            	  6959: 	CMP.w		d3,d6				* compare the number string index with length
01:0000E452 6306            	  6960: 	BLS.s		LAB_U020			* if there skip the character get
                            	  6961: 
01:0000E454 10323000        	  6962: 	MOVE.b	(a2,d3.w),d0		* get a character from the number string
01:0000E458 5243            	  6963: 	ADDQ.w	#1,d3				* increment the number string index
                            	  6964: LAB_U020
01:0000E45A 11804000        	  6965: 	MOVE.b	d0,(a0,d4.w)		* save the number character to the new format
                            	  6966: 							* string
01:0000E45E 60D8            	  6967: 	BRA.s		LAB_U018			* go do the next new format character
                            	  6968: 
                            	  6969: * now copy the integer digit characters from the number string
                            	  6970: 
                            	  6971: LAB_U022
01:0000E460 7C00            	  6972: 	MOVEQ		#0,d6				* clear the sign done flag
01:0000E462 7A00            	  6973: 	MOVEQ		#0,d5				* clear the sign present flag
01:0000E464 5342            	  6974: 	SUBQ.w	#1,d2				* decrement the number string index
01:0000E466 6608            	  6975: 	BNE.s		LAB_U026			* if not now at sign continue
                            	  6976: 
01:0000E468 7401            	  6977: 	MOVEQ		#1,d2				* increment the number string index
01:0000E46A 15BC00302000    	  6978: 	MOVE.b	#'0',(a2,d2.w)		* replace the point with a zero
                            	  6979: LAB_U026
01:0000E470 382F0008        	  6980: 	MOVE.w	fsdpi(sp),d4		* get the new format string decimal point index
01:0000E474 B244            	  6981: 	CMP.w		d4,d1				* compare it with the new format string length
01:0000E476 6402            	  6982: 	BCC.s		LAB_U02A			* if within the string go use the index
                            	  6983: 
01:0000E478 3801            	  6984: 	MOVE.w	d1,d4				* else set the index to the end of the string
                            	  6985: LAB_U02A
01:0000E47A 5344            	  6986: 	SUBQ.w	#1,d4				* decrement the new format string index
01:0000E47C 6B62            	  6987: 	BMI.s		LAB_U03E			* if all done go test for any overflow
                            	  6988: 
01:0000E47E 10304000        	  6989: 	MOVE.b	(a0,d4.w),d0		* else get a new format string character
                            	  6990: 
01:0000E482 7E30            	  6991: 	MOVEQ		#'0',d7			* default to "0" character
01:0000E484 B03C0025        	  6992: 	CMP.b		#'%',d0			* compare it with "%"
01:0000E488 6708            	  6993: 	BEQ.s		LAB_U02B			* if "%" go copy a number character
                            	  6994: 
01:0000E48A 7E20            	  6995: 	MOVEQ		#' ',d7			* default to " " character
01:0000E48C B03C0023        	  6996: 	CMP.b		#'#',d0			* compare it with "#"
01:0000E490 6606            	  6997: 	BNE.s		LAB_U02C			* if not "#" go try ","
                            	  6998: 
                            	  6999: LAB_U02B
01:0000E492 4A42            	  7000: 	TST.w		d2				* test the number string index
01:0000E494 6634            	  7001: 	BNE.s		LAB_U036			* if not at the sign go get a number character
                            	  7002: 
01:0000E496 6042            	  7003: 	BRA.s		LAB_U03C			* else go save the default character
                            	  7004: 
                            	  7005: LAB_U02C
01:0000E498 B03C002C        	  7006: 	CMP.b		#',',d0			* compare it with ","
01:0000E49C 6610            	  7007: 	BNE.s		LAB_U030			* if not "," go try the sign characters
                            	  7008: 
01:0000E49E 4A42            	  7009: 	TST.w		d2				* test the number string index
01:0000E4A0 6608            	  7010: 	BNE.s		LAB_U02E			* if not at the sign keep the ","
                            	  7011: 
01:0000E4A2 0C30002540FF    	  7012: 	CMP.b		#'%',-1(a0,d4.w)		* else compare the next format string character
                            	  7013: 							* with "%"
01:0000E4A8 6630            	  7014: 	BNE.s		LAB_U03C			* if not "%" keep the default character
                            	  7015: 
                            	  7016: LAB_U02E
01:0000E4AA 1E00            	  7017: 	MOVE.b	d0,d7				* else use the "," character
01:0000E4AC 602C            	  7018: 	BRA.s		LAB_U03C			* go save the character to the string
                            	  7019: 
                            	  7020: LAB_U030
01:0000E4AE B03C002D        	  7021: 	CMP.b		#'-',d0			* compare it with "-"
01:0000E4B2 6710            	  7022: 	BEQ.s		LAB_U034			* if "-" go do the sign character
                            	  7023: 
01:0000E4B4 B03C002B        	  7024: 	CMP.b		#'+',d0			* compare it with "+"
01:0000E4B8 66C0            	  7025: 	BNE.s		LAB_U02A			* if not "+" go do the next new format character
                            	  7026: 
01:0000E4BA 0C12002D        	  7027: 	CMP.b		#'-',(a2)			* compare the sign character with "-"
01:0000E4BE 6704            	  7028: 	BEQ.s		LAB_U034			* if "-" don't change the sign character
                            	  7029: 
01:0000E4C0 14BC002B        	  7030: 	MOVE.b	#'+',(a2)			* else make the sign character "+"
                            	  7031: LAB_U034
01:0000E4C4 1A00            	  7032: 	MOVE.b	d0,d5				* set the sign present flag
01:0000E4C6 4A42            	  7033: 	TST.w		d2				* test the number string index
01:0000E4C8 6708            	  7034: 	BEQ.s		LAB_U038			* if at the sign keep the default character
                            	  7035: 
                            	  7036: LAB_U036
01:0000E4CA 1E322000        	  7037: 	MOVE.b	(a2,d2.w),d7		* else get a character from the number string
01:0000E4CE 5342            	  7038: 	SUBQ.w	#1,d2				* decrement the number string index
01:0000E4D0 6008            	  7039: 	BRA.s		LAB_U03C			* go save the character
                            	  7040: 
                            	  7041: LAB_U038
01:0000E4D2 4A06            	  7042: 	TST.b		d6				* test the sign done flag
01:0000E4D4 6604            	  7043: 	BNE.s		LAB_U03C			* if the sign has been done go use the space
                            	  7044: 							* character
                            	  7045: 
01:0000E4D6 1E12            	  7046: 	MOVE.b	(a2),d7			* else get the sign character
01:0000E4D8 1C07            	  7047: 	MOVE.b	d7,d6				* flag that the sign has been done
                            	  7048: LAB_U03C
01:0000E4DA 11874000        	  7049: 	MOVE.b	d7,(a0,d4.w)		* save the number character to the new format
                            	  7050: 							* string
01:0000E4DE 609A            	  7051: 	BRA.s		LAB_U02A			* go do the next new format character
                            	  7052: 
                            	  7053: * test for overflow conditions
                            	  7054: 
                            	  7055: LAB_U03E
01:0000E4E0 4A42            	  7056: 	TST.w		d2				* test the number string index
01:0000E4E2 6614            	  7057: 	BNE.s		LAB_U040			* if all the digits aren't done go output
                            	  7058: 							* an overflow indication
                            	  7059: 
                            	  7060: * test for sign overflows
                            	  7061: 
01:0000E4E4 4A05            	  7062: 	TST.b		d5				* test the sign present flag
01:0000E4E6 6754            	  7063: 	BEQ.s		LAB_U04A			* if no sign present go add the string
                            	  7064: 
                            	  7065: * there was a sign in the format string
                            	  7066: 
01:0000E4E8 4A06            	  7067: 	TST.b		d6				* test the sign done flag
01:0000E4EA 6650            	  7068: 	BNE.s		LAB_U04A			* if the sign is done go add the string
                            	  7069: 
                            	  7070: * the sign isn't done so see if it was mandatory
                            	  7071: 
01:0000E4EC 0C05002B        	  7072: 	CMPI.b	#'+',d5			* compare the sign with "+"
01:0000E4F0 6706            	  7073: 	BEQ.s		LAB_U040			* if it was "+" go output an overflow
                            	  7074: 							* indication
                            	  7075: 
                            	  7076: * the sign wasn't mandatory but the number may have been negative
                            	  7077: 
01:0000E4F2 0C12002D        	  7078: 	CMP.b		#'-',(a2)			* compare the sign character with "-"
01:0000E4F6 6644            	  7079: 	BNE.s		LAB_U04A			* if it wasn't "-" go add the string
                            	  7080: 
                            	  7081: * else the sign was "-" and a sign hasn't been output so ..
                            	  7082: 
                            	  7083: * the number overflowed the format string so replace all the special format characters
                            	  7084: * with the overflow character
                            	  7085: 
                            	  7086: LAB_U040
01:0000E4F8 7A23            	  7087: 	MOVEQ		#ofchr,d5			* set the overflow character
01:0000E4FA 3E01            	  7088: 	MOVE.w	d1,d7				* copy the new format string length
01:0000E4FC 5347            	  7089: 	SUBQ.w	#1,d7				* adjust for the loop type
01:0000E4FE 3C2F0004        	  7090: 	MOVE.w	fsti(sp),d6			* copy the new format string last index
01:0000E502 5346            	  7091: 	SUBQ.w	#1,d6				* -1 gives the last character of this string
01:0000E504 6E02            	  7092: 	BGT.s		LAB_U044			* if not zero continue
                            	  7093: 
01:0000E506 3C07            	  7094: 	MOVE.w	d7,d6				* else set the format string index to the end
                            	  7095: LAB_U044
01:0000E508 10316000        	  7096: 	MOVE.b	(a1,d6.w),d0		* get a character from the format string
01:0000E50C 0C000023        	  7097: 	CMPI.b	#'#',d0			* compare it with "#" special format character
01:0000E510 671E            	  7098: 	BEQ.s		LAB_U046			* if "#" go use the overflow character
                            	  7099: 
01:0000E512 0C000025        	  7100: 	CMPI.b	#'%',d0			* compare it with "%" special format character
01:0000E516 6718            	  7101: 	BEQ.s		LAB_U046			* if "%" go use the overflow character
                            	  7102: 
01:0000E518 0C00002C        	  7103: 	CMPI.b	#',',d0			* compare it with "," special format character
01:0000E51C 6712            	  7104: 	BEQ.s		LAB_U046			* if "," go use the overflow character
                            	  7105: 
01:0000E51E 0C00002B        	  7106: 	CMPI.b	#'+',d0			* compare it with "+" special format character
01:0000E522 670C            	  7107: 	BEQ.s		LAB_U046			* if "+" go use the overflow character
                            	  7108: 
01:0000E524 0C00002D        	  7109: 	CMPI.b	#'-',d0			* compare it with "-" special format character
01:0000E528 6706            	  7110: 	BEQ.s		LAB_U046			* if "-" go use the overflow character
                            	  7111: 
01:0000E52A 0C00002E        	  7112: 	CMPI.b	#'.',d0			* compare it with "." special format character
01:0000E52E 6602            	  7113: 	BNE.s		LAB_U048			* if not "." skip the using overflow character
                            	  7114: 
                            	  7115: LAB_U046
01:0000E530 1005            	  7116: 	MOVE.b	d5,d0				* use the overflow character
                            	  7117: LAB_U048
01:0000E532 11807000        	  7118: 	MOVE.b	d0,(a0,d7.w)		* save the character to the new format string
01:0000E536 5346            	  7119: 	SUBQ.w	#1,d6				* decrement the format string index
01:0000E538 51CFFFCE        	  7120: 	DBF		d7,LAB_U044			* decrement the count and loop if not all done
                            	  7121: 
                            	  7122: * add the new string to the previous string
                            	  7123: 
                            	  7124: LAB_U04A
01:0000E53C 41EC0006        	  7125: 	LEA		6(a4),a0			* get the descriptor pointer for string 1
01:0000E540 274C0590        	  7126: 	MOVE.l	a4,FAC1_m(a3)		* save the descriptor pointer for string 2
01:0000E544 6100F018        	  7127: 	BSR		LAB_224E			* concatenate the strings
                            	  7128: 
                            	  7129: * now check for any tail on the format string
                            	  7130: 
01:0000E548 302F0004        	  7131: 	MOVE.w	fsti(sp),d0			* get this index
01:0000E54C 6720            	  7132: 	BEQ.s		LAB_U04C			* if at start of string skip the output
                            	  7133: 
01:0000E54E 3F400006        	  7134: 	MOVE.w	d0,fsli(sp)			* save this index to the last index
01:0000E552 61000082        	  7135: 	BSR		LAB_ProcFo			* now process the format string
01:0000E556 4A02            	  7136: 	TST.b		d2				* test the special characters flag
01:0000E558 6614            	  7137: 	BNE.s		LAB_U04C			* if special characters present skip the output
                            	  7138: 
                            	  7139: * else output the new string part
                            	  7140: 
01:0000E55A 613C            	  7141: 	BSR.s		LAB_DupFmt			* duplicate the processed format string section
01:0000E55C 3F6F00040006    	  7142: 	MOVE.w	fsti(sp),fsli(sp)		* copy this index to the last index
                            	  7143: 
                            	  7144: * add the new string to the previous string
                            	  7145: 
01:0000E562 41EC0006        	  7146: 	LEA		6(a4),a0			* get the descriptor pointer for string 1
01:0000E566 274C0590        	  7147: 	MOVE.l	a4,FAC1_m(a3)		* save the descriptor pointer for string 2
01:0000E56A 6100EFF2        	  7148: 	BSR		LAB_224E			* concatenate the strings
                            	  7149: 
                            	  7150: * check for another value or end of function
                            	  7151: 
                            	  7152: LAB_U04C
01:0000E56E 101D            	  7153: 	MOVE.b	(a5)+,d0			* get the next BASIC byte
01:0000E570 B03C0029        	  7154: 	CMP.b		#')',d0			* compare with close bracket
01:0000E574 6600FDCA        	  7155: 	BNE		LAB_U002			* if not ")" go do next value
                            	  7156: 
                            	  7157: * pop the result string off the descriptor stack
                            	  7158: 
01:0000E578 204C            	  7159: 	MOVEA.l	a4,a0				* copy the result string descriptor pointer
01:0000E57A 222B0446        	  7160: 	MOVE.l	Sstorl(a3),d1		* save the bottom of string space
01:0000E57E 6100F040        	  7161: 	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  7162: 							* d0 = length, a0 = pointer
01:0000E582 27410446        	  7163: 	MOVE.l	d1,Sstorl(a3)		* restore the bottom of string space
01:0000E586 2248            	  7164: 	MOVEA.l	a0,a1				* copy the string result pointer
01:0000E588 3200            	  7165: 	MOVE.w	d0,d1				* copy the string result length
                            	  7166: 
                            	  7167: * pop the format string off the descriptor stack
                            	  7168: 
01:0000E58A 205F            	  7169: 	MOVEA.l	(sp)+,a0			* pull the format string descriptor pointer
01:0000E58C 6100F032        	  7170: 	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
                            	  7171: 							* d0 = length, a0 = pointer
                            	  7172: 
01:0000E590 508F            	  7173: 	LEA		fend(sp),sp			* dump the saved values
                            	  7174: 
                            	  7175: * push the result string back on the descriptor stack and return
                            	  7176: 
01:0000E592 2049            	  7177: 	MOVEA.l	a1,a0				* copy the result string pointer back
01:0000E594 6000EE80        	  7178: 	BRA		LAB_RTST			* push a string on the descriptor stack and
                            	  7179: 							* return. a0 = pointer, d1 = length
                            	  7180: 
                            	  7181: 
                            	  7182: *************************************************************************************
                            	  7183: *
                            	  7184: * duplicate the processed format string section
                            	  7185: 
                            	  7186: 							* make a string as long as the format string
                            	  7187: LAB_DupFmt
01:0000E598 226F0004        	  7188: 	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
01:0000E59C 3E290004        	  7189: 	MOVE.w	4(a1),d7			* get the format string length
01:0000E5A0 342F000A        	  7190: 	MOVE.w	4+fsli(sp),d2		* get the format string last index
01:0000E5A4 3C2F0008        	  7191: 	MOVE.w	4+fsti(sp),d6		* get the format string this index
01:0000E5A8 3206            	  7192: 	MOVE.w	d6,d1				* copy the format string this index
01:0000E5AA 9242            	  7193: 	SUB.w		d2,d1				* subtract the format string last index
01:0000E5AC 6202            	  7194: 	BHI.s		LAB_D002			* if > 0 skip the correction
                            	  7195: 
01:0000E5AE D247            	  7196: 	ADD.w		d7,d1				* else add the format string length as the
                            	  7197: 							* correction
                            	  7198: LAB_D002
01:0000E5B0 6100EE7E        	  7199: 	BSR		LAB_2115			* make string space d1 bytes long
                            	  7200: 							* return a0/Sutill = pointer, others unchanged
                            	  7201: 
                            	  7202: * push the new string on the descriptor stack
                            	  7203: 
01:0000E5B4 6100EE60        	  7204: 	BSR		LAB_RTST			* push a string on the descriptor stack and
                            	  7205: 							* return. a0 = pointer, d1 = length
                            	  7206: 
                            	  7207: * copy the characters from the format string
                            	  7208: 
01:0000E5B8 226F0004        	  7209: 	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
01:0000E5BC 2251            	  7210: 	MOVEA.l	(a1),a1			* get the format string pointer
01:0000E5BE 7800            	  7211: 	MOVEQ		#0,d4				* clear the new string index
                            	  7212: LAB_D00A
01:0000E5C0 11B120004000    	  7213: 	MOVE.b	(a1,d2.w),(a0,d4.w)	* get a character from the format string and
                            	  7214: 							* save it to the new string
01:0000E5C6 5244            	  7215: 	ADDQ.w	#1,d4				* increment the new string index
01:0000E5C8 5242            	  7216: 	ADDQ.w	#1,d2				* increment the format string index
01:0000E5CA BE42            	  7217: 	CMP.w		d2,d7				* compare the format index with the length
01:0000E5CC 6602            	  7218: 	BNE.s		LAB_D00E			* if not there skip the reset
                            	  7219: 
01:0000E5CE 7400            	  7220: 	MOVEQ		#0,d2				* else reset the format string index
                            	  7221: LAB_D00E
01:0000E5D0 BC42            	  7222: 	CMP.w		d2,d6				* compare the index with this index
01:0000E5D2 66EC            	  7223: 	BNE.s		LAB_D00A			* if not equal go do the next character
                            	  7224: 
01:0000E5D4 4E75            	  7225: 	RTS
                            	  7226: 
                            	  7227: 
                            	  7228: **************************************************************************************
                            	  7229: *
                            	  7230: * process the format string
                            	  7231: 
                            	  7232: LAB_ProcFo
01:0000E5D6 226F0004        	  7233: 	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
01:0000E5DA 3E290004        	  7234: 	MOVE.w	4(a1),d7			* get the format string length
01:0000E5DE 2251            	  7235: 	MOVEA.l	(a1),a1			* get the format string pointer
01:0000E5E0 3C2F000A        	  7236: 	MOVE.w	4+fsli(sp),d6		* get the format string last index
                            	  7237: 
01:0000E5E4 3F47000C        	  7238: 	MOVE.w	d7,4+fsdpi(sp)		* set the format string decimal point index
                            	  7239: *##	MOVE.w	#-1,4+fsdpi(sp)		* set the format string decimal point index
01:0000E5E8 7A00            	  7240: 	MOVEQ		#0,d5				* no decimal point
01:0000E5EA 7600            	  7241: 	MOVEQ		#0,d3				* no decimal characters
01:0000E5EC 7400            	  7242: 	MOVEQ		#0,d2				* no special characters
                            	  7243: LAB_P004
01:0000E5EE 10316000        	  7244: 	MOVE.b	(a1,d6.w),d0		* get a format string byte
                            	  7245: 
01:0000E5F2 B03C002C        	  7246: 	CMP.b		#',',d0			* compare it with ","
01:0000E5F6 6742            	  7247: 	BEQ.s		LAB_P01A			* if "," go do the next format string byte
                            	  7248: 
01:0000E5F8 B03C0023        	  7249: 	CMP.b		#'#',d0			* compare it with "#"
01:0000E5FC 6706            	  7250: 	BEQ.s		LAB_P008			* if "#" go flag special characters
                            	  7251: 
01:0000E5FE B03C0025        	  7252: 	CMP.b		#'%',d0			* compare it with "%"
01:0000E602 6608            	  7253: 	BNE.s		LAB_P00C			* if not "%" go try "+"
                            	  7254: 
                            	  7255: LAB_P008
01:0000E604 4A85            	  7256: 	TST.l		d5				* test the decimal point flag
01:0000E606 6A10            	  7257: 	BPL.s		LAB_P00E			* if no point skip counting decimal characters
                            	  7258: 
01:0000E608 5243            	  7259: 	ADDQ.w	#1,d3				* else increment the decimal character count
01:0000E60A 602E            	  7260: 	BRA.s		LAB_P01A			* go do the next character
                            	  7261: 
                            	  7262: LAB_P00C
01:0000E60C B03C002B        	  7263: 	CMP.b		#'+',d0			* compare it with "+"
01:0000E610 6706            	  7264: 	BEQ.s		LAB_P00E			* if "+" go flag special characters
                            	  7265: 
01:0000E612 B03C002D        	  7266: 	CMP.b		#'-',d0			* compare it with "-"
01:0000E616 6604            	  7267: 	BNE.s		LAB_P010			* if not "-" go check decimal point
                            	  7268: 
                            	  7269: LAB_P00E
01:0000E618 8400            	  7270: 	OR.b		d0,d2				* flag special characters
01:0000E61A 601E            	  7271: 	BRA.s		LAB_P01A			* go do the next character
                            	  7272: 
                            	  7273: LAB_P010
01:0000E61C B03C002E        	  7274: 	CMP.b		#'.',d0			* compare it with "."
01:0000E620 6614            	  7275: 	BNE.s		LAB_P018			* if not "." go check next
                            	  7276: 
                            	  7277: * "." a decimal point
                            	  7278: 
01:0000E622 4A85            	  7279: 	TST.l		d5				* if there is already a decimal point
01:0000E624 6B14            	  7280: 	BMI.s		LAB_P01A			* go do the next character
                            	  7281: 
01:0000E626 3006            	  7282: 	MOVE.w	d6,d0				* copy the decimal point index
01:0000E628 906F000A        	  7283: 	SUB.w		4+fsli(sp),d0		* calculate it from the scan start
01:0000E62C 3F40000C        	  7284: 	MOVE.w	d0,4+fsdpi(sp)		* save the decimal point index
01:0000E630 7AFF            	  7285: 	MOVEQ		#-1,d5			* flag decimal point
01:0000E632 8400            	  7286: 	OR.b		d0,d2				* flag special characters
01:0000E634 6004            	  7287: 	BRA.s		LAB_P01A			* go do the next character
                            	  7288: 
                            	  7289: * was not a special character
                            	  7290: 
                            	  7291: LAB_P018
01:0000E636 4A02            	  7292: 	TST.b		d2				* test if there have been special characters
01:0000E638 6608            	  7293: 	BNE.s		LAB_P01E			* if so exit the format string process
                            	  7294: 
                            	  7295: LAB_P01A
01:0000E63A 5246            	  7296: 	ADDQ.w	#1,d6				* increment the format string index
01:0000E63C BE46            	  7297: 	CMP.w		d6,d7				* compare it with the format string length
01:0000E63E 62AE            	  7298: 	BHI.s		LAB_P004			* if length > index go get the next character
                            	  7299: 
01:0000E640 7C00            	  7300: 	MOVEQ		#0,d6				* length = index so reset the format string
                            	  7301: 							* index
                            	  7302: LAB_P01E
01:0000E642 3F460008        	  7303: 	MOVE.w	d6,4+fsti(sp)		* save the format string this index
01:0000E646 3F43000E        	  7304: 	MOVE.w	d3,4+fsdc(sp)		* save the format string decimal characters
                            	  7305: 
01:0000E64A 4E75            	  7306: 	RTS
                            	  7307: 
                            	  7308: 
                            	  7309: *************************************************************************************
                            	  7310: *
                            	  7311: * perform BIN$()
                            	  7312: * # of leading 0s is in d1, the number is in d0
                            	  7313: 
                            	  7314: LAB_BINS
01:0000E64C B23C0021        	  7315: 	CMP.b		#$21,d1			* max + 1
01:0000E650 6400DB22        	  7316: 	BCC		LAB_FCER			* exit if too big ( > or = )
                            	  7317: 
01:0000E654 741F            	  7318: 	MOVEQ		#$1F,d2			* bit count-1
01:0000E656 41EB05B6        	  7319: 	LEA		Binss(a3),a0		* point to string
01:0000E65A 7830            	  7320: 	MOVEQ		#$30,d4			* "0" character for ADDX
                            	  7321: NextB1
01:0000E65C 7600            	  7322: 	MOVEQ		#0,d3				* clear byte
01:0000E65E E288            	  7323: 	LSR.l		#1,d0				* shift bit into Xb
01:0000E660 D704            	  7324: 	ADDX.b	d4,d3				* add carry and character to zero
01:0000E662 11832000        	  7325: 	MOVE.b	d3,(a0,d2.w)		* save character to string
01:0000E666 51CAFFF4        	  7326: 	DBF		d2,NextB1			* decrement and loop if not done
                            	  7327: 
                            	  7328: * this is the exit code and is also used by HEX$()
                            	  7329: 
                            	  7330: EndBHS
01:0000E66A 177C000005D6    	  7331: 	MOVE.b	#0,BHsend(a3)		* null terminate the string
01:0000E670 4A01            	  7332: 	TST.b		d1				* test # of characters
01:0000E672 670E            	  7333: 	BEQ.s		NextB2			* go truncate string
                            	  7334: 
01:0000E674 4481            	  7335: 	NEG.l		d1				* make -ve
01:0000E676 D2BC000005D6    	  7336: 	ADD.l		#BHsend,d1			* effectively (end-length)
01:0000E67C 41F31000        	  7337: 	LEA		0(a3,d1.w),a0		* effectively add (end-length) to pointer
01:0000E680 600E            	  7338: 	BRA.s		BinPr				* go print string
                            	  7339: 
                            	  7340: * truncate string to remove leading "0"s
                            	  7341: 
                            	  7342: NextB2
01:0000E682 1010            	  7343: 	MOVE.b	(a0),d0			* get byte
01:0000E684 670A            	  7344: 	BEQ.s		BinPr				* if null then end of string so add 1 and go
                            	  7345: 							* print it
                            	  7346: 
01:0000E686 B03C0030        	  7347: 	CMP.b		#'0',d0			* compare with "0"
01:0000E68A 660E            	  7348: 	BNE.s		GoPr				* if not "0" then go print string from here
                            	  7349: 
01:0000E68C 5248            	  7350: 	ADDQ.w	#1,a0				* else increment pointer
01:0000E68E 60F2            	  7351: 	BRA.s		NextB2			* loop always
                            	  7352: 
                            	  7353: * make fixed length output string - ignore overflows!
                            	  7354: 
                            	  7355: BinPr
01:0000E690 43EB05D6        	  7356: 	LEA		BHsend(a3),a1		* get string end
01:0000E694 B1C9            	  7357: 	CMPA.l	a1,a0				* are we at the string end
01:0000E696 6602            	  7358: 	BNE.s		GoPr				* branch if not
                            	  7359: 
01:0000E698 5348            	  7360: 	SUBQ.w	#1,a0				* else need at least one zero
                            	  7361: GoPr
01:0000E69A 6000ED34        	  7362: 	BRA		LAB_20AE			* print " terminated string to FAC1, stack & RET
                            	  7363: 
                            	  7364: 
                            	  7365: *************************************************************************************
                            	  7366: *
                            	  7367: * perform HEX$()
                            	  7368: * # of leading 0s is in d1, the number is in d0
                            	  7369: 
                            	  7370: LAB_HEXS
01:0000E69E B23C0009        	  7371: 	CMP.b		#$09,d1			* max + 1
01:0000E6A2 6400DAD0        	  7372: 	BCC		LAB_FCER			* exit if too big ( > or = )
                            	  7373: 
01:0000E6A6 7407            	  7374: 	MOVEQ		#$07,d2			* nibble count-1
01:0000E6A8 41EB05CE        	  7375: 	LEA		Hexss(a3),a0		* point to string
01:0000E6AC 7830            	  7376: 	MOVEQ		#$30,d4			* "0" character for ABCD
                            	  7377: NextH1
01:0000E6AE 1600            	  7378: 	MOVE.b	d0,d3				* copy lowest byte
01:0000E6B0 E898            	  7379: 	ROR.l		#4,d0				* shift nibble into 0-3
01:0000E6B2 C63C000F        	  7380: 	AND.b		#$0F,d3			* just this nibble
01:0000E6B6 1A03            	  7381: 	MOVE.b	d3,d5				* copy it
01:0000E6B8 DA3C00F6        	  7382: 	ADD.b		#$F6,d5			* set extend bit
01:0000E6BC C704            	  7383: 	ABCD		d4,d3				* decimal add extend and character to zero
01:0000E6BE 11832000        	  7384: 	MOVE.b	d3,(a0,d2.w)		* save character to string
01:0000E6C2 51CAFFEA        	  7385: 	DBF		d2,NextH1			* decrement and loop if not done
                            	  7386: 
01:0000E6C6 60A2            	  7387: 	BRA.s		EndBHS			* go process string
                            	  7388: 
                            	  7389: 
                            	  7390: *************************************************************************************
                            	  7391: *
                            	  7392: * ctrl-c check routine. includes limited "life" byte save for INGET routine
                            	  7393: 
                            	  7394: VEC_CC
01:0000E6C8 4A2B05E8        	  7395: 	TST.b		ccflag(a3)			* check [CTRL-C] check flag
01:0000E6CC 661E            	  7396: 	BNE.s		RTS_022			* exit if [CTRL-C] check inhibited
                            	  7397: 
01:0000E6CE 4EAB040C        	  7398: 	JSR		V_INPT(a3)			* scan input device
01:0000E6D2 640E            	  7399: 	BCC.s		LAB_FBA0			* exit if buffer empty
                            	  7400: 
01:0000E6D4 174005E9        	  7401: 	MOVE.b	d0,ccbyte(a3)		* save received byte
01:0000E6D8 177C002005EA    	  7402: 	MOVE.b	#$20,ccnull(a3)		* set "life" timer for bytes countdown
01:0000E6DE 6000DF06        	  7403: 	BRA		LAB_1636			* return to BASIC
                            	  7404: 
                            	  7405: LAB_FBA0
01:0000E6E2 4A2B05EA        	  7406: 	TST.b		ccnull(a3)			* get countdown byte
01:0000E6E6 6704            	  7407: 	BEQ.s		RTS_022			* exit if finished
                            	  7408: 
01:0000E6E8 532B05EA        	  7409: 	SUBQ.b	#1,ccnull(a3)		* else decrement countdown
                            	  7410: RTS_022
01:0000E6EC 4E75            	  7411: 	RTS
                            	  7412: 
                            	  7413: 
                            	  7414: *************************************************************************************
                            	  7415: *
                            	  7416: * get byte from input device, no waiting
                            	  7417: * returns with carry set if byte in A
                            	  7418: 
                            	  7419: INGET
01:0000E6EE 4EAB040C        	  7420: 	JSR		V_INPT(a3)			* call scan input device
01:0000E6F2 650A            	  7421: 	BCS.s		LAB_FB95			* if byte go reset timer
                            	  7422: 
01:0000E6F4 102B05EA        	  7423: 	MOVE.b	ccnull(a3),d0		* get countdown
01:0000E6F8 67F2            	  7424: 	BEQ.s		RTS_022			* exit if empty
                            	  7425: 
01:0000E6FA 102B05E9        	  7426: 	MOVE.b	ccbyte(a3),d0		* get last received byte
                            	  7427: LAB_FB95
01:0000E6FE 177C000005EA    	  7428: 	MOVE.b	#$00,ccnull(a3)		* clear timer because we got a byte
01:0000E704 003C0001        	  7429: 	ORI.b		#1,CCR			* set carry, flag we got a byte
01:0000E708 4E75            	  7430: 	RTS
                            	  7431: 
                            	  7432: 
                            	  7433: *************************************************************************************
                            	  7434: *
                            	  7435: * perform MAX()
                            	  7436: 
                            	  7437: LAB_MAX
01:0000E70A 6100E552        	  7438: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
01:0000E70E 4A2B05B5        	  7439: 	TST.b		Dtypef(a3)			* test data type
01:0000E712 6B00DA40        	  7440: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  7441: 
                            	  7442: LAB_MAXN
01:0000E716 612C            	  7443: 	BSR.s		LAB_PHFA			* push FAC1, evaluate expression,
                            	  7444: 							* pull FAC2 & compare with FAC1
01:0000E718 64FC            	  7445: 	BCC.s		LAB_MAXN			* branch if no swap to do
                            	  7446: 
01:0000E71A 6100F4B2        	  7447: 	BSR		LAB_279B			* copy FAC2 to FAC1
01:0000E71E 60F6            	  7448: 	BRA.s		LAB_MAXN			* go do next
                            	  7449: 
                            	  7450: 
                            	  7451: *************************************************************************************
                            	  7452: *
                            	  7453: * perform MIN()
                            	  7454: 
                            	  7455: LAB_MIN
01:0000E720 6100E53C        	  7456: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
01:0000E724 4A2B05B5        	  7457: 	TST.b		Dtypef(a3)			* test data type
01:0000E728 6B00DA2A        	  7458: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  7459: 
                            	  7460: LAB_MINN
01:0000E72C 6116            	  7461: 	BSR.s		LAB_PHFA			* push FAC1, evaluate expression,
                            	  7462: 							* pull FAC2 & compare with FAC1
01:0000E72E 63FC            	  7463: 	BLS.s		LAB_MINN			* branch if no swap to do
                            	  7464: 
01:0000E730 6100F49C        	  7465: 	BSR		LAB_279B			* copy FAC2 to FAC1
01:0000E734 60F6            	  7466: 	BRA.s		LAB_MINN			* go do next (branch always)
                            	  7467: 
                            	  7468: * exit routine. don't bother returning to the loop code
                            	  7469: * check for correct exit, else so syntax error
                            	  7470: 
                            	  7471: LAB_MMEC
01:0000E736 B03C0029        	  7472: 	CMP.b		#')',d0			* is it end of function?
01:0000E73A 6600DA44        	  7473: 	BNE		LAB_SNER			* if not do MAX MIN syntax error
                            	  7474: 
01:0000E73E 588F            	  7475: 	LEA		4(sp),sp			* dump return address (faster)
01:0000E740 6000E67A        	  7476: 	BRA		LAB_IGBY			* update BASIC execute pointer (to chr past ")")
                            	  7477: 							* and return
                            	  7478: 
                            	  7479: * check for next, evaluate & return or exit
                            	  7480: * this is the routine that does most of the work
                            	  7481: 
                            	  7482: LAB_PHFA
01:0000E744 6100E678        	  7483: 	BSR		LAB_GBYT			* get next BASIC byte
01:0000E748 B03C002C        	  7484: 	CMP.b		#',',d0			* is there more ?
01:0000E74C 66E8            	  7485: 	BNE.s		LAB_MMEC			* if not go do end check
                            	  7486: 
01:0000E74E 3F2B0594        	  7487: 	MOVE.w	FAC1_e(a3),-(sp)		* push exponent and sign
01:0000E752 2F2B0590        	  7488: 	MOVE.l	FAC1_m(a3),-(sp)		* push mantissa
                            	  7489: 
01:0000E756 6100E506        	  7490: 	BSR		LAB_EVEZ			* evaluate expression (no decrement)
01:0000E75A 4A2B05B5        	  7491: 	TST.b		Dtypef(a3)			* test data type
01:0000E75E 6B00D9F4        	  7492: 	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
                            	  7493: 
                            	  7494: 
                            	  7495: 							* pop FAC2 (MAX/MIN expression so far)
01:0000E762 275F0598        	  7496: 	MOVE.l	(sp)+,FAC2_m(a3)		* pop mantissa
                            	  7497: 
01:0000E766 301F            	  7498: 	MOVE.w	(sp)+,d0			* pop exponent and sign
01:0000E768 3740059C        	  7499: 	MOVE.w	d0,FAC2_e(a3)		* save exponent and sign
01:0000E76C 176B0595059E    	  7500: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* get FAC1 sign
01:0000E772 B12B059E        	  7501: 	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
01:0000E776 6000F4C2        	  7502: 	BRA		LAB_27FA			* compare FAC1 with FAC2 & return
                            	  7503: 							* returns d0=+1 Cb=0 if FAC1 > FAC2
                            	  7504: 							* returns d0= 0 Cb=0 if FAC1 = FAC2
                            	  7505: 							* returns d0=-1 Cb=1 if FAC1 < FAC2
                            	  7506: 
                            	  7507: 
                            	  7508: *************************************************************************************
                            	  7509: *
                            	  7510: * perform WIDTH
                            	  7511: 
                            	  7512: LAB_WDTH
01:0000E77A B03C002C        	  7513: 	CMP.b		#',',d0			* is next byte ","
01:0000E77E 672C            	  7514: 	BEQ.s		LAB_TBSZ			* if so do tab size
                            	  7515: 
01:0000E780 6100EF9A        	  7516: 	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
01:0000E784 4A00            	  7517: 	TST.b		d0				* test result
01:0000E786 6712            	  7518: 	BEQ.s		LAB_NSTT			* branch if set for infinite line
                            	  7519: 
01:0000E788 B03C0010        	  7520: 	CMP.b		#$10,d0			* else make min width = 16d
01:0000E78C 6500D9E6        	  7521: 	BCS		LAB_FCER			* if less do function call error & exit
                            	  7522: 
                            	  7523: * this next compare ensures that we can't exit WIDTH via an error leaving the
                            	  7524: * tab size greater than the line length.
                            	  7525: 
01:0000E790 B02B05E2        	  7526: 	CMP.b		TabSiz(a3),d0		* compare with tab size
01:0000E794 6404            	  7527: 	BCC.s		LAB_NSTT			* branch if >= tab size
                            	  7528: 
01:0000E796 174005E2        	  7529: 	MOVE.b	d0,TabSiz(a3)		* else make tab size = terminal width
                            	  7530: LAB_NSTT
01:0000E79A 174005E6        	  7531: 	MOVE.b	d0,TWidth(a3)		* set the terminal width
01:0000E79E 6100E61E        	  7532: 	BSR		LAB_GBYT			* get BASIC byte back
01:0000E7A2 672C            	  7533: 	BEQ.s		WExit				* exit if no following
                            	  7534: 
01:0000E7A4 B03C002C        	  7535: 	CMP.b		#',',d0			* else is it ","
01:0000E7A8 6600D9D6        	  7536: 	BNE		LAB_SNER			* if not do syntax error
                            	  7537: 
                            	  7538: LAB_TBSZ
01:0000E7AC 6100EF6A        	  7539: 	BSR		LAB_SGBY			* increment and get byte, result in d0 and Itemp
01:0000E7B0 4A00            	  7540: 	TST.b		d0				* test TAB size
01:0000E7B2 6B00D9C0        	  7541: 	BMI		LAB_FCER			* if >127 do function call error & exit
                            	  7542: 
01:0000E7B6 B03C0001        	  7543: 	CMP.b		#1,d0				* compare with min-1
01:0000E7BA 6500D9B8        	  7544: 	BCS		LAB_FCER			* if <=1 do function call error & exit
                            	  7545: 
01:0000E7BE 122B05E6        	  7546: 	MOVE.b	TWidth(a3),d1		* set flags for width
01:0000E7C2 6708            	  7547: 	BEQ.s		LAB_SVTB			* skip check if infinite line
                            	  7548: 
01:0000E7C4 B02B05E6        	  7549: 	CMP.b		TWidth(a3),d0		* compare TAB with width
01:0000E7C8 6E00D9AA        	  7550: 	BGT		LAB_FCER			* branch if too big
                            	  7551: 
                            	  7552: LAB_SVTB
01:0000E7CC 174005E2        	  7553: 	MOVE.b	d0,TabSiz(a3)		* save TAB size
                            	  7554: 
                            	  7555: * calculate tab column limit from TAB size. The Iclim is set to the last tab
                            	  7556: * position on a line that still has at least one whole tab width between it
                            	  7557: * and the end of the line.
                            	  7558: 
                            	  7559: WExit
01:0000E7D0 102B05E6        	  7560: 	MOVE.b	TWidth(a3),d0		* get width
01:0000E7D4 670A            	  7561: 	BEQ.s		LAB_WDLP			* branch if infinite line
                            	  7562: 
01:0000E7D6 B02B05E2        	  7563: 	CMP.b		TabSiz(a3),d0		* compare with tab size
01:0000E7DA 6404            	  7564: 	BCC.s		LAB_WDLP			* branch if >= tab size
                            	  7565: 
01:0000E7DC 174005E2        	  7566: 	MOVE.b	d0,TabSiz(a3)		* else make tab size = terminal width
                            	  7567: LAB_WDLP
01:0000E7E0 902B05E2        	  7568: 	SUB.b		TabSiz(a3),d0		* subtract tab size
01:0000E7E4 64FA            	  7569: 	BCC.s		LAB_WDLP			* loop while no borrow
                            	  7570: 
01:0000E7E6 D02B05E2        	  7571: 	ADD.b		TabSiz(a3),d0		* add tab size back
01:0000E7EA D02B05E2        	  7572: 	ADD.b		TabSiz(a3),d0		* add tab size back again
                            	  7573: 
01:0000E7EE 4400            	  7574: 	NEG.b		d0				* make -ve
01:0000E7F0 D02B05E6        	  7575: 	ADD.b		TWidth(a3),d0		* subtract remainder from width
01:0000E7F4 174005E7        	  7576: 	MOVE.b	d0,Iclim(a3)		* save tab column limit
                            	  7577: RTS_023
01:0000E7F8 4E75            	  7578: 	RTS
                            	  7579: 
                            	  7580: 
                            	  7581: *************************************************************************************
                            	  7582: *
                            	  7583: * perform SQR()
                            	  7584: 
                            	  7585: * d0 is number to find the root of
                            	  7586: * d1 is the root result
                            	  7587: * d2 is the remainder
                            	  7588: * d3 is a counter
                            	  7589: * d4 is temp
                            	  7590: 
                            	  7591: LAB_SQR
01:0000E7FA 4A2B0595        	  7592: 	TST.b		FAC1_s(a3)			* test FAC1 sign
01:0000E7FE 6B00D974        	  7593: 	BMI		LAB_FCER			* if -ve do function call error
                            	  7594: 
01:0000E802 4A2B0594        	  7595: 	TST.b		FAC1_e(a3)			* test exponent
01:0000E806 67F0            	  7596: 	BEQ.s		RTS_023			* exit if zero
                            	  7597: 
01:0000E808 48E77800        	  7598: 	MOVEM.l	d1-d4,-(sp)			* save registers
01:0000E80C 202B0590        	  7599: 	MOVE.l	FAC1_m(a3),d0		* copy FAC1
01:0000E810 7400            	  7600: 	MOVEQ		#0,d2				* clear remainder
01:0000E812 2202            	  7601: 	MOVE.l	d2,d1				* clear root
                            	  7602: 
01:0000E814 761F            	  7603: 	MOVEQ		#$1F,d3			* $1F for DBF, 64 pairs of bits to
                            	  7604: 							* do for a 32 bit result
01:0000E816 082B00000594    	  7605: 	BTST		#0,FAC1_e(a3)		* test exponent odd/even
01:0000E81C 6606            	  7606: 	BNE.s		LAB_SQE2			* if odd only 1 shift first time
                            	  7607: 
                            	  7608: LAB_SQE1
01:0000E81E D080            	  7609: 	ADD.l		d0,d0				* shift highest bit of number ..
01:0000E820 D582            	  7610: 	ADDX.l	d2,d2				* .. into remainder .. never overflows
01:0000E822 D281            	  7611: 	ADD.l		d1,d1				* root = root * 2 .. never overflows
                            	  7612: LAB_SQE2
01:0000E824 D080            	  7613: 	ADD.l		d0,d0				* shift highest bit of number ..
01:0000E826 D582            	  7614: 	ADDX.l	d2,d2				* .. into remainder .. never overflows
                            	  7615: 
01:0000E828 2801            	  7616: 	MOVE.l	d1,d4				* copy root
01:0000E82A D884            	  7617: 	ADD.l		d4,d4				* 2n
01:0000E82C 5284            	  7618: 	ADDQ.l	#1,d4				* 2n+1
                            	  7619: 
01:0000E82E B484            	  7620: 	CMP.l		d4,d2				* compare 2n+1 to remainder
01:0000E830 6504            	  7621: 	BCS.s		LAB_SQNS			* skip sub if remainder smaller
                            	  7622: 
01:0000E832 9484            	  7623: 	SUB.l		d4,d2				* subtract temp from remainder
01:0000E834 5281            	  7624: 	ADDQ.l	#1,d1				* increment root
                            	  7625: LAB_SQNS
01:0000E836 51CBFFE6        	  7626: 	DBF		d3,LAB_SQE1			* loop if not all done
                            	  7627: 
01:0000E83A 27410590        	  7628: 	MOVE.l	d1,FAC1_m(a3)		* save result mantissa
01:0000E83E 102B0594        	  7629: 	MOVE.b	FAC1_e(a3),d0		* get exponent (d0 is clear here)
01:0000E842 907C0080        	  7630: 	SUB.w		#$80,d0			* normalise
01:0000E846 E248            	  7631: 	LSR.w		#1,d0				* /2
01:0000E848 6402            	  7632: 	BCC.s		LAB_SQNA			* skip increment if carry clear
                            	  7633: 
01:0000E84A 5240            	  7634: 	ADDQ.w	#1,d0				* add bit zero back in (allow for half shift)
                            	  7635: LAB_SQNA
01:0000E84C D07C0080        	  7636: 	ADD.w		#$80,d0			* re-bias to $80
01:0000E850 17400594        	  7637: 	MOVE.b	d0,FAC1_e(a3)		* save it
01:0000E854 4CDF001E        	  7638: 	MOVEM.l	(sp)+,d1-d4			* restore registers
01:0000E858 6000F0B2        	  7639: 	BRA		LAB_24D5			* normalise FAC1 & return
                            	  7640: 
                            	  7641: 
                            	  7642: *************************************************************************************
                            	  7643: *
                            	  7644: * perform VARPTR()
                            	  7645: 
                            	  7646: LAB_VARPTR
01:0000E85C 101D            	  7647: 	MOVE.b	(a5)+,d0			* increment pointer
                            	  7648: LAB_VARCALL
01:0000E85E 6100E76A        	  7649: 	BSR		LAB_GVAR			* get variable address in a0
01:0000E862 6100E546        	  7650: 	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
01:0000E866 2008            	  7651: 	MOVE.l	a0,d0				* copy the variable address
01:0000E868 6000EA50        	  7652: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  7653: 
                            	  7654: 
                            	  7655: *************************************************************************************
                            	  7656: *
                            	  7657: * perform RAMBASE
                            	  7658: 
                            	  7659: LAB_RAM
01:0000E86C 41EB0400        	  7660: 	LEA		ram_base(a3),a0		* get start of EhBASIC RAM
01:0000E870 2008            	  7661: 	MOVE.l	a0,d0				* copy it
01:0000E872 6000EA46        	  7662: 	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
                            	  7663: 
                            	  7664: 
                            	  7665: *************************************************************************************
                            	  7666: *
                            	  7667: * perform PI
                            	  7668: 
                            	  7669: LAB_PI
01:0000E876 277CC90FDAA20590	  7670: 	MOVE.l	#$C90FDAA2,FAC1_m(a3)	* pi mantissa (32 bit)
01:0000E87E 377C82000594    	  7671: 	MOVE.w	#$8200,FAC1_e(a3)		* pi exponent and sign
01:0000E884 4E75            	  7672: 	RTS
                            	  7673: 
                            	  7674: 
                            	  7675: *************************************************************************************
                            	  7676: *
                            	  7677: * perform TWOPI
                            	  7678: 
                            	  7679: LAB_TWOPI
01:0000E886 277CC90FDAA20590	  7680: 	MOVE.l	#$C90FDAA2,FAC1_m(a3)	* 2pi mantissa (32 bit)
01:0000E88E 377C83000594    	  7681: 	MOVE.w	#$8300,FAC1_e(a3)		* 2pi exponent and sign
01:0000E894 4E75            	  7682: 	RTS
                            	  7683: 
                            	  7684: 
                            	  7685: *************************************************************************************
                            	  7686: *
                            	  7687: * get ASCII string equivalent into FAC1 as integer32 or float
                            	  7688: 
                            	  7689: * entry is with a5 pointing to the first character of the string
                            	  7690: * exit with a5 pointing to the first character after the string
                            	  7691: 
                            	  7692: * d0 is character
                            	  7693: * d1 is mantissa
                            	  7694: * d2 is partial and table mantissa
                            	  7695: * d3 is mantissa exponent (decimal & binary)
                            	  7696: * d4 is decimal exponent
                            	  7697: 
                            	  7698: * get FAC1 from string
                            	  7699: * this routine now handles hex and binary values from strings
                            	  7700: * starting with "$" and "%" respectively
                            	  7701: 
                            	  7702: LAB_2887
01:0000E896 48E77C00        	  7703: 	MOVEM.l	d1-d5,-(sp)			* save registers
01:0000E89A 7200            	  7704: 	MOVEQ		#$00,d1			* clear temp accumulator
01:0000E89C 2601            	  7705: 	MOVE.l	d1,d3				* set mantissa decimal exponent count
01:0000E89E 2801            	  7706: 	MOVE.l	d1,d4				* clear decimal exponent
01:0000E8A0 17410595        	  7707: 	MOVE.b	d1,FAC1_s(a3)		* clear sign byte
01:0000E8A4 174105B5        	  7708: 	MOVE.b	d1,Dtypef(a3)		* set float data type
01:0000E8A8 174105AF        	  7709: 	MOVE.b	d1,expneg(a3)		* clear exponent sign
01:0000E8AC 6100E510        	  7710: 	BSR		LAB_GBYT			* get first byte back
01:0000E8B0 653C            	  7711: 	BCS.s		LAB_28FE			* go get floating if 1st character numeric
                            	  7712: 
01:0000E8B2 B03C002D        	  7713: 	CMP.b		#'-',d0			* or is it -ve number
01:0000E8B6 6608            	  7714: 	BNE.s		LAB_289A			* branch if not
                            	  7715: 
01:0000E8B8 177C00FF0595    	  7716: 	MOVE.b	#$FF,FAC1_s(a3)		* set sign byte
01:0000E8BE 6006            	  7717: 	BRA.s		LAB_289C			* now go scan & check for hex/bin/int
                            	  7718: 
                            	  7719: LAB_289A
                            	  7720: 							* first character wasn't numeric or -
01:0000E8C0 B03C002B        	  7721: 	CMP.b		#'+',d0			* compare with '+'
01:0000E8C4 6606            	  7722: 	BNE.s		LAB_289D			* branch if not '+' (go check for '.'/hex/binary
                            	  7723: 							* /integer)
                            	  7724: 	
                            	  7725: LAB_289C
                            	  7726: 							* was "+" or "-" to start, so get next character
01:0000E8C6 6100E4F4        	  7727: 	BSR		LAB_IGBY			* increment & scan memory
01:0000E8CA 6522            	  7728: 	BCS.s		LAB_28FE			* branch if numeric character
                            	  7729: 
                            	  7730: LAB_289D
01:0000E8CC B03C002E        	  7731: 	CMP.b		#'.',d0			* else compare with '.'
01:0000E8D0 67000092        	  7732: 	BEQ		LAB_2904			* branch if '.'
                            	  7733: 
                            	  7734: 							* code here for hex/binary/integer numbers
01:0000E8D4 B03C0024        	  7735: 	CMP.b		#'$',d0			* compare with '$'
01:0000E8D8 6700010A        	  7736: 	BEQ		LAB_CHEX			* branch if '$'
                            	  7737: 
01:0000E8DC B03C0025        	  7738: 	CMP.b		#'%',d0			* else compare with '%'
01:0000E8E0 67000164        	  7739: 	BEQ		LAB_CBIN			* branch if '%'
                            	  7740: 
01:0000E8E4 6000008C        	  7741: 	BRA		LAB_2Y01			* not #.$%& so return 0
                            	  7742: 
                            	  7743: LAB_28FD
01:0000E8E8 6100E4D2        	  7744: 	BSR		LAB_IGBY			* get next character
01:0000E8EC 646C            	  7745: 	BCC.s		LAB_2902			* exit loop if not a digit
                            	  7746: 
                            	  7747: LAB_28FE
01:0000E8EE 610001A8        	  7748: 	BSR		d1x10				* multiply d1 by 10 and add character
01:0000E8F2 64F4            	  7749: 	BCC.s		LAB_28FD			* loop for more if no overflow
                            	  7750: 
                            	  7751: LAB_28FF
                            	  7752: 							* overflowed mantissa, count 10s exponent
01:0000E8F4 5283            	  7753: 	ADDQ.l	#1,d3				* increment mantissa decimal exponent count
01:0000E8F6 6100E4C4        	  7754: 	BSR		LAB_IGBY			* get next character
01:0000E8FA 65F8            	  7755: 	BCS.s		LAB_28FF			* loop while numeric character
                            	  7756: 
                            	  7757: 							* done overflow, now flush fraction or do E
01:0000E8FC B03C002E        	  7758: 	CMP.b		#'.',d0			* else compare with '.'
01:0000E900 6606            	  7759: 	BNE.s		LAB_2901			* branch if not '.'
                            	  7760: 
                            	  7761: LAB_2900
                            	  7762: 							* flush remaining fraction digits
01:0000E902 6100E4B8        	  7763: 	BSR		LAB_IGBY			* get next character
01:0000E906 65FA            	  7764: 	BCS		LAB_2900			* loop while numeric character
                            	  7765: 
                            	  7766: LAB_2901
                            	  7767: 							* done number, only (possible) exponent remains
01:0000E908 B03C0045        	  7768: 	CMP.b		#'E',d0			* else compare with 'E'
01:0000E90C 6664            	  7769: 	BNE.s		LAB_2Y01			* if not 'E' all done, go evaluate
                            	  7770: 
                            	  7771: 							* process exponent
01:0000E90E 6100E4AC        	  7772: 	BSR		LAB_IGBY			* get next character
01:0000E912 6528            	  7773: 	BCS.s		LAB_2X04			* branch if digit
                            	  7774: 
01:0000E914 B03C002D        	  7775: 	CMP.b		#'-',d0			* or is it -ve number
01:0000E918 6706            	  7776: 	BEQ.s		LAB_2X01			* branch if so
                            	  7777: 
01:0000E91A B03C00B3        	  7778: 	CMP.b		#TK_MINUS,d0		* or is it -ve number
01:0000E91E 6608            	  7779: 	BNE.s		LAB_2X02			* branch if not
                            	  7780: 
                            	  7781: LAB_2X01
01:0000E920 177C00FF05AF    	  7782: 	MOVE.b	#$FF,expneg(a3)		* set exponent sign
01:0000E926 600E            	  7783: 	BRA.s		LAB_2X03			* now go scan & check exponent
                            	  7784: 
                            	  7785: LAB_2X02
01:0000E928 B03C002B        	  7786: 	CMP.b		#'+',d0			* or is it +ve number
01:0000E92C 6708            	  7787: 	BEQ.s		LAB_2X03			* branch if so
                            	  7788: 
01:0000E92E B03C00B2        	  7789: 	CMP.b		#TK_PLUS,d0			* or is it +ve number
01:0000E932 6600D84C        	  7790: 	BNE		LAB_SNER			* wasn't - + TK_MINUS TK_PLUS or # so do error
                            	  7791: 
                            	  7792: LAB_2X03
01:0000E936 6100E484        	  7793: 	BSR		LAB_IGBY			* get next character
01:0000E93A 6436            	  7794: 	BCC.s		LAB_2Y01			* if not digit all done, go evaluate
                            	  7795: LAB_2X04
01:0000E93C C8FC000A        	  7796: 	MULU		#10,d4			* multiply decimal exponent by 10
01:0000E940 C0BC000000FF    	  7797: 	AND.l		#$FF,d0			* mask character
01:0000E946 903C0030        	  7798: 	SUB.b		#'0',d0			* convert to value
01:0000E94A D880            	  7799: 	ADD.l		d0,d4				* add to decimal exponent
01:0000E94C B83C0030        	  7800: 	CMP.b		#48,d4			* compare with decimal exponent limit+10
01:0000E950 6FE4            	  7801: 	BLE.s		LAB_2X03			* loop if no overflow/underflow
                            	  7802: 
                            	  7803: LAB_2X05
                            	  7804: 							* exponent value has overflowed
01:0000E952 6100E468        	  7805: 	BSR		LAB_IGBY			* get next character
01:0000E956 65FA            	  7806: 	BCS.s		LAB_2X05			* loop while numeric digit
                            	  7807: 
01:0000E958 6018            	  7808: 	BRA.s		LAB_2Y01			* all done, go evaluate
                            	  7809: 
                            	  7810: LAB_2902
01:0000E95A B03C002E        	  7811: 	CMP.b		#'.',d0			* else compare with '.'
01:0000E95E 6704            	  7812: 	BEQ.s		LAB_2904			* branch if was '.'
                            	  7813: 
01:0000E960 60A6            	  7814: 	BRA.s		LAB_2901			* branch if not '.' (go check/do 'E')
                            	  7815: 
                            	  7816: LAB_2903
01:0000E962 5383            	  7817: 	SUBQ.l	#1,d3				* decrement mantissa decimal exponent
                            	  7818: LAB_2904
                            	  7819: 							* was dp so get fraction part
01:0000E964 6100E456        	  7820: 	BSR		LAB_IGBY			* get next character
01:0000E968 649E            	  7821: 	BCC.s		LAB_2901			* exit loop if not a digit (go check/do 'E')
                            	  7822: 
01:0000E96A 6100012C        	  7823: 	BSR		d1x10				* multiply d1 by 10 and add character
01:0000E96E 64F2            	  7824: 	BCC.s		LAB_2903			* loop for more if no overflow
                            	  7825: 
01:0000E970 6090            	  7826: 	BRA.s		LAB_2900			* else go flush remaining fraction part
                            	  7827: 
                            	  7828: LAB_2Y01
                            	  7829: 							* now evaluate result
01:0000E972 4A2B05AF        	  7830: 	TST.b		expneg(a3)			* test exponent sign
01:0000E976 6A02            	  7831: 	BPL.s		LAB_2Y02			* branch if sign positive
                            	  7832: 
01:0000E978 4484            	  7833: 	NEG.l		d4				* negate decimal exponent
                            	  7834: LAB_2Y02
01:0000E97A D883            	  7835: 	ADD.l		d3,d4				* add mantissa decimal exponent
01:0000E97C 7620            	  7836: 	MOVEQ		#32,d3			* set up max binary exponent
01:0000E97E 4A81            	  7837: 	TST.l		d1				* test mantissa
01:0000E980 6752            	  7838: 	BEQ.s		LAB_rtn0			* if mantissa=0 return 0
                            	  7839: 
01:0000E982 6B08            	  7840: 	BMI.s		LAB_2Y04			* branch if already mormalised
                            	  7841: 
01:0000E984 5383            	  7842: 	SUBQ.l	#1,d3				* decrement bianry exponent for DBMI loop
                            	  7843: LAB_2Y03
01:0000E986 D281            	  7844: 	ADD.l		d1,d1				* shift mantissa
01:0000E988 5BCBFFFC        	  7845: 	DBMI		d3,LAB_2Y03			* decrement & loop if not normalised
                            	  7846: 
                            	  7847: 							* ensure not too big or small
                            	  7848: LAB_2Y04
01:0000E98C B8BC00000026    	  7849: 	CMP.l		#38,d4			* compare decimal exponent with max exponent
01:0000E992 6E00D7DC        	  7850: 	BGT		LAB_OFER			* if greater do overflow error and warm start
                            	  7851: 
01:0000E996 B8BCFFFFFFDA    	  7852: 	CMP.l		#-38,d4			* compare decimal exponent with min exponent
01:0000E99C 6D34            	  7853: 	BLT.s		LAB_ret0			* if less just return zero
                            	  7854: 
01:0000E99E 4484            	  7855: 	NEG.l		d4				* negate decimal exponent to go right way
01:0000E9A0 C9FC0006        	  7856: 	MULS		#6,d4				* 6 bytes per entry
01:0000E9A4 2F08            	  7857: 	MOVE.l	a0,-(sp)			* save register
01:0000E9A6 41FA0210        	  7858: 	LEA		LAB_P_10(pc),a0		* point to table
01:0000E9AA 17704000059C    	  7859: 	MOVE.b	(a0,d4.w),FAC2_e(a3)	* copy exponent for multiply
01:0000E9B0 277040020598    	  7860: 	MOVE.l	2(a0,d4.w),FAC2_m(a3)	* copy table mantissa
01:0000E9B6 205F            	  7861: 	MOVE.l	(sp)+,a0			* restore register
                            	  7862: 
01:0000E9B8 0A030080        	  7863: 	EORI.b	#$80,d3			* normalise input exponent
01:0000E9BC 27410590        	  7864: 	MOVE.l	d1,FAC1_m(a3)		* save input mantissa
01:0000E9C0 17430594        	  7865: 	MOVE.b	d3,FAC1_e(a3)		* save input exponent
01:0000E9C4 176B0595059E    	  7866: 	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* set sign as sign compare
                            	  7867: 
01:0000E9CA 4CDF003E        	  7868: 	MOVEM.l	(sp)+,d1-d5			* restore registers
01:0000E9CE 6000F064        	  7869: 	BRA		LAB_MULTIPLY		* go multiply input by table
                            	  7870: 
                            	  7871: LAB_ret0
01:0000E9D2 7200            	  7872: 	MOVEQ		#0,d1				* clear mantissa
                            	  7873: LAB_rtn0
01:0000E9D4 2601            	  7874: 	MOVE.l	d1,d3				* clear exponent
01:0000E9D6 17430594        	  7875: 	MOVE.b	d3,FAC1_e(a3)		* save exponent
01:0000E9DA 27410590        	  7876: 	MOVE.l	d1,FAC1_m(a3)		* save mantissa
01:0000E9DE 4CDF003E        	  7877: 	MOVEM.l	(sp)+,d1-d5			* restore registers
01:0000E9E2 4E75            	  7878: 	RTS
                            	  7879: 
                            	  7880: 
                            	  7881: *************************************************************************************
                            	  7882: *
                            	  7883: * $ for hex add-on
                            	  7884: 
                            	  7885: * gets here if the first character was "$" for hex
                            	  7886: * get hex number
                            	  7887: 
                            	  7888: LAB_CHEX
01:0000E9E4 177C004005B5    	  7889: 	MOVE.b	#$40,Dtypef(a3)		* set integer numeric data type
01:0000E9EA 7620            	  7890: 	MOVEQ		#32,d3			* set up max binary exponent
                            	  7891: LAB_CHXX
01:0000E9EC 6100E3CE        	  7892: 	BSR		LAB_IGBY			* increment & scan memory
01:0000E9F0 6514            	  7893: 	BCS.s		LAB_ISHN			* branch if numeric character
                            	  7894: 
01:0000E9F2 803C0020        	  7895: 	OR.b		#$20,d0			* case convert, allow "A" to "F" and "a" to "f"
01:0000E9F6 903C0061        	  7896: 	SUB.b		#'a',d0			* subtract "a"
01:0000E9FA 652A            	  7897: 	BCS.s		LAB_CHX3			* exit if <"a"
                            	  7898: 
01:0000E9FC B03C0006        	  7899: 	CMP.b		#$06,d0			* compare normalised with $06 (max+1)
01:0000EA00 6424            	  7900: 	BCC.s		LAB_CHX3			* exit if >"f"
                            	  7901: 
01:0000EA02 D03C003A        	  7902: 	ADD.b		#$3A,d0			* convert to nibble+"0"
                            	  7903: LAB_ISHN
01:0000EA06 616C            	  7904: 	BSR.s		d1x16				* multiply d1 by 16 and add the character
01:0000EA08 64E2            	  7905: 	BCC.s		LAB_CHXX			* loop for more if no overflow
                            	  7906: 
                            	  7907: 							* overflowed mantissa, count 16s exponent
                            	  7908: LAB_CHX1
01:0000EA0A 5883            	  7909: 	ADDQ.l	#4,d3				* increment mantissa exponent count
01:0000EA0C 6900D762        	  7910: 	BVS		LAB_OFER			* do overflow error if overflowed
                            	  7911: 
01:0000EA10 6100E3AA        	  7912: 	BSR		LAB_IGBY			* get next character
01:0000EA14 65F4            	  7913: 	BCS.s		LAB_CHX1			* loop while numeric character
                            	  7914: 
01:0000EA16 803C0020        	  7915: 	OR.b		#$20,d0			* case convert, allow "A" to "F" and "a" to "f"
01:0000EA1A 903C0061        	  7916: 	SUB.b		#'a',d0			* subtract "a"
01:0000EA1E 6506            	  7917: 	BCS.s		LAB_CHX3			* exit if <"a"
                            	  7918: 
01:0000EA20 B03C0006        	  7919: 	CMP.b		#$06,d0			* compare normalised with $06 (max+1)
01:0000EA24 65E4            	  7920: 	BCS.s		LAB_CHX1			* loop if <="f"
                            	  7921: 
                            	  7922: 							* now return value
                            	  7923: LAB_CHX3
01:0000EA26 4A81            	  7924: 	TST.l		d1				* test mantissa
01:0000EA28 67AA            	  7925: 	BEQ.s		LAB_rtn0			* if mantissa=0 return 0
                            	  7926: 
01:0000EA2A 6B08            	  7927: 	BMI.s		LAB_exxf			* branch if already mormalised
                            	  7928: 
01:0000EA2C 5383            	  7929: 	SUBQ.l	#1,d3				* decrement bianry exponent for DBMI loop
                            	  7930: LAB_CHX2
01:0000EA2E D281            	  7931: 	ADD.l		d1,d1				* shift mantissa
01:0000EA30 5BCBFFFC        	  7932: 	DBMI		d3,LAB_CHX2			* decrement & loop if not normalised
                            	  7933: 
                            	  7934: LAB_exxf
01:0000EA34 0A030080        	  7935: 	EORI.b	#$80,d3			* normalise exponent
01:0000EA38 17430594        	  7936: 	MOVE.b	d3,FAC1_e(a3)		* save exponent
01:0000EA3C 27410590        	  7937: 	MOVE.l	d1,FAC1_m(a3)		* save mantissa
01:0000EA40 4CDF003E        	  7938: 	MOVEM.l	(sp)+,d1-d5			* restore registers
                            	  7939: RTS_024
01:0000EA44 4E75            	  7940: 	RTS
                            	  7941: 
                            	  7942: 
                            	  7943: *************************************************************************************
                            	  7944: *
                            	  7945: * % for binary add-on
                            	  7946: 
                            	  7947: * gets here if the first character was "%" for binary
                            	  7948: * get binary number
                            	  7949: 
                            	  7950: LAB_CBIN
01:0000EA46 177C004005B5    	  7951: 	MOVE.b	#$40,Dtypef(a3)		* set integer numeric data type
01:0000EA4C 7620            	  7952: 	MOVEQ		#32,d3			* set up max binary exponent
                            	  7953: LAB_CBXN
01:0000EA4E 6100E36C        	  7954: 	BSR		LAB_IGBY			* increment & scan memory
01:0000EA52 64D2            	  7955: 	BCC.s		LAB_CHX3			* if not numeric character go return value
                            	  7956: 
01:0000EA54 B03C0032        	  7957: 	CMP.b		#'2',d0			* compare with "2" (max+1)
01:0000EA58 64CC            	  7958: 	BCC.s		LAB_CHX3			* if >="2" go return value
                            	  7959: 
01:0000EA5A 2401            	  7960: 	MOVE.l	d1,d2				* copy value
01:0000EA5C 6124            	  7961: 	BSR.s		d1x02				* multiply d1 by 2 and add character
01:0000EA5E 64EE            	  7962: 	BCC.s		LAB_CBXN			* loop for more if no overflow
                            	  7963: 
                            	  7964: 							* overflowed mantissa, count 2s exponent
                            	  7965: LAB_CBX1
01:0000EA60 5283            	  7966: 	ADDQ.l	#1,d3				* increment mantissa exponent count
01:0000EA62 6900D70C        	  7967: 	BVS		LAB_OFER			* do overflow error if overflowed
                            	  7968: 
01:0000EA66 6100E354        	  7969: 	BSR		LAB_IGBY			* get next character
01:0000EA6A 64BA            	  7970: 	BCC.s		LAB_CHX3			* if not numeric character go return value
                            	  7971: 
01:0000EA6C B03C0032        	  7972: 	CMP.b		#'2',d0			* compare with "2" (max+1)
01:0000EA70 65EE            	  7973: 	BCS.s		LAB_CBX1			* loop if <"2"
                            	  7974: 
01:0000EA72 60B2            	  7975: 	BRA.s		LAB_CHX3			* if not numeric character go return value
                            	  7976: 
                            	  7977: * half way decent times 16 and times 2 with overflow checks
                            	  7978: 
                            	  7979: d1x16
01:0000EA74 2401            	  7980: 	MOVE.l	d1,d2				* copy value
01:0000EA76 D482            	  7981: 	ADD.l		d2,d2				* times two
01:0000EA78 65CA            	  7982: 	BCS.s		RTS_024			* return if overflow
                            	  7983: 
01:0000EA7A D482            	  7984: 	ADD.l		d2,d2				* times four
01:0000EA7C 65C6            	  7985: 	BCS.s		RTS_024			* return if overflow
                            	  7986: 
01:0000EA7E D482            	  7987: 	ADD.l		d2,d2				* times eight
01:0000EA80 65C2            	  7988: 	BCS.s		RTS_024			* return if overflow
                            	  7989: 
                            	  7990: d1x02
01:0000EA82 D482            	  7991: 	ADD.l		d2,d2				* times sixteen (ten/two)
01:0000EA84 65BE            	  7992: 	BCS.s		RTS_024			* return if overflow
                            	  7993: 
                            	  7994: * now add in new digit
                            	  7995: 
01:0000EA86 C0BC000000FF    	  7996: 	AND.l		#$FF,d0			* mask character
01:0000EA8C 903C0030        	  7997: 	SUB.b		#'0',d0			* convert to value
01:0000EA90 D480            	  7998: 	ADD.l		d0,d2				* add to result
01:0000EA92 65B0            	  7999: 	BCS.s		RTS_024			* return if overflow, it should never ever do
                            	  8000: 							* this
                            	  8001: 
01:0000EA94 2202            	  8002: 	MOVE.l	d2,d1				* copy result
01:0000EA96 4E75            	  8003: 	RTS
                            	  8004: 
                            	  8005: * half way decent times 10 with overflow checks
                            	  8006: 
                            	  8007: d1x10
01:0000EA98 2401            	  8008: 	MOVE.l	d1,d2				* copy value
01:0000EA9A D482            	  8009: 	ADD.l		d2,d2				* times two
01:0000EA9C 6508            	  8010: 	BCS.s		RTS_025			* return if overflow
                            	  8011: 
01:0000EA9E D482            	  8012: 	ADD.l		d2,d2				* times four
01:0000EAA0 6504            	  8013: 	BCS.s		RTS_025			* return if overflow
                            	  8014: 
01:0000EAA2 D481            	  8015: 	ADD.l		d1,d2				* times five
01:0000EAA4 64DC            	  8016: 	BCC.s		d1x02				* do times two and add in new digit if ok
                            	  8017: 
                            	  8018: RTS_025
01:0000EAA6 4E75            	  8019: 	RTS
                            	  8020: 
                            	  8021: 
                            	  8022: *************************************************************************************
                            	  8023: *
                            	  8024: * token values needed for BASIC
                            	  8025: 
                            	  8026: TK_END		EQU $80			* $80
                            	  8027: TK_FOR		EQU TK_END+1		* $81
                            	  8028: TK_NEXT		EQU TK_FOR+1		* $82
                            	  8029: TK_DATA		EQU TK_NEXT+1		* $83
                            	  8030: TK_INPUT		EQU TK_DATA+1		* $84
                            	  8031: TK_DIM		EQU TK_INPUT+1		* $85
                            	  8032: TK_READ		EQU TK_DIM+1		* $86
                            	  8033: TK_LET		EQU TK_READ+1		* $87
                            	  8034: TK_DEC		EQU TK_LET+1		* $88
                            	  8035: TK_GOTO		EQU TK_DEC+1		* $89
                            	  8036: TK_RUN		EQU TK_GOTO+1		* $8A
                            	  8037: TK_IF			EQU TK_RUN+1		* $8B
                            	  8038: TK_RESTORE		EQU TK_IF+1			* $8C
                            	  8039: TK_GOSUB		EQU TK_RESTORE+1		* $8D
                            	  8040: TK_RETURN		EQU TK_GOSUB+1		* $8E
                            	  8041: TK_REM		EQU TK_RETURN+1		* $8F
                            	  8042: TK_STOP		EQU TK_REM+1		* $90
                            	  8043: TK_ON			EQU TK_STOP+1		* $91
                            	  8044: TK_NULL		EQU TK_ON+1			* $92
                            	  8045: TK_INC		EQU TK_NULL+1		* $93
                            	  8046: TK_WAIT		EQU TK_INC+1		* $94
                            	  8047: TK_LOAD		EQU TK_WAIT+1		* $95
                            	  8048: TK_SAVE		EQU TK_LOAD+1		* $96
                            	  8049: TK_DEF		EQU TK_SAVE+1		* $97
                            	  8050: TK_POKE		EQU TK_DEF+1		* $98
                            	  8051: TK_DOKE		EQU TK_POKE+1		* $99
                            	  8052: TK_LOKE		EQU TK_DOKE+1		* $9A
                            	  8053: TK_CALL		EQU TK_LOKE+1		* $9B
                            	  8054: TK_DO			EQU TK_CALL+1		* $9C
                            	  8055: TK_LOOP		EQU TK_DO+1			* $9D
                            	  8056: TK_PRINT		EQU TK_LOOP+1		* $9E
                            	  8057: TK_CONT		EQU TK_PRINT+1		* $9F
                            	  8058: TK_LIST		EQU TK_CONT+1		* $A0
                            	  8059: TK_CLEAR		EQU TK_LIST+1		* $A1
                            	  8060: TK_NEW		EQU TK_CLEAR+1		* $A2
                            	  8061: TK_WIDTH		EQU TK_NEW+1		* $A3
                            	  8062: TK_GET		EQU TK_WIDTH+1		* $A4
                            	  8063: TK_SWAP		EQU TK_GET+1		* $A5
                            	  8064: TK_BITSET		EQU TK_SWAP+1		* $A6
                            	  8065: TK_BITCLR		EQU TK_BITSET+1		* $A7
                            	  8066: TK_TAB		EQU TK_BITCLR+1		* $A8
                            	  8067: TK_ELSE		EQU TK_TAB+1		* $A9
                            	  8068: TK_TO			EQU TK_ELSE+1		* $AA
                            	  8069: TK_FN			EQU TK_TO+1			* $AB
                            	  8070: TK_SPC		EQU TK_FN+1			* $AC
                            	  8071: TK_THEN		EQU TK_SPC+1		* $AD
                            	  8072: TK_NOT		EQU TK_THEN+1		* $AE
                            	  8073: TK_STEP		EQU TK_NOT+1		* $AF
                            	  8074: TK_UNTIL		EQU TK_STEP+1		* $B0
                            	  8075: TK_WHILE		EQU TK_UNTIL+1		* $B1
                            	  8076: TK_PLUS		EQU TK_WHILE+1		* $B2
                            	  8077: TK_MINUS		EQU TK_PLUS+1		* $B3
                            	  8078: TK_MULT		EQU TK_MINUS+1		* $B4
                            	  8079: TK_DIV		EQU TK_MULT+1		* $B5
                            	  8080: TK_POWER		EQU TK_DIV+1		* $B6
                            	  8081: TK_AND		EQU TK_POWER+1		* $B7
                            	  8082: TK_EOR		EQU TK_AND+1		* $B8
                            	  8083: TK_OR			EQU TK_EOR+1		* $B9
                            	  8084: TK_RSHIFT		EQU TK_OR+1			* $BA
                            	  8085: TK_LSHIFT		EQU TK_RSHIFT+1		* $BB
                            	  8086: TK_GT			EQU TK_LSHIFT+1		* $BC
                            	  8087: TK_EQUAL		EQU TK_GT+1			* $BD
                            	  8088: TK_LT			EQU TK_EQUAL+1		* $BE
                            	  8089: TK_SGN		EQU TK_LT+1			* $BF
                            	  8090: TK_INT		EQU TK_SGN+1		* $C0
                            	  8091: TK_ABS		EQU TK_INT+1		* $C1
                            	  8092: TK_USR		EQU TK_ABS+1		* $C2
                            	  8093: TK_FRE		EQU TK_USR+1		* $C3
                            	  8094: TK_POS		EQU TK_FRE+1		* $C4
                            	  8095: TK_SQR		EQU TK_POS+1		* $C5
                            	  8096: TK_RND		EQU TK_SQR+1		* $C6
                            	  8097: TK_LOG		EQU TK_RND+1		* $C7
                            	  8098: TK_EXP		EQU TK_LOG+1		* $C8
                            	  8099: TK_COS		EQU TK_EXP+1		* $C9
                            	  8100: TK_SIN		EQU TK_COS+1		* $CA
                            	  8101: TK_TAN		EQU TK_SIN+1		* $CB
                            	  8102: TK_ATN		EQU TK_TAN+1		* $CC
                            	  8103: TK_PEEK		EQU TK_ATN+1		* $CD
                            	  8104: TK_DEEK		EQU TK_PEEK+1		* $CE
                            	  8105: TK_LEEK		EQU TK_DEEK+1		* $CF
                            	  8106: TK_LEN		EQU TK_LEEK+1		* $D0
                            	  8107: TK_STRS		EQU TK_LEN+1		* $D1
                            	  8108: TK_VAL		EQU TK_STRS+1		* $D2
                            	  8109: TK_ASC		EQU TK_VAL+1		* $D3
                            	  8110: TK_UCASES		EQU TK_ASC+1		* $D4
                            	  8111: TK_LCASES		EQU TK_UCASES+1		* $D5
                            	  8112: TK_CHRS		EQU TK_LCASES+1		* $D6
                            	  8113: TK_HEXS		EQU TK_CHRS+1		* $D7
                            	  8114: TK_BINS		EQU TK_HEXS+1		* $D8
                            	  8115: TK_BITTST		EQU TK_BINS+1		* $D9
                            	  8116: TK_MAX		EQU TK_BITTST+1		* $DA
                            	  8117: TK_MIN		EQU TK_MAX+1		* $DB
                            	  8118: TK_RAM		EQU TK_MIN+1		* $DC
                            	  8119: TK_PI			EQU TK_RAM+1		* $DD
                            	  8120: TK_TWOPI		EQU TK_PI+1			* $DE
                            	  8121: TK_VPTR		EQU TK_TWOPI+1		* $DF
                            	  8122: TK_SADD		EQU TK_VPTR+1		* $E0
                            	  8123: TK_LEFTS		EQU TK_SADD+1		* $E1
                            	  8124: TK_RIGHTS		EQU TK_LEFTS+1		* $E2
                            	  8125: TK_MIDS		EQU TK_RIGHTS+1		* $E3
                            	  8126: TK_USINGS		EQU TK_MIDS+1		* $E4
                            	  8127: 
                            	  8128: 
                            	  8129: *************************************************************************************
                            	  8130: *
                            	  8131: * binary to unsigned decimal table
                            	  8132: 
                            	  8133: Bin2dec
01:0000EAA8 3B9ACA00        	  8134: 	dc.l	$3B9ACA00				* 1000000000
01:0000EAAC 05F5E100        	  8135: 	dc.l	$05F5E100				* 100000000
01:0000EAB0 00989680        	  8136: 	dc.l	$00989680				* 10000000
01:0000EAB4 000F4240        	  8137: 	dc.l	$000F4240				* 1000000
01:0000EAB8 000186A0        	  8138: 	dc.l	$000186A0				* 100000
01:0000EABC 00002710        	  8139: 	dc.l	$00002710				* 10000
01:0000EAC0 000003E8        	  8140: 	dc.l	$000003E8				* 1000
01:0000EAC4 00000064        	  8141: 	dc.l	$00000064				* 100
01:0000EAC8 0000000A        	  8142: 	dc.l	$0000000A				* 10
01:0000EACC 00000000        	  8143: 	dc.l	$00000000				* 0 end marker
                            	  8144: 
                            	  8145: LAB_RSED
01:0000EAD0 332E3232        	  8146: 	dc.l	$332E3232				* 858665522
                            	  8147: 
                            	  8148: * string to value exponent table
                            	  8149: 
01:0000EAD4 FF00            	  8150: 	dc.w	255<<8				* 10**38
01:0000EAD6 96769951        	  8151: 	dc.l	$96769951
01:0000EADA FB00            	  8152: 	dc.w	251<<8				* 10**37
01:0000EADC F0BDC21B        	  8153: 	dc.l	$F0BDC21B
01:0000EAE0 F800            	  8154: 	dc.w	248<<8				* 10**36
01:0000EAE2 C097CE7C        	  8155: 	dc.l	$C097CE7C
01:0000EAE6 F500            	  8156: 	dc.w	245<<8				* 10**35
01:0000EAE8 9A130B96        	  8157: 	dc.l	$9A130B96
01:0000EAEC F100            	  8158: 	dc.w	241<<8				* 10**34
01:0000EAEE F684DF57        	  8159: 	dc.l	$F684DF57
01:0000EAF2 EE00            	  8160: 	dc.w	238<<8				* 10**33
01:0000EAF4 C5371912        	  8161: 	dc.l	$C5371912
01:0000EAF8 EB00            	  8162: 	dc.w	235<<8				* 10**32
01:0000EAFA 9DC5ADA8        	  8163: 	dc.l	$9DC5ADA8
01:0000EAFE E700            	  8164: 	dc.w	231<<8				* 10**31
01:0000EB00 FC6F7C40        	  8165: 	dc.l	$FC6F7C40
01:0000EB04 E400            	  8166: 	dc.w	228<<8				* 10**30
01:0000EB06 C9F2C9CD        	  8167: 	dc.l	$C9F2C9CD
01:0000EB0A E100            	  8168: 	dc.w	225<<8				* 10**29
01:0000EB0C A18F07D7        	  8169: 	dc.l	$A18F07D7
01:0000EB10 DE00            	  8170: 	dc.w	222<<8				* 10**28
01:0000EB12 813F3979        	  8171: 	dc.l	$813F3979
01:0000EB16 DA00            	  8172: 	dc.w	218<<8				* 10**27
01:0000EB18 CECB8F28        	  8173: 	dc.l	$CECB8F28
01:0000EB1C D700            	  8174: 	dc.w	215<<8				* 10**26
01:0000EB1E A56FA5BA        	  8175: 	dc.l	$A56FA5BA
01:0000EB22 D400            	  8176: 	dc.w	212<<8				* 10**25
01:0000EB24 84595161        	  8177: 	dc.l	$84595161
01:0000EB28 D000            	  8178: 	dc.w	208<<8				* 10**24
01:0000EB2A D3C21BCF        	  8179: 	dc.l	$D3C21BCF
01:0000EB2E CD00            	  8180: 	dc.w	205<<8				* 10**23
01:0000EB30 A968163F        	  8181: 	dc.l	$A968163F
01:0000EB34 CA00            	  8182: 	dc.w	202<<8				* 10**22
01:0000EB36 87867832        	  8183: 	dc.l	$87867832
01:0000EB3A C600            	  8184: 	dc.w	198<<8				* 10**21
01:0000EB3C D8D726B7        	  8185: 	dc.l	$D8D726B7
01:0000EB40 C300            	  8186: 	dc.w	195<<8				* 10**20
01:0000EB42 AD78EBC6        	  8187: 	dc.l	$AD78EBC6
01:0000EB46 C000            	  8188: 	dc.w	192<<8				* 10**19
01:0000EB48 8AC72305        	  8189: 	dc.l	$8AC72305
01:0000EB4C BC00            	  8190: 	dc.w	188<<8				* 10**18
01:0000EB4E DE0B6B3A        	  8191: 	dc.l	$DE0B6B3A
01:0000EB52 B900            	  8192: 	dc.w	185<<8				* 10**17
01:0000EB54 B1A2BC2F        	  8193: 	dc.l	$B1A2BC2F
01:0000EB58 B600            	  8194: 	dc.w	182<<8				* 10**16
01:0000EB5A 8E1BC9BF        	  8195: 	dc.l	$8E1BC9BF
01:0000EB5E B200            	  8196: 	dc.w	178<<8				* 10**15
01:0000EB60 E35FA932        	  8197: 	dc.l	$E35FA932
01:0000EB64 AF00            	  8198: 	dc.w	175<<8				* 10**14
01:0000EB66 B5E620F5        	  8199: 	dc.l	$B5E620F5
01:0000EB6A AC00            	  8200: 	dc.w	172<<8				* 10**13
01:0000EB6C 9184E72A        	  8201: 	dc.l	$9184E72A
01:0000EB70 A800            	  8202: 	dc.w	168<<8				* 10**12
01:0000EB72 E8D4A510        	  8203: 	dc.l	$E8D4A510
01:0000EB76 A500            	  8204: 	dc.w	165<<8				* 10**11
01:0000EB78 BA43B740        	  8205: 	dc.l	$BA43B740
01:0000EB7C A200            	  8206: 	dc.w	162<<8				* 10**10
01:0000EB7E 9502F900        	  8207: 	dc.l	$9502F900
01:0000EB82 9E00            	  8208: 	dc.w	158<<8				* 10**9
01:0000EB84 EE6B2800        	  8209: 	dc.l	$EE6B2800
01:0000EB88 9B00            	  8210: 	dc.w	155<<8				* 10**8
01:0000EB8A BEBC2000        	  8211: 	dc.l	$BEBC2000
01:0000EB8E 9800            	  8212: 	dc.w	152<<8				* 10**7
01:0000EB90 98968000        	  8213: 	dc.l	$98968000
01:0000EB94 9400            	  8214: 	dc.w	148<<8				* 10**6
01:0000EB96 F4240000        	  8215: 	dc.l	$F4240000
01:0000EB9A 9100            	  8216: 	dc.w	145<<8				* 10**5
01:0000EB9C C3500000        	  8217: 	dc.l	$C3500000
01:0000EBA0 8E00            	  8218: 	dc.w	142<<8				* 10**4
01:0000EBA2 9C400000        	  8219: 	dc.l	$9C400000
01:0000EBA6 8A00            	  8220: 	dc.w	138<<8				* 10**3
01:0000EBA8 FA000000        	  8221: 	dc.l	$FA000000
01:0000EBAC 8700            	  8222: 	dc.w	135<<8				* 10**2
01:0000EBAE C8000000        	  8223: 	dc.l	$C8000000
01:0000EBB2 8400            	  8224: 	dc.w	132<<8				* 10**1
01:0000EBB4 A0000000        	  8225: 	dc.l	$A0000000
                            	  8226: LAB_P_10
01:0000EBB8 8100            	  8227: 	dc.w	129<<8				* 10**0
01:0000EBBA 80000000        	  8228: 	dc.l	$80000000
01:0000EBBE 7D00            	  8229: 	dc.w	125<<8				* 10**-1
01:0000EBC0 CCCCCCCD        	  8230: 	dc.l	$CCCCCCCD
01:0000EBC4 7A00            	  8231: 	dc.w	122<<8				* 10**-2
01:0000EBC6 A3D70A3D        	  8232: 	dc.l	$A3D70A3D
01:0000EBCA 7700            	  8233: 	dc.w	119<<8				* 10**-3
01:0000EBCC 83126E98        	  8234: 	dc.l	$83126E98
01:0000EBD0 7300            	  8235: 	dc.w	115<<8				* 10**-4
01:0000EBD2 D1B71759        	  8236: 	dc.l	$D1B71759
01:0000EBD6 7000            	  8237: 	dc.w	112<<8				* 10**-5
01:0000EBD8 A7C5AC47        	  8238: 	dc.l	$A7C5AC47
01:0000EBDC 6D00            	  8239: 	dc.w	109<<8				* 10**-6
01:0000EBDE 8637BD06        	  8240: 	dc.l	$8637BD06
01:0000EBE2 6900            	  8241: 	dc.w	105<<8				* 10**-7
01:0000EBE4 D6BF94D6        	  8242: 	dc.l	$D6BF94D6
01:0000EBE8 6600            	  8243: 	dc.w	102<<8				* 10**-8
01:0000EBEA ABCC7712        	  8244: 	dc.l	$ABCC7712
01:0000EBEE 6300            	  8245: 	dc.w	99<<8					* 10**-9
01:0000EBF0 89705F41        	  8246: 	dc.l	$89705F41
01:0000EBF4 5F00            	  8247: 	dc.w	95<<8					* 10**-10
01:0000EBF6 DBE6FECF        	  8248: 	dc.l	$DBE6FECF
01:0000EBFA 5C00            	  8249: 	dc.w	92<<8					* 10**-11
01:0000EBFC AFEBFF0C        	  8250: 	dc.l	$AFEBFF0C
01:0000EC00 5900            	  8251: 	dc.w	89<<8					* 10**-12
01:0000EC02 8CBCCC09        	  8252: 	dc.l	$8CBCCC09
01:0000EC06 5500            	  8253: 	dc.w	85<<8					* 10**-13
01:0000EC08 E12E1342        	  8254: 	dc.l	$E12E1342
01:0000EC0C 5200            	  8255: 	dc.w	82<<8					* 10**-14
01:0000EC0E B424DC35        	  8256: 	dc.l	$B424DC35
01:0000EC12 4F00            	  8257: 	dc.w	79<<8					* 10**-15
01:0000EC14 901D7CF7        	  8258: 	dc.l	$901D7CF7
01:0000EC18 4B00            	  8259: 	dc.w	75<<8					* 10**-16
01:0000EC1A E69594BF        	  8260: 	dc.l	$E69594BF
01:0000EC1E 4800            	  8261: 	dc.w	72<<8					* 10**-17
01:0000EC20 B877AA32        	  8262: 	dc.l	$B877AA32
01:0000EC24 4500            	  8263: 	dc.w	69<<8					* 10**-18
01:0000EC26 9392EE8F        	  8264: 	dc.l	$9392EE8F
01:0000EC2A 4100            	  8265: 	dc.w	65<<8					* 10**-19
01:0000EC2C EC1E4A7E        	  8266: 	dc.l	$EC1E4A7E
01:0000EC30 3E00            	  8267: 	dc.w	62<<8					* 10**-20
01:0000EC32 BCE50865        	  8268: 	dc.l	$BCE50865
01:0000EC36 3B00            	  8269: 	dc.w	59<<8					* 10**-21
01:0000EC38 971DA050        	  8270: 	dc.l	$971DA050
01:0000EC3C 3700            	  8271: 	dc.w	55<<8					* 10**-22
01:0000EC3E F1C90081        	  8272: 	dc.l	$F1C90081
01:0000EC42 3400            	  8273: 	dc.w	52<<8					* 10**-23
01:0000EC44 C16D9A01        	  8274: 	dc.l	$C16D9A01
01:0000EC48 3100            	  8275: 	dc.w	49<<8					* 10**-24
01:0000EC4A 9ABE14CD        	  8276: 	dc.l	$9ABE14CD
01:0000EC4E 2D00            	  8277: 	dc.w	45<<8					* 10**-25
01:0000EC50 F79687AE        	  8278: 	dc.l	$F79687AE
01:0000EC54 2A00            	  8279: 	dc.w	42<<8					* 10**-26
01:0000EC56 C6120625        	  8280: 	dc.l	$C6120625
01:0000EC5A 2700            	  8281: 	dc.w	39<<8					* 10**-27
01:0000EC5C 9E74D1B8        	  8282: 	dc.l	$9E74D1B8
01:0000EC60 2300            	  8283: 	dc.w	35<<8					* 10**-28
01:0000EC62 FD87B5F3        	  8284: 	dc.l	$FD87B5F3
01:0000EC66 2000            	  8285: 	dc.w	32<<8					* 10**-29
01:0000EC68 CAD2F7F5        	  8286: 	dc.l	$CAD2F7F5
01:0000EC6C 1D00            	  8287: 	dc.w	29<<8					* 10**-30
01:0000EC6E A2425FF7        	  8288: 	dc.l	$A2425FF7
01:0000EC72 1A00            	  8289: 	dc.w	26<<8					* 10**-31
01:0000EC74 81CEB32C        	  8290: 	dc.l	$81CEB32C
01:0000EC78 1600            	  8291: 	dc.w	22<<8					* 10**-32
01:0000EC7A CFB11EAD        	  8292: 	dc.l	$CFB11EAD
01:0000EC7E 1300            	  8293: 	dc.w	19<<8					* 10**-33
01:0000EC80 A6274BBE        	  8294: 	dc.l	$A6274BBE
01:0000EC84 1000            	  8295: 	dc.w	16<<8					* 10**-34
01:0000EC86 84EC3C98        	  8296: 	dc.l	$84EC3C98
01:0000EC8A 0C00            	  8297: 	dc.w	12<<8					* 10**-35
01:0000EC8C D4AD2DC0        	  8298: 	dc.l	$D4AD2DC0
01:0000EC90 0900            	  8299: 	dc.w	9<<8					* 10**-36
01:0000EC92 AA242499        	  8300: 	dc.l	$AA242499
01:0000EC96 0600            	  8301: 	dc.w	6<<8					* 10**-37
01:0000EC98 881CEA14        	  8302: 	dc.l	$881CEA14
01:0000EC9C 0200            	  8303: 	dc.w	2<<8					* 10**-38
01:0000EC9E D9C7DCED        	  8304: 	dc.l	$D9C7DCED
                            	  8305: 
                            	  8306: 
                            	  8307: *************************************************************************************
                            	  8308: *
                            	  8309: * table of constants for cordic SIN/COS/TAN calculations
                            	  8310: * constants are un normalised fractions and are atn(2^-i)/2pi
                            	  8311: 
01:0000ECA2 4DBA76D4        	  8312: 	dc.l	$4DBA76D4				* SIN/COS multiply constant
                            	  8313: TAB_SNCO
01:0000ECA6 20000000        	  8314: 	dc.l	$20000000				* atn(2^0)/2pi
01:0000ECAA 12E4051E        	  8315: 	dc.l	$12E4051E				* atn(2^1)/2pi
01:0000ECAE 09FB385C        	  8316: 	dc.l	$09FB385C				* atn(2^2)/2pi
01:0000ECB2 051111D5        	  8317: 	dc.l	$051111D5				* atn(2^3)/2pi
01:0000ECB6 028B0D44        	  8318: 	dc.l	$028B0D44				* atn(2^4)/2pi
01:0000ECBA 0145D7E2        	  8319: 	dc.l	$0145D7E2				* atn(2^5)/2pi
01:0000ECBE 00A2F61F        	  8320: 	dc.l	$00A2F61F				* atn(2^6)/2pi
01:0000ECC2 00517C56        	  8321: 	dc.l	$00517C56				* atn(2^7)/2pi
01:0000ECC6 0028BE54        	  8322: 	dc.l	$0028BE54				* atn(2^8)/2pi
01:0000ECCA 00145F2F        	  8323: 	dc.l	$00145F2F				* atn(2^9)/2pi
01:0000ECCE 000A2F99        	  8324: 	dc.l	$000A2F99				* atn(2^10)/2pi
01:0000ECD2 000517CD        	  8325: 	dc.l	$000517CD				* atn(2^11)/2pi
01:0000ECD6 00028BE7        	  8326: 	dc.l	$00028BE7				* atn(2^12)/2pi
01:0000ECDA 000145F4        	  8327: 	dc.l	$000145F4				* atn(2^13)/2pi
01:0000ECDE 0000A2FA        	  8328: 	dc.l	$0000A2FA				* atn(2^14)/2pi
01:0000ECE2 0000517D        	  8329: 	dc.l	$0000517D				* atn(2^15)/2pi
01:0000ECE6 000028BF        	  8330: 	dc.l	$000028BF				* atn(2^16)/2pi
01:0000ECEA 00001460        	  8331: 	dc.l	$00001460				* atn(2^17)/2pi
01:0000ECEE 00000A30        	  8332: 	dc.l	$00000A30				* atn(2^18)/2pi
01:0000ECF2 00000518        	  8333: 	dc.l	$00000518				* atn(2^19)/2pi
01:0000ECF6 0000028C        	  8334: 	dc.l	$0000028C				* atn(2^20)/2pi
01:0000ECFA 00000146        	  8335: 	dc.l	$00000146				* atn(2^21)/2pi
01:0000ECFE 000000A3        	  8336: 	dc.l	$000000A3				* atn(2^22)/2pi
01:0000ED02 00000052        	  8337: 	dc.l	$00000052				* atn(2^23)/2pi
01:0000ED06 00000029        	  8338: 	dc.l	$00000029				* atn(2^24)/2pi
01:0000ED0A 00000015        	  8339: 	dc.l	$00000015				* atn(2^25)/2pi
01:0000ED0E 0000000B        	  8340: 	dc.l	$0000000B				* atn(2^26)/2pi
01:0000ED12 00000006        	  8341: 	dc.l	$00000006				* atn(2^27)/2pi
01:0000ED16 00000003        	  8342: 	dc.l	$00000003				* atn(2^28)/2pi
01:0000ED1A 00000002        	  8343: 	dc.l	$00000002				* atn(2^29)/2pi
01:0000ED1E 00000001        	  8344: 	dc.l	$00000001				* atn(2^30)/2pi
01:0000ED22 00000001        	  8345: 	dc.l	$00000001				* atn(2^31)/2pi
                            	  8346: 
                            	  8347: 
                            	  8348: *************************************************************************************
                            	  8349: *
                            	  8350: * table of constants for cordic ATN calculation
                            	  8351: * constants are normalised to two integer bits and are atn(2^-i)
                            	  8352: 
                            	  8353: TAB_ATNC
01:0000ED26 1DAC6705        	  8354: 	dc.l	$1DAC6705				* atn(2^-1)
01:0000ED2A 0FADBAFD        	  8355: 	dc.l	$0FADBAFD				* atn(2^-2)
01:0000ED2E 07F56EA7        	  8356: 	dc.l	$07F56EA7				* atn(2^-3)
01:0000ED32 03FEAB77        	  8357: 	dc.l	$03FEAB77				* atn(2^-4)
01:0000ED36 01FFD55C        	  8358: 	dc.l	$01FFD55C				* atn(2^-5)
01:0000ED3A 00FFFAAB        	  8359: 	dc.l	$00FFFAAB				* atn(2^-6)
01:0000ED3E 007FFF55        	  8360: 	dc.l	$007FFF55				* atn(2^-7)
01:0000ED42 003FFFEB        	  8361: 	dc.l	$003FFFEB				* atn(2^-8)
01:0000ED46 001FFFFD        	  8362: 	dc.l	$001FFFFD				* atn(2^-9)
01:0000ED4A 00100000        	  8363: 	dc.l	$00100000				* atn(2^-10)
01:0000ED4E 00080000        	  8364: 	dc.l	$00080000				* atn(2^-11)
01:0000ED52 00040000        	  8365: 	dc.l	$00040000				* atn(2^-12)
01:0000ED56 00020000        	  8366: 	dc.l	$00020000				* atn(2^-13)
01:0000ED5A 00010000        	  8367: 	dc.l	$00010000				* atn(2^-14)
01:0000ED5E 00008000        	  8368: 	dc.l	$00008000				* atn(2^-15)
01:0000ED62 00004000        	  8369: 	dc.l	$00004000				* atn(2^-16)
01:0000ED66 00002000        	  8370: 	dc.l	$00002000				* atn(2^-17)
01:0000ED6A 00001000        	  8371: 	dc.l	$00001000				* atn(2^-18)
01:0000ED6E 00000800        	  8372: 	dc.l	$00000800				* atn(2^-19)
01:0000ED72 00000400        	  8373: 	dc.l	$00000400				* atn(2^-20)
01:0000ED76 00000200        	  8374: 	dc.l	$00000200				* atn(2^-21)
01:0000ED7A 00000100        	  8375: 	dc.l	$00000100				* atn(2^-22)
01:0000ED7E 00000080        	  8376: 	dc.l	$00000080				* atn(2^-23)
01:0000ED82 00000040        	  8377: 	dc.l	$00000040				* atn(2^-24)
01:0000ED86 00000020        	  8378: 	dc.l	$00000020				* atn(2^-25)
01:0000ED8A 00000010        	  8379: 	dc.l	$00000010				* atn(2^-26)
01:0000ED8E 00000008        	  8380: 	dc.l	$00000008				* atn(2^-27)
01:0000ED92 00000004        	  8381: 	dc.l	$00000004				* atn(2^-28)
01:0000ED96 00000002        	  8382: 	dc.l	$00000002				* atn(2^-29)
01:0000ED9A 00000001        	  8383: 	dc.l	$00000001				* atn(2^-30)
                            	  8384: LAB_1D96
01:0000ED9E 00000000        	  8385: 	dc.l	$00000000				* atn(2^-31)
01:0000EDA2 00000000        	  8386: 	dc.l	$00000000				* atn(2^-32)
                            	  8387: 
                            	  8388: * constants are normalised to n integer bits and are tanh(2^-i)
                            	  8389: n	equ	2
                            	  8390: TAB_HTHET
01:0000EDA6 2327D4F4        	  8391: 	dc.l	$2327d4f4			* atnh(2^-1) .549306144
01:0000EDAA 1058AEFA        	  8392: 	dc.l	$1058aefa			* atnh(2^-2) .255412812
01:0000EDAE 080AC48E        	  8393: 	dc.l	$080ac48e			* atnh(2^-3)
01:0000EDB2 04015622        	  8394: 	dc.l	$04015622			* atnh(2^-4)
01:0000EDB6 02002AB0        	  8395: 	dc.l	$02002ab0			* atnh(2^-5)
01:0000EDBA 01000554        	  8396: 	dc.l	$01000554			* atnh(2^-6)
01:0000EDBE 008000AA        	  8397: 	dc.l	$008000aa			* atnh(2^-7)
01:0000EDC2 00400014        	  8398: 	dc.l	$00400014			* atnh(2^-8)
01:0000EDC6 00200002        	  8399: 	dc.l	$00200002			* atnh(2^-9)
01:0000EDCA 00100000        	  8400: 	dc.l	$00100000			* atnh(2^-10)
01:0000EDCE 00080000        	  8401: 	dc.l	$00080000			* atnh(2^-11)
01:0000EDD2 00040000        	  8402: 	dc.l	$00040000			* atnh(2^-12)
01:0000EDD6 00020000        	  8403: 	dc.l	$00020000			* atnh(2^-13)
01:0000EDDA 00010000        	  8404: 	dc.l	$00010000			* atnh(2^-14)
01:0000EDDE 00008000        	  8405: 	dc.l	$00008000			* atnh(2^-15)
01:0000EDE2 00004000        	  8406: 	dc.l	$00004000			* atnh(2^-16)
01:0000EDE6 00002000        	  8407: 	dc.l	$00002000			* atnh(2^-17)
01:0000EDEA 00001000        	  8408: 	dc.l	$00001000			* atnh(2^-18)
01:0000EDEE 00000800        	  8409: 	dc.l	$00000800			* atnh(2^-19)
01:0000EDF2 00000400        	  8410: 	dc.l	$00000400			* atnh(2^-20)
01:0000EDF6 00000200        	  8411: 	dc.l	$00000200			* atnh(2^-21)
01:0000EDFA 00000100        	  8412: 	dc.l	$00000100			* atnh(2^-22)
01:0000EDFE 00000080        	  8413: 	dc.l	$00000080			* atnh(2^-23)
01:0000EE02 00000040        	  8414: 	dc.l	$00000040			* atnh(2^-24)
01:0000EE06 00000020        	  8415: 	dc.l	$00000020			* atnh(2^-25)
01:0000EE0A 00000010        	  8416: 	dc.l	$00000010			* atnh(2^-26)
01:0000EE0E 00000008        	  8417: 	dc.l	$00000008			* atnh(2^-27)
01:0000EE12 00000004        	  8418: 	dc.l	$00000004			* atnh(2^-28)
01:0000EE16 00000002        	  8419: 	dc.l	$00000002			* atnh(2^-29)
01:0000EE1A 00000001        	  8420: 	dc.l	$00000001			* atnh(2^-30)
01:0000EE1E 00000000        	  8421: 	dc.l	$00000000			* atnh(2^-31)
01:0000EE22 00000000        	  8422: 	dc.l	$00000000			* atnh(2^-32)
                            	  8423: KFCTSEED	equ	$26A3D110		* $26A3D110
                            	  8424: 
                            	  8425: 
                            	  8426: *************************************************************************************
                            	  8427: *
                            	  8428: * command vector table
                            	  8429: 
                            	  8430: LAB_CTBL
01:0000EE26 D7C8            	  8431: 	dc.w	LAB_END-LAB_CTBL			* END
01:0000EE28 D6FC            	  8432: 	dc.w	LAB_FOR-LAB_CTBL			* FOR
01:0000EE2A DD68            	  8433: 	dc.w	LAB_NEXT-LAB_CTBL			* NEXT
01:0000EE2C D91C            	  8434: 	dc.w	LAB_DATA-LAB_CTBL			* DATA
01:0000EE2E DC5C            	  8435: 	dc.w	LAB_INPUT-LAB_CTBL		* INPUT
01:0000EE30 E136            	  8436: 	dc.w	LAB_DIM-LAB_CTBL			* DIM
01:0000EE32 DC82            	  8437: 	dc.w	LAB_READ-LAB_CTBL			* READ
01:0000EE34 DA8E            	  8438: 	dc.w	LAB_LET-LAB_CTBL			* LET
01:0000EE36 DA2C            	  8439: 	dc.w	LAB_DEC-LAB_CTBL			* DEC	
01:0000EE38 D884            	  8440: 	dc.w	LAB_GOTO-LAB_CTBL			* GOTO
01:0000EE3A D84C            	  8441: 	dc.w	LAB_RUN-LAB_CTBL			* RUN
01:0000EE3C D944            	  8442: 	dc.w	LAB_IF-LAB_CTBL			* IF
01:0000EE3E D7F6            	  8443: 	dc.w	LAB_RESTORE-LAB_CTBL		* RESTORE
01:0000EE40 D872            	  8444: 	dc.w	LAB_GOSUB-LAB_CTBL		* GOSUB
01:0000EE42 D908            	  8445: 	dc.w	LAB_RETURN-LAB_CTBL		* RETURN
01:0000EE44 D9B2            	  8446: 	dc.w	LAB_REM-LAB_CTBL			* REM
01:0000EE46 D7D0            	  8447: 	dc.w	LAB_STOP-LAB_CTBL			* STOP
01:0000EE48 D9BA            	  8448: 	dc.w	LAB_ON-LAB_CTBL			* ON
01:0000EE4A D824            	  8449: 	dc.w	LAB_NULL-LAB_CTBL			* NULL
01:0000EE4C DA32            	  8450: 	dc.w	LAB_INC-LAB_CTBL			* INC	
01:0000EE4E EA34            	  8451: 	dc.w	LAB_WAIT-LAB_CTBL			* WAIT
01:0000EE50 EA22            	  8452: 	dc.w	LAB_LOAD-LAB_CTBL			* LOAD
01:0000EE52 EA26            	  8453: 	dc.w	LAB_SAVE-LAB_CTBL			* SAVE
01:0000EE54 E4C6            	  8454: 	dc.w	LAB_DEF-LAB_CTBL			* DEF
01:0000EE56 E9A2            	  8455: 	dc.w	LAB_POKE-LAB_CTBL			* POKE
01:0000EE58 E9D2            	  8456: 	dc.w	LAB_DOKE-LAB_CTBL			* DOKE
01:0000EE5A E9D8            	  8457: 	dc.w	LAB_LOKE-LAB_CTBL			* LOKE
01:0000EE5C EA2A            	  8458: 	dc.w	LAB_CALL-LAB_CTBL			* CALL
01:0000EE5E D860            	  8459: 	dc.w	LAB_DO-LAB_CTBL			* DO	
01:0000EE60 D8B2            	  8460: 	dc.w	LAB_LOOP-LAB_CTBL			* LOOP
01:0000EE62 DB22            	  8461: 	dc.w	LAB_PRINT-LAB_CTBL		* PRINT
01:0000EE64 D82E            	  8462: 	dc.w	LAB_CONT-LAB_CTBL			* CONT
01:0000EE66 D648            	  8463: 	dc.w	LAB_LIST-LAB_CTBL			* LIST
01:0000EE68 D644            	  8464: 	dc.w	LAB_CLEAR-LAB_CTBL		* CLEAR
01:0000EE6A D5F4            	  8465: 	dc.w	LAB_NEW-LAB_CTBL			* NEW
01:0000EE6C F954            	  8466: 	dc.w	LAB_WDTH-LAB_CTBL			* WIDTH
01:0000EE6E DAE8            	  8467: 	dc.w	LAB_GET-LAB_CTBL			* GET
01:0000EE70 E9EC            	  8468: 	dc.w	LAB_SWAP-LAB_CTBL			* SWAP
01:0000EE72 F4A2            	  8469: 	dc.w	LAB_BITSET-LAB_CTBL		* BITSET
01:0000EE74 F4B2            	  8470: 	dc.w	LAB_BITCLR-LAB_CTBL		* BITCLR
                            	  8471: 
                            	  8472: 
                            	  8473: *************************************************************************************
                            	  8474: *
                            	  8475: * function pre process routine table
                            	  8476: 
                            	  8477: LAB_FTPP
01:0000EE76 DFE4            	  8478: 	dc.w	LAB_PPFN-LAB_FTPP			* SGN(n)	process numeric expression in ()
01:0000EE78 DFE4            	  8479: 	dc.w	LAB_PPFN-LAB_FTPP			* INT(n)		"
01:0000EE7A DFE4            	  8480: 	dc.w	LAB_PPFN-LAB_FTPP			* ABS(n)		"
01:0000EE7C DDE8            	  8481: 	dc.w	LAB_EVEZ-LAB_FTPP			* USR(x)	process any expression
01:0000EE7E DF30            	  8482: 	dc.w	LAB_1BF7-LAB_FTPP			* FRE(x)	process any expression in ()
01:0000EE80 DF30            	  8483: 	dc.w	LAB_1BF7-LAB_FTPP			* POS(x)		"
01:0000EE82 DFE4            	  8484: 	dc.w	LAB_PPFN-LAB_FTPP			* SQR(n)	process numeric expression in ()
01:0000EE84 DFE4            	  8485: 	dc.w	LAB_PPFN-LAB_FTPP			* RND(n)		"
01:0000EE86 DFE4            	  8486: 	dc.w	LAB_PPFN-LAB_FTPP			* LOG(n)		"
01:0000EE88 DFE4            	  8487: 	dc.w	LAB_PPFN-LAB_FTPP			* EXP(n)		"
01:0000EE8A DFE4            	  8488: 	dc.w	LAB_PPFN-LAB_FTPP			* COS(n)		"
01:0000EE8C DFE4            	  8489: 	dc.w	LAB_PPFN-LAB_FTPP			* SIN(n)		"
01:0000EE8E DFE4            	  8490: 	dc.w	LAB_PPFN-LAB_FTPP			* TAN(n)		"
01:0000EE90 DFE4            	  8491: 	dc.w	LAB_PPFN-LAB_FTPP			* ATN(n)		"
01:0000EE92 DFE4            	  8492: 	dc.w	LAB_PPFN-LAB_FTPP			* PEEK(n)		"
01:0000EE94 DFE4            	  8493: 	dc.w	LAB_PPFN-LAB_FTPP			* DEEK(n)		"
01:0000EE96 DFE4            	  8494: 	dc.w	LAB_PPFN-LAB_FTPP			* LEEK(n)		"
01:0000EE98 DFD6            	  8495: 	dc.w	LAB_PPFS-LAB_FTPP			* LEN($)	process string expression in ()
01:0000EE9A DFE4            	  8496: 	dc.w	LAB_PPFN-LAB_FTPP			* STR$(n)	process numeric expression in ()
01:0000EE9C DFD6            	  8497: 	dc.w	LAB_PPFS-LAB_FTPP			* VAL($)	process string expression in ()
01:0000EE9E DFD6            	  8498: 	dc.w	LAB_PPFS-LAB_FTPP			* ASC($)		"
01:0000EEA0 DFD6            	  8499: 	dc.w	LAB_PPFS-LAB_FTPP			* UCASE$($)		"
01:0000EEA2 DFD6            	  8500: 	dc.w	LAB_PPFS-LAB_FTPP			* LCASE$($)		"
01:0000EEA4 DFE4            	  8501: 	dc.w	LAB_PPFN-LAB_FTPP			* CHR$(n)	process numeric expression in ()
01:0000EEA6 E01E            	  8502: 	dc.w	LAB_BHSS-LAB_FTPP			* HEX$()	bin/hex pre process
01:0000EEA8 E01E            	  8503: 	dc.w	LAB_BHSS-LAB_FTPP			* BIN$()		"
01:0000EEAA 0000            	  8504: 	dc.w	$0000					* BITTST()	none
01:0000EEAC 0000            	  8505: 	dc.w	$0000					* MAX()		"
01:0000EEAE 0000            	  8506: 	dc.w	$0000					* MIN()		"
01:0000EEB0 DFF2            	  8507: 	dc.w	LAB_PPBI-LAB_FTPP			* RAMBASE	advance pointer
01:0000EEB2 DFF2            	  8508: 	dc.w	LAB_PPBI-LAB_FTPP			* PI			"
01:0000EEB4 DFF2            	  8509: 	dc.w	LAB_PPBI-LAB_FTPP			* TWOPI		"
01:0000EEB6 0000            	  8510: 	dc.w	$0000					* VARPTR()	none
01:0000EEB8 0000            	  8511: 	dc.w	$0000					* SADD()		"
01:0000EEBA DFFC            	  8512: 	dc.w	LAB_LRMS-LAB_FTPP			* LEFT$()	process string expression
01:0000EEBC DFFC            	  8513: 	dc.w	LAB_LRMS-LAB_FTPP			* RIGHT$()		"
01:0000EEBE DFFC            	  8514: 	dc.w	LAB_LRMS-LAB_FTPP			* MID$()		"
01:0000EEC0 DDE8            	  8515: 	dc.w	LAB_EVEZ-LAB_FTPP			* USING$(x)	process any expression
                            	  8516: 
                            	  8517: 
                            	  8518: *************************************************************************************
                            	  8519: *
                            	  8520: * action addresses for functions
                            	  8521: 
                            	  8522: LAB_FTBL
01:0000EEC2 ED5E            	  8523: 	dc.w	LAB_SGN-LAB_FTBL			* SGN()
01:0000EEC4 EDE0            	  8524: 	dc.w	LAB_INT-LAB_FTBL			* INT()
01:0000EEC6 ED70            	  8525: 	dc.w	LAB_ABS-LAB_FTBL			* ABS()
01:0000EEC8 E97E            	  8526: 	dc.w	LAB_USR-LAB_FTBL			* USR()
01:0000EECA E3E2            	  8527: 	dc.w	LAB_FRE-LAB_FTBL			* FRE()
01:0000EECC E414            	  8528: 	dc.w	LAB_POS-LAB_FTBL			* POS()
01:0000EECE F938            	  8529: 	dc.w	LAB_SQR-LAB_FTBL			* SQR()
01:0000EED0 F228            	  8530: 	dc.w	LAB_RND-LAB_FTBL			* RND()
01:0000EED2 EA80            	  8531: 	dc.w	LAB_LOG-LAB_FTBL			* LOG()
01:0000EED4 F10E            	  8532: 	dc.w	LAB_EXP-LAB_FTBL			* EXP()
01:0000EED6 F27C            	  8533: 	dc.w	LAB_COS-LAB_FTBL			* COS()
01:0000EED8 F294            	  8534: 	dc.w	LAB_SIN-LAB_FTBL			* SIN()
01:0000EEDA F25A            	  8535: 	dc.w	LAB_TAN-LAB_FTBL			* TAN()
01:0000EEDC F354            	  8536: 	dc.w	LAB_ATN-LAB_FTBL			* ATN()
01:0000EEDE E8FA            	  8537: 	dc.w	LAB_PEEK-LAB_FTBL			* PEEK()
01:0000EEE0 E90C            	  8538: 	dc.w	LAB_DEEK-LAB_FTBL			* DEEK()
01:0000EEE2 E922            	  8539: 	dc.w	LAB_LEEK-LAB_FTBL			* LEEK()
01:0000EEE4 E83E            	  8540: 	dc.w	LAB_LENS-LAB_FTBL			* LEN()
01:0000EEE6 E50A            	  8541: 	dc.w	LAB_STRS-LAB_FTBL			* STR$()
01:0000EEE8 E882            	  8542: 	dc.w	LAB_VAL-LAB_FTBL			* VAL()
01:0000EEEA E846            	  8543: 	dc.w	LAB_ASC-LAB_FTBL			* ASC()
01:0000EEEC E7F4            	  8544: 	dc.w	LAB_UCASE-LAB_FTBL		* UCASE$()
01:0000EEEE E7C4            	  8545: 	dc.w	LAB_LCASE-LAB_FTBL		* LCASE$()
01:0000EEF0 E72C            	  8546: 	dc.w	LAB_CHRS-LAB_FTBL			* CHR$()
01:0000EEF2 F7DC            	  8547: 	dc.w	LAB_HEXS-LAB_FTBL			* HEX$()
01:0000EEF4 F78A            	  8548: 	dc.w	LAB_BINS-LAB_FTBL			* BIN$()
01:0000EEF6 F426            	  8549: 	dc.w	LAB_BTST-LAB_FTBL			* BITTST()
01:0000EEF8 F848            	  8550: 	dc.w	LAB_MAX-LAB_FTBL			* MAX()
01:0000EEFA F85E            	  8551: 	dc.w	LAB_MIN-LAB_FTBL			* MIN()
01:0000EEFC F9AA            	  8552: 	dc.w	LAB_RAM-LAB_FTBL			* RAMBASE
01:0000EEFE F9B4            	  8553: 	dc.w	LAB_PI-LAB_FTBL			* PI
01:0000EF00 F9C4            	  8554: 	dc.w	LAB_TWOPI-LAB_FTBL		* TWOPI
01:0000EF02 F99A            	  8555: 	dc.w	LAB_VARPTR-LAB_FTBL		* VARPTR()
01:0000EF04 E826            	  8556: 	dc.w	LAB_SADD-LAB_FTBL			* SADD()
01:0000EF06 E73C            	  8557: 	dc.w	LAB_LEFT-LAB_FTBL			* LEFT$()
01:0000EF08 E750            	  8558: 	dc.w	LAB_RIGHT-LAB_FTBL		* RIGHT$()
01:0000EF0A E780            	  8559: 	dc.w	LAB_MIDS-LAB_FTBL			* MID$()
01:0000EF0C F454            	  8560: 	dc.w	LAB_USINGS-LAB_FTBL		* USING$()
                            	  8561: 
                            	  8562: 
                            	  8563: *************************************************************************************
                            	  8564: *
                            	  8565: * hierarchy and action addresses for operator
                            	  8566: 
                            	  8567: LAB_OPPT
01:0000EF0E 0079            	  8568: 	dc.w	$0079					* +
01:0000EF10 E984            	  8569: 	dc.w	LAB_ADD-LAB_OPPT
01:0000EF12 0079            	  8570: 	dc.w	$0079					* -
01:0000EF14 E970            	  8571: 	dc.w	LAB_SUBTRACT-LAB_OPPT
01:0000EF16 007B            	  8572: 	dc.w	$007B					* *
01:0000EF18 EB26            	  8573: 	dc.w	LAB_MULTIPLY-LAB_OPPT
01:0000EF1A 007B            	  8574: 	dc.w	$007B					* /
01:0000EF1C EBB2            	  8575: 	dc.w	LAB_DIVIDE-LAB_OPPT
01:0000EF1E 007F            	  8576: 	dc.w	$007F					* ^
01:0000EF20 F00C            	  8577: 	dc.w	LAB_POWER-LAB_OPPT
01:0000EF22 0050            	  8578: 	dc.w	$0050					* AND
01:0000EF24 DFC6            	  8579: 	dc.w	LAB_AND-LAB_OPPT
01:0000EF26 0046            	  8580: 	dc.w	$0046					* EOR
01:0000EF28 DFB6            	  8581: 	dc.w	LAB_EOR-LAB_OPPT
01:0000EF2A 0046            	  8582: 	dc.w	$0046					* OR
01:0000EF2C DFBE            	  8583: 	dc.w	LAB_OR-LAB_OPPT
01:0000EF2E 0056            	  8584: 	dc.w	$0056					* >>
01:0000EF30 E06A            	  8585: 	dc.w	LAB_RSHIFT-LAB_OPPT
01:0000EF32 0056            	  8586: 	dc.w	$0056					* <<
01:0000EF34 E05A            	  8587: 	dc.w	LAB_LSHIFT-LAB_OPPT
01:0000EF36 007D            	  8588: 	dc.w	$007D					* >
01:0000EF38 F070            	  8589: 	dc.w	LAB_GTHAN-LAB_OPPT		* used to evaluate -n
01:0000EF3A 005A            	  8590: 	dc.w	$005A					* =
01:0000EF3C DFDC            	  8591: 	dc.w	LAB_EQUAL-LAB_OPPT		* used to evaluate NOT
01:0000EF3E 0064            	  8592: 	dc.w	$0064					* <
01:0000EF40 DFE6            	  8593: 	dc.w	LAB_LTHAN-LAB_OPPT
                            	  8594: 
                            	  8595: 
                            	  8596: *************************************************************************************
                            	  8597: *
                            	  8598: * misc constants
                            	  8599: 
                            	  8600: * This table is used in converting numbers to ASCII.
                            	  8601: * first four entries for expansion to 9.25 digits
                            	  8602: 
                            	  8603: LAB_2A9A
01:0000EF42 FFF0BDC0        	  8604: 	dc.l	$FFF0BDC0				* -1000000
01:0000EF46 000186A0        	  8605: 	dc.l	$000186A0				* 100000
01:0000EF4A FFFFD8F0        	  8606: 	dc.l	$FFFFD8F0				* -10000
01:0000EF4E 000003E8        	  8607: 	dc.l	$000003E8				* 1000
01:0000EF52 FFFFFF9C        	  8608: 	dc.l	$FFFFFF9C				* -100
01:0000EF56 0000000A        	  8609: 	dc.l	$0000000A				* 10
01:0000EF5A FFFFFFFF        	  8610: 	dc.l	$FFFFFFFF				* -1
                            	  8611: LAB_2A9B
                            	  8612: 
                            	  8613: 
                            	  8614: *************************************************************************************
                            	  8615: *
                            	  8616: * new keyword tables
                            	  8617: 
                            	  8618: * offsets to keyword tables
                            	  8619: 
                            	  8620: TAB_CHRT
01:0000EF5E 0000            	  8621: 	dc.w	TAB_STAR-TAB_STAR			* "*"	$2A
01:0000EF60 0002            	  8622: 	dc.w	TAB_PLUS-TAB_STAR			* "+"	$2B
01:0000EF62 FFFF            	  8623: 	dc.w	-1					* "," $2C no keywords
01:0000EF64 0004            	  8624: 	dc.w	TAB_MNUS-TAB_STAR			* "-"	$2D
01:0000EF66 FFFF            	  8625: 	dc.w	-1					* "." $2E no keywords
01:0000EF68 0006            	  8626: 	dc.w	TAB_SLAS-TAB_STAR			* "/"	$2F
01:0000EF6A FFFF            	  8627: 	dc.w	-1					* "0" $30 no keywords
01:0000EF6C FFFF            	  8628: 	dc.w	-1					* "1" $31 no keywords
01:0000EF6E FFFF            	  8629: 	dc.w	-1					* "2" $32 no keywords
01:0000EF70 FFFF            	  8630: 	dc.w	-1					* "3" $33 no keywords
01:0000EF72 FFFF            	  8631: 	dc.w	-1					* "4" $34 no keywords
01:0000EF74 FFFF            	  8632: 	dc.w	-1					* "5" $35 no keywords
01:0000EF76 FFFF            	  8633: 	dc.w	-1					* "6" $36 no keywords
01:0000EF78 FFFF            	  8634: 	dc.w	-1					* "7" $37 no keywords
01:0000EF7A FFFF            	  8635: 	dc.w	-1					* "8" $38 no keywords
01:0000EF7C FFFF            	  8636: 	dc.w	-1					* "9" $39 no keywords
01:0000EF7E FFFF            	  8637: 	dc.w	-1					* ";" $3A no keywords
01:0000EF80 FFFF            	  8638: 	dc.w	-1					* ":" $3B no keywords
01:0000EF82 0008            	  8639: 	dc.w	TAB_LESS-TAB_STAR			* "<"	$3C
01:0000EF84 000C            	  8640: 	dc.w	TAB_EQUL-TAB_STAR			* "="	$3D
01:0000EF86 000E            	  8641: 	dc.w	TAB_MORE-TAB_STAR			* ">"	$3E
01:0000EF88 0012            	  8642: 	dc.w	TAB_QEST-TAB_STAR			* "?"	$3F
01:0000EF8A FFFF            	  8643: 	dc.w	-1					* "@" $40 no keywords
01:0000EF8C 0014            	  8644: 	dc.w	TAB_ASCA-TAB_STAR			* "A"	$41
01:0000EF8E 0024            	  8645: 	dc.w	TAB_ASCB-TAB_STAR			* "B"	$42
01:0000EF90 003D            	  8646: 	dc.w	TAB_ASCC-TAB_STAR			* "C"	$43
01:0000EF92 0054            	  8647: 	dc.w	TAB_ASCD-TAB_STAR			* "D"	$44
01:0000EF94 006D            	  8648: 	dc.w	TAB_ASCE-TAB_STAR			* "E"	$45
01:0000EF96 007C            	  8649: 	dc.w	TAB_ASCF-TAB_STAR			* "F"	$46
01:0000EF98 0086            	  8650: 	dc.w	TAB_ASCG-TAB_STAR			* "G"	$47
01:0000EF9A 0093            	  8651: 	dc.w	TAB_ASCH-TAB_STAR			* "H"	$48
01:0000EF9C 0099            	  8652: 	dc.w	TAB_ASCI-TAB_STAR			* "I"	$49
01:0000EF9E FFFF            	  8653: 	dc.w	-1					* "J" $4A no keywords
01:0000EFA0 FFFF            	  8654: 	dc.w	-1					* "K" $4B no keywords
01:0000EFA2 00A8            	  8655: 	dc.w	TAB_ASCL-TAB_STAR			* "L"	$4C
01:0000EFA4 00D6            	  8656: 	dc.w	TAB_ASCM-TAB_STAR			* "M"	$4D
01:0000EFA6 00E4            	  8657: 	dc.w	TAB_ASCN-TAB_STAR			* "N"	$4E
01:0000EFA8 00F3            	  8658: 	dc.w	TAB_ASCO-TAB_STAR			* "O"	$4F
01:0000EFAA 00F8            	  8659: 	dc.w	TAB_ASCP-TAB_STAR			* "P"	$50
01:0000EFAC FFFF            	  8660: 	dc.w	-1					* "Q" $51 no keywords
01:0000EFAE 010D            	  8661: 	dc.w	TAB_ASCR-TAB_STAR			* "R"	$52
01:0000EFB0 0137            	  8662: 	dc.w	TAB_ASCS-TAB_STAR			* "S"	$53
01:0000EFB2 0162            	  8663: 	dc.w	TAB_ASCT-TAB_STAR			* "T"	$54
01:0000EFB4 0176            	  8664: 	dc.w	TAB_ASCU-TAB_STAR			* "U"	$55
01:0000EFB6 018E            	  8665: 	dc.w	TAB_ASCV-TAB_STAR			* "V"	$56
01:0000EFB8 019A            	  8666: 	dc.w	TAB_ASCW-TAB_STAR			* "W"	$57
01:0000EFBA FFFF            	  8667: 	dc.w	-1					* "X" $58 no keywords
01:0000EFBC FFFF            	  8668: 	dc.w	-1					* "Y" $59 no keywords
01:0000EFBE FFFF            	  8669: 	dc.w	-1					* "Z" $5A no keywords
01:0000EFC0 FFFF            	  8670: 	dc.w	-1					* "[" $5B no keywords
01:0000EFC2 FFFF            	  8671: 	dc.w	-1					* "\" $5C no keywords
01:0000EFC4 FFFF            	  8672: 	dc.w	-1					* "]" $5D no keywords
01:0000EFC6 01A9            	  8673: 	dc.w	TAB_POWR-TAB_STAR			* "^"	$5E
                            	  8674: 
                            	  8675: 
                            	  8676: *************************************************************************************
                            	  8677: *
                            	  8678: * Table of Basic keywords for LIST command
                            	  8679: * [byte]first character,[byte]remaining length -1
                            	  8680: * [word]offset from table start
                            	  8681: 
                            	  8682: LAB_KEYT
01:0000EFC8 45              	  8683: 	dc.b	'E',1
01:0000EFC9 01
01:0000EFCA 0071            	  8684: 	dc.w	KEY_END-TAB_STAR			* END
01:0000EFCC 46              	  8685: 	dc.b	'F',1
01:0000EFCD 01
01:0000EFCE 007C            	  8686: 	dc.w	KEY_FOR-TAB_STAR			* FOR
01:0000EFD0 4E              	  8687: 	dc.b	'N',2
01:0000EFD1 02
01:0000EFD2 00E7            	  8688: 	dc.w	KEY_NEXT-TAB_STAR			* NEXT
01:0000EFD4 44              	  8689: 	dc.b	'D',2
01:0000EFD5 02
01:0000EFD6 0054            	  8690: 	dc.w	KEY_DATA-TAB_STAR			* DATA
01:0000EFD8 49              	  8691: 	dc.b	'I',3
01:0000EFD9 03
01:0000EFDA 009E            	  8692: 	dc.w	KEY_INPUT-TAB_STAR		* INPUT
01:0000EFDC 44              	  8693: 	dc.b	'D',1
01:0000EFDD 01
01:0000EFDE 0063            	  8694: 	dc.w	KEY_DIM-TAB_STAR			* DIM
01:0000EFE0 52              	  8695: 	dc.b	'R',2
01:0000EFE1 02
01:0000EFE2 0114            	  8696: 	dc.w	KEY_READ-TAB_STAR			* READ
01:0000EFE4 4C              	  8697: 	dc.b	'L',1
01:0000EFE5 01
01:0000EFE6 00BE            	  8698: 	dc.w	KEY_LET-TAB_STAR			* LET
01:0000EFE8 44              	  8699: 	dc.b	'D',1
01:0000EFE9 01
01:0000EFEA 0058            	  8700: 	dc.w	KEY_DEC-TAB_STAR			* DEC
01:0000EFEC 47              	  8701: 	dc.b	'G',2
01:0000EFED 02
01:0000EFEE 0089            	  8702: 	dc.w	KEY_GOTO-TAB_STAR			* GOTO
01:0000EFF0 52              	  8703: 	dc.b	'R',1
01:0000EFF1 01
01:0000EFF2 0133            	  8704: 	dc.w	KEY_RUN-TAB_STAR			* RUN
01:0000EFF4 49              	  8705: 	dc.b	'I',0
01:0000EFF5 00
01:0000EFF6 0099            	  8706: 	dc.w	KEY_IF-TAB_STAR			* IF
01:0000EFF8 52              	  8707: 	dc.b	'R',5
01:0000EFF9 05
01:0000EFFA 011B            	  8708: 	dc.w	KEY_RESTORE-TAB_STAR		* RESTORE
01:0000EFFC 47              	  8709: 	dc.b	'G',3
01:0000EFFD 03
01:0000EFFE 008D            	  8710: 	dc.w	KEY_GOSUB-TAB_STAR		* GOSUB
01:0000F000 52              	  8711: 	dc.b	'R',4
01:0000F001 04
01:0000F002 0122            	  8712: 	dc.w	KEY_RETURN-TAB_STAR		* RETURN
01:0000F004 52              	  8713: 	dc.b	'R',1
01:0000F005 01
01:0000F006 0118            	  8714: 	dc.w	KEY_REM-TAB_STAR			* REM
01:0000F008 53              	  8715: 	dc.b	'S',2
01:0000F009 02
01:0000F00A 0154            	  8716: 	dc.w	KEY_STOP-TAB_STAR			* STOP
01:0000F00C 4F              	  8717: 	dc.b	'O',0
01:0000F00D 00
01:0000F00E 00F3            	  8718: 	dc.w	KEY_ON-TAB_STAR			* ON
01:0000F010 4E              	  8719: 	dc.b	'N',2
01:0000F011 02
01:0000F012 00EE            	  8720: 	dc.w	KEY_NULL-TAB_STAR			* NULL
01:0000F014 49              	  8721: 	dc.b	'I',1
01:0000F015 01
01:0000F016 009B            	  8722: 	dc.w	KEY_INC-TAB_STAR			* INC
01:0000F018 57              	  8723: 	dc.b	'W',2
01:0000F019 02
01:0000F01A 019A            	  8724: 	dc.w	KEY_WAIT-TAB_STAR			* WAIT
01:0000F01C 4C              	  8725: 	dc.b	'L',2
01:0000F01D 02
01:0000F01E 00C5            	  8726: 	dc.w	KEY_LOAD-TAB_STAR			* LOAD
01:0000F020 53              	  8727: 	dc.b	'S',2
01:0000F021 02
01:0000F022 013C            	  8728: 	dc.w	KEY_SAVE-TAB_STAR			* SAVE
01:0000F024 44              	  8729: 	dc.b	'D',1
01:0000F025 01
01:0000F026 0060            	  8730: 	dc.w	KEY_DEF-TAB_STAR			* DEF
01:0000F028 50              	  8731: 	dc.b	'P',2
01:0000F029 02
01:0000F02A 00FF            	  8732: 	dc.w	KEY_POKE-TAB_STAR			* POKE
01:0000F02C 44              	  8733: 	dc.b	'D',2
01:0000F02D 02
01:0000F02E 0066            	  8734: 	dc.w	KEY_DOKE-TAB_STAR			* DOKE
01:0000F030 4C              	  8735: 	dc.b	'L',2
01:0000F031 02
01:0000F032 00CD            	  8736: 	dc.w	KEY_LOKE-TAB_STAR			* LOKE
01:0000F034 43              	  8737: 	dc.b	'C',2
01:0000F035 02
01:0000F036 003D            	  8738: 	dc.w	KEY_CALL-TAB_STAR			* CALL
01:0000F038 44              	  8739: 	dc.b	'D',0
01:0000F039 00
01:0000F03A 006A            	  8740: 	dc.w	KEY_DO-TAB_STAR			* DO
01:0000F03C 4C              	  8741: 	dc.b	'L',2
01:0000F03D 02
01:0000F03E 00D1            	  8742: 	dc.w	KEY_LOOP-TAB_STAR			* LOOP
01:0000F040 50              	  8743: 	dc.b	'P',3
01:0000F041 03
01:0000F042 0107            	  8744: 	dc.w	KEY_PRINT-TAB_STAR		* PRINT
01:0000F044 43              	  8745: 	dc.b	'C',2
01:0000F045 02
01:0000F046 004B            	  8746: 	dc.w	KEY_CONT-TAB_STAR			* CONT
01:0000F048 4C              	  8747: 	dc.b	'L',2
01:0000F049 02
01:0000F04A 00C1            	  8748: 	dc.w	KEY_LIST-TAB_STAR			* LIST
01:0000F04C 43              	  8749: 	dc.b	'C',3
01:0000F04D 03
01:0000F04E 0046            	  8750: 	dc.w	KEY_CLEAR-TAB_STAR		* CLEAR
01:0000F050 4E              	  8751: 	dc.b	'N',1
01:0000F051 01
01:0000F052 00E4            	  8752: 	dc.w	KEY_NEW-TAB_STAR			* NEW
01:0000F054 57              	  8753: 	dc.b	'W',3
01:0000F055 03
01:0000F056 01A3            	  8754: 	dc.w	KEY_WIDTH-TAB_STAR		* WIDTH
01:0000F058 47              	  8755: 	dc.b	'G',1
01:0000F059 01
01:0000F05A 0086            	  8756: 	dc.w	KEY_GET-TAB_STAR			* GET
01:0000F05C 53              	  8757: 	dc.b	'S',2
01:0000F05D 02
01:0000F05E 015D            	  8758: 	dc.w	KEY_SWAP-TAB_STAR			* SWAP
01:0000F060 42              	  8759: 	dc.b	'B',4
01:0000F061 04
01:0000F062 002F            	  8760: 	dc.w	KEY_BITSET-TAB_STAR		* BITSET
01:0000F064 42              	  8761: 	dc.b	'B',4
01:0000F065 04
01:0000F066 0029            	  8762: 	dc.w	KEY_BITCLR-TAB_STAR		* BITCLR
01:0000F068 54              	  8763: 	dc.b	'T',2
01:0000F069 02
01:0000F06A 0162            	  8764: 	dc.w	KEY_TAB-TAB_STAR			* TAB(
01:0000F06C 45              	  8765: 	dc.b	'E',2
01:0000F06D 02
01:0000F06E 006D            	  8766: 	dc.w	KEY_ELSE-TAB_STAR			* ELSE
01:0000F070 54              	  8767: 	dc.b	'T',0
01:0000F071 00
01:0000F072 016E            	  8768: 	dc.w	KEY_TO-TAB_STAR			* TO
01:0000F074 46              	  8769: 	dc.b	'F',0
01:0000F075 00
01:0000F076 007F            	  8770: 	dc.w	KEY_FN-TAB_STAR			* FN
01:0000F078 53              	  8771: 	dc.b	'S',2
01:0000F079 02
01:0000F07A 0148            	  8772: 	dc.w	KEY_SPC-TAB_STAR			* SPC(
01:0000F07C 54              	  8773: 	dc.b	'T',2
01:0000F07D 02
01:0000F07E 016A            	  8774: 	dc.w	KEY_THEN-TAB_STAR			* THEN
01:0000F080 4E              	  8775: 	dc.b	'N',1
01:0000F081 01
01:0000F082 00EB            	  8776: 	dc.w	KEY_NOT-TAB_STAR			* NOT
01:0000F084 53              	  8777: 	dc.b	'S',2
01:0000F085 02
01:0000F086 0150            	  8778: 	dc.w	KEY_STEP-TAB_STAR			* STEP
01:0000F088 55              	  8779: 	dc.b	'U',3
01:0000F089 03
01:0000F08A 017D            	  8780: 	dc.w	KEY_UNTIL-TAB_STAR		* UNTIL
01:0000F08C 57              	  8781: 	dc.b	'W',3
01:0000F08D 03
01:0000F08E 019E            	  8782: 	dc.w	KEY_WHILE-TAB_STAR		* WHILE
                            	  8783: 
01:0000F090 2B              	  8784: 	dc.b	'+',-1
01:0000F091 FF
01:0000F092 0002            	  8785: 	dc.w	KEY_PLUS-TAB_STAR			* +
01:0000F094 2D              	  8786: 	dc.b	'-',-1
01:0000F095 FF
01:0000F096 0004            	  8787: 	dc.w	KEY_MINUS-TAB_STAR		* -
01:0000F098 2A              	  8788: 	dc.b	'*',-1
01:0000F099 FF
01:0000F09A 0000            	  8789: 	dc.w	KEY_MULT-TAB_STAR			* *
01:0000F09C 2F              	  8790: 	dc.b	'/',-1
01:0000F09D FF
01:0000F09E 0006            	  8791: 	dc.w	KEY_DIV-TAB_STAR			* /
01:0000F0A0 5E              	  8792: 	dc.b	'^',-1
01:0000F0A1 FF
01:0000F0A2 01A9            	  8793: 	dc.w	KEY_POWER-TAB_STAR		* ^
01:0000F0A4 41              	  8794: 	dc.b	'A',1
01:0000F0A5 01
01:0000F0A6 0018            	  8795: 	dc.w	KEY_AND-TAB_STAR			* AND
01:0000F0A8 45              	  8796: 	dc.b	'E',1
01:0000F0A9 01
01:0000F0AA 0074            	  8797: 	dc.w	KEY_EOR-TAB_STAR			* EOR
01:0000F0AC 4F              	  8798: 	dc.b	'O',0
01:0000F0AD 00
01:0000F0AE 00F5            	  8799: 	dc.w	KEY_OR-TAB_STAR			* OR
01:0000F0B0 3E              	  8800: 	dc.b	'>',0
01:0000F0B1 00
01:0000F0B2 000E            	  8801: 	dc.w	KEY_RSHIFT-TAB_STAR		* >>
01:0000F0B4 3C              	  8802: 	dc.b	'<',0
01:0000F0B5 00
01:0000F0B6 0008            	  8803: 	dc.w	KEY_LSHIFT-TAB_STAR		* <<
01:0000F0B8 3E              	  8804: 	dc.b	'>',-1
01:0000F0B9 FF
01:0000F0BA 0010            	  8805: 	dc.w	KEY_GT-TAB_STAR			* >
01:0000F0BC 3D              	  8806: 	dc.b	'=',-1
01:0000F0BD FF
01:0000F0BE 000C            	  8807: 	dc.w	KEY_EQUAL-TAB_STAR		* =
01:0000F0C0 3C              	  8808: 	dc.b	'<',-1
01:0000F0C1 FF
01:0000F0C2 000A            	  8809: 	dc.w	KEY_LT-TAB_STAR			* <
                            	  8810: 
01:0000F0C4 53              	  8811: 	dc.b	'S',2
01:0000F0C5 02
01:0000F0C6 0140            	  8812: 	dc.w	KEY_SGN-TAB_STAR			* SGN(
01:0000F0C8 49              	  8813: 	dc.b	'I',2
01:0000F0C9 02
01:0000F0CA 00A3            	  8814: 	dc.w	KEY_INT-TAB_STAR			* INT(
01:0000F0CC 41              	  8815: 	dc.b	'A',2
01:0000F0CD 02
01:0000F0CE 0014            	  8816: 	dc.w	KEY_ABS-TAB_STAR			* ABS(
01:0000F0D0 55              	  8817: 	dc.b	'U',2
01:0000F0D1 02
01:0000F0D2 0189            	  8818: 	dc.w	KEY_USR-TAB_STAR			* USR(
01:0000F0D4 46              	  8819: 	dc.b	'F',2
01:0000F0D5 02
01:0000F0D6 0081            	  8820: 	dc.w	KEY_FRE-TAB_STAR			* FRE(
01:0000F0D8 50              	  8821: 	dc.b	'P',2
01:0000F0D9 02
01:0000F0DA 0103            	  8822: 	dc.w	KEY_POS-TAB_STAR			* POS(
01:0000F0DC 53              	  8823: 	dc.b	'S',2
01:0000F0DD 02
01:0000F0DE 014C            	  8824: 	dc.w	KEY_SQR-TAB_STAR			* SQR(
01:0000F0E0 52              	  8825: 	dc.b	'R',2
01:0000F0E1 02
01:0000F0E2 012F            	  8826: 	dc.w	KEY_RND-TAB_STAR			* RND(
01:0000F0E4 4C              	  8827: 	dc.b	'L',2
01:0000F0E5 02
01:0000F0E6 00C9            	  8828: 	dc.w	KEY_LOG-TAB_STAR			* LOG(
01:0000F0E8 45              	  8829: 	dc.b	'E',2
01:0000F0E9 02
01:0000F0EA 0077            	  8830: 	dc.w	KEY_EXP-TAB_STAR			* EXP(
01:0000F0EC 43              	  8831: 	dc.b	'C',2
01:0000F0ED 02
01:0000F0EE 004F            	  8832: 	dc.w	KEY_COS-TAB_STAR			* COS(
01:0000F0F0 53              	  8833: 	dc.b	'S',2
01:0000F0F1 02
01:0000F0F2 0144            	  8834: 	dc.w	KEY_SIN-TAB_STAR			* SIN(
01:0000F0F4 54              	  8835: 	dc.b	'T',2
01:0000F0F5 02
01:0000F0F6 0166            	  8836: 	dc.w	KEY_TAN-TAB_STAR			* TAN(
01:0000F0F8 41              	  8837: 	dc.b	'A',2
01:0000F0F9 02
01:0000F0FA 001F            	  8838: 	dc.w	KEY_ATN-TAB_STAR			* ATN(
01:0000F0FC 50              	  8839: 	dc.b	'P',3
01:0000F0FD 03
01:0000F0FE 00F8            	  8840: 	dc.w	KEY_PEEK-TAB_STAR			* PEEK(
01:0000F100 44              	  8841: 	dc.b	'D',3
01:0000F101 03
01:0000F102 005B            	  8842: 	dc.w	KEY_DEEK-TAB_STAR			* DEEK(
01:0000F104 4C              	  8843: 	dc.b	'L',3
01:0000F105 03
01:0000F106 00AF            	  8844: 	dc.w	KEY_LEEK-TAB_STAR			* LEEK(
01:0000F108 4C              	  8845: 	dc.b	'L',2
01:0000F109 02
01:0000F10A 00BA            	  8846: 	dc.w	KEY_LEN-TAB_STAR			* LEN(
01:0000F10C 53              	  8847: 	dc.b	'S',3
01:0000F10D 03
01:0000F10E 0158            	  8848: 	dc.w	KEY_STRS-TAB_STAR			* STR$(
01:0000F110 56              	  8849: 	dc.b	'V',2
01:0000F111 02
01:0000F112 018E            	  8850: 	dc.w	KEY_VAL-TAB_STAR			* VAL(
01:0000F114 41              	  8851: 	dc.b	'A',2
01:0000F115 02
01:0000F116 001B            	  8852: 	dc.w	KEY_ASC-TAB_STAR			* ASC(
01:0000F118 55              	  8853: 	dc.b	'U',5
01:0000F119 05
01:0000F11A 0176            	  8854: 	dc.w	KEY_UCASES-TAB_STAR		* UCASE$(
01:0000F11C 4C              	  8855: 	dc.b	'L',5
01:0000F11D 05
01:0000F11E 00A8            	  8856: 	dc.w	KEY_LCASES-TAB_STAR		* LCASE$(
01:0000F120 43              	  8857: 	dc.b	'C',3
01:0000F121 03
01:0000F122 0041            	  8858: 	dc.w	KEY_CHRS-TAB_STAR			* CHR$(
01:0000F124 48              	  8859: 	dc.b	'H',3
01:0000F125 03
01:0000F126 0093            	  8860: 	dc.w	KEY_HEXS-TAB_STAR			* HEX$(
01:0000F128 42              	  8861: 	dc.b	'B',3
01:0000F129 03
01:0000F12A 0024            	  8862: 	dc.w	KEY_BINS-TAB_STAR			* BIN$(
01:0000F12C 42              	  8863: 	dc.b	'B',5
01:0000F12D 05
01:0000F12E 0035            	  8864: 	dc.w	KEY_BITTST-TAB_STAR		* BITTST(
01:0000F130 4D              	  8865: 	dc.b	'M',2
01:0000F131 02
01:0000F132 00D6            	  8866: 	dc.w	KEY_MAX-TAB_STAR			* MAX(
01:0000F134 4D              	  8867: 	dc.b	'M',2
01:0000F135 02
01:0000F136 00DF            	  8868: 	dc.w	KEY_MIN-TAB_STAR			* MIN(
01:0000F138 52              	  8869: 	dc.b	'R',5
01:0000F139 05
01:0000F13A 010D            	  8870: 	dc.w	KEY_RAM-TAB_STAR			* RAMBASE
01:0000F13C 50              	  8871: 	dc.b	'P',0
01:0000F13D 00
01:0000F13E 00FD            	  8872: 	dc.w	KEY_PI-TAB_STAR			* PI
01:0000F140 54              	  8873: 	dc.b	'T',3
01:0000F141 03
01:0000F142 0170            	  8874: 	dc.w	KEY_TWOPI-TAB_STAR		* TWOPI
01:0000F144 56              	  8875: 	dc.b	'V',5
01:0000F145 05
01:0000F146 0192            	  8876: 	dc.w	KEY_VPTR-TAB_STAR			* VARPTR(
01:0000F148 53              	  8877: 	dc.b	'S',3
01:0000F149 03
01:0000F14A 0137            	  8878: 	dc.w	KEY_SADD-TAB_STAR			* SADD(
01:0000F14C 4C              	  8879: 	dc.b	'L',4
01:0000F14D 04
01:0000F14E 00B4            	  8880: 	dc.w	KEY_LEFTS-TAB_STAR		* LEFT$(
01:0000F150 52              	  8881: 	dc.b	'R',5
01:0000F151 05
01:0000F152 0128            	  8882: 	dc.w	KEY_RIGHTS-TAB_STAR		* RIGHT$(
01:0000F154 4D              	  8883: 	dc.b	'M',3
01:0000F155 03
01:0000F156 00DA            	  8884: 	dc.w	KEY_MIDS-TAB_STAR			* MID$(
01:0000F158 55              	  8885: 	dc.b	'U',5
01:0000F159 05
01:0000F15A 0182            	  8886: 	dc.w	KEY_USINGS-TAB_STAR		* USING$(
                            	  8887: 
                            	  8888: 
                            	  8889: *************************************************************************************
                            	  8890: *
                            	  8891: * BASIC error messages
                            	  8892: 
                            	  8893: LAB_BAER
01:0000F15C 0030            	  8894: 	dc.w	LAB_NF-LAB_BAER			* $00 NEXT without FOR
01:0000F15E 0041            	  8895: 	dc.w	LAB_SN-LAB_BAER			* $02 syntax
01:0000F160 0048            	  8896: 	dc.w	LAB_RG-LAB_BAER			* $04 RETURN without GOSUB
01:0000F162 005D            	  8897: 	dc.w	LAB_OD-LAB_BAER			* $06 out of data
01:0000F164 0069            	  8898: 	dc.w	LAB_FC-LAB_BAER			* $08 function call
01:0000F166 0077            	  8899: 	dc.w	LAB_OV-LAB_BAER			* $0A overflow
01:0000F168 0080            	  8900: 	dc.w	LAB_OM-LAB_BAER			* $0C out of memory
01:0000F16A 008E            	  8901: 	dc.w	LAB_US-LAB_BAER			* $0E undefined statement
01:0000F16C 00A2            	  8902: 	dc.w	LAB_BS-LAB_BAER			* $10 array bounds
01:0000F16E 00AF            	  8903: 	dc.w	LAB_DD-LAB_BAER			* $12 double dimension array
01:0000F170 00C0            	  8904: 	dc.w	LAB_D0-LAB_BAER			* $14 divide by 0
01:0000F172 00CF            	  8905: 	dc.w	LAB_ID-LAB_BAER			* $16 illegal direct
01:0000F174 00DE            	  8906: 	dc.w	LAB_TM-LAB_BAER			* $18 type mismatch
01:0000F176 00EC            	  8907: 	dc.w	LAB_LS-LAB_BAER			* $1A long string
01:0000F178 00FC            	  8908: 	dc.w	LAB_ST-LAB_BAER			* $1C string too complex
01:0000F17A 010F            	  8909: 	dc.w	LAB_CN-LAB_BAER			* $1E continue error
01:0000F17C 011E            	  8910: 	dc.w	LAB_UF-LAB_BAER			* $20 undefined function
01:0000F17E 0131            	  8911: 	dc.w	LAB_LD-LAB_BAER			* $22 LOOP without DO
01:0000F180 0141            	  8912: 	dc.w	LAB_UV-LAB_BAER			* $24 undefined variable
01:0000F182 0154            	  8913: 	dc.w	LAB_UA-LAB_BAER			* $26 undimensioned array
01:0000F184 0168            	  8914: 	dc.w	LAB_WD-LAB_BAER			* $28 wrong dimensions
01:0000F186 0179            	  8915: 	dc.w	LAB_AD-LAB_BAER			* $2A address
01:0000F188 0181            	  8916: 	dc.w	LAB_FO-LAB_BAER			* $2C format
01:0000F18A 0188            	  8917: 	dc.w	LAB_NI-LAB_BAER			* $2E not implemented
                            	  8918: 
01:0000F18C 4E45585420776974	  8919: LAB_NF	dc.b	'NEXT without FOR',$00
01:0000F194 686F757420464F52
01:0000F19C 00
01:0000F19D 53796E746178    	  8920: LAB_SN	dc.b	'Syntax',$00
01:0000F1A3 00
01:0000F1A4 52455455524E2077	  8921: LAB_RG	dc.b	'RETURN without GOSUB',$00
01:0000F1AC 6974686F75742047
01:0000F1B4 4F535542
01:0000F1B8 00
01:0000F1B9 4F7574206F662044	  8922: LAB_OD	dc.b	'Out of DATA',$00
01:0000F1C1 415441
01:0000F1C4 00
01:0000F1C5 46756E6374696F6E	  8923: LAB_FC	dc.b	'Function call',$00
01:0000F1CD 2063616C6C
01:0000F1D2 00
01:0000F1D3 4F766572666C6F77	  8924: LAB_OV	dc.b	'Overflow',$00
01:0000F1DB 00
01:0000F1DC 4F7574206F66206D	  8925: LAB_OM	dc.b	'Out of memory',$00
01:0000F1E4 656D6F7279
01:0000F1E9 00
01:0000F1EA 556E646566696E65	  8926: LAB_US	dc.b	'Undefined statement',$00
01:0000F1F2 642073746174656D
01:0000F1FA 656E74
01:0000F1FD 00
01:0000F1FE 417272617920626F	  8927: LAB_BS	dc.b	'Array bounds',$00
01:0000F206 756E6473
01:0000F20A 00
01:0000F20B 446F75626C652064	  8928: LAB_DD	dc.b	'Double dimension',$00
01:0000F213 696D656E73696F6E
01:0000F21B 00
01:0000F21C 4469766964652062	  8929: LAB_D0	dc.b	'Divide by zero',$00
01:0000F224 79207A65726F
01:0000F22A 00
01:0000F22B 496C6C6567616C20	  8930: LAB_ID	dc.b	'Illegal direct',$00
01:0000F233 646972656374
01:0000F239 00
01:0000F23A 54797065206D6973	  8931: LAB_TM	dc.b	'Type mismatch',$00
01:0000F242 6D61746368
01:0000F247 00
01:0000F248 537472696E672074	  8932: LAB_LS	dc.b	'String too long',$00
01:0000F250 6F6F206C6F6E67
01:0000F257 00
01:0000F258 537472696E672074	  8933: LAB_ST	dc.b	'String too complex',$00
01:0000F260 6F6F20636F6D706C
01:0000F268 6578
01:0000F26A 00
01:0000F26B 43616E277420636F	  8934: LAB_CN	dc.b	'Can''t continue',$00
01:0000F273 6E74696E7565
01:0000F279 00
01:0000F27A 556E646566696E65	  8935: LAB_UF	dc.b	'Undefined function',$00
01:0000F282 642066756E637469
01:0000F28A 6F6E
01:0000F28C 00
01:0000F28D 4C4F4F5020776974	  8936: LAB_LD	dc.b	'LOOP without DO',$00
01:0000F295 686F757420444F
01:0000F29C 00
01:0000F29D 556E646566696E65	  8937: LAB_UV	dc.b	'Undefined variable',$00
01:0000F2A5 6420766172696162
01:0000F2AD 6C65
01:0000F2AF 00
01:0000F2B0 556E64696D656E73	  8938: LAB_UA	dc.b	'Undimensioned array',$00
01:0000F2B8 696F6E6564206172
01:0000F2C0 726179
01:0000F2C3 00
01:0000F2C4 57726F6E67206469	  8939: LAB_WD	dc.b	'Wrong dimensions',$00
01:0000F2CC 6D656E73696F6E73
01:0000F2D4 00
01:0000F2D5 41646472657373  	  8940: LAB_AD	dc.b	'Address',$00
01:0000F2DC 00
01:0000F2DD 466F726D6174    	  8941: LAB_FO	dc.b	'Format',$00
01:0000F2E3 00
01:0000F2E4 4E6F7420696D706C	  8942: LAB_NI  dc.b    'Not implemented',$00
01:0000F2EC 656D656E746564
01:0000F2F3 00
                            	  8943: 
                            	  8944: 
                            	  8945: *************************************************************************************
                            	  8946: *
                            	  8947: * keyword table for line (un)crunching
                            	  8948: 
                            	  8949: * [keyword,token
                            	  8950: * [keyword,token]]
                            	  8951: * end marker (#$00)
                            	  8952: 
                            	  8953: TAB_STAR
                            	  8954: KEY_MULT
01:0000F2F4 B4              	  8955: 	dc.b TK_MULT,$00				* *
01:0000F2F5 00
                            	  8956: TAB_PLUS
                            	  8957: KEY_PLUS
01:0000F2F6 B2              	  8958: 	dc.b TK_PLUS,$00				* +
01:0000F2F7 00
                            	  8959: TAB_MNUS
                            	  8960: KEY_MINUS
01:0000F2F8 B3              	  8961: 	dc.b TK_MINUS,$00				* -
01:0000F2F9 00
                            	  8962: TAB_SLAS
                            	  8963: KEY_DIV
01:0000F2FA B5              	  8964: 	dc.b TK_DIV,$00				* /
01:0000F2FB 00
                            	  8965: TAB_LESS
                            	  8966: KEY_LSHIFT
01:0000F2FC 3C              	  8967: 	dc.b	'<',TK_LSHIFT			* <<
01:0000F2FD BB
                            	  8968: KEY_LT
01:0000F2FE BE              	  8969: 	dc.b TK_LT					* <
01:0000F2FF 00              	  8970: 	dc.b	$00
                            	  8971: TAB_EQUL
                            	  8972: KEY_EQUAL
01:0000F300 BD              	  8973: 	dc.b TK_EQUAL,$00				* =
01:0000F301 00
                            	  8974: TAB_MORE
                            	  8975: KEY_RSHIFT
01:0000F302 3E              	  8976: 	dc.b	'>',TK_RSHIFT			* >>
01:0000F303 BA
                            	  8977: KEY_GT
01:0000F304 BC              	  8978: 	dc.b TK_GT					* >
01:0000F305 00              	  8979: 	dc.b	$00
                            	  8980: TAB_QEST
01:0000F306 9E              	  8981: 	dc.b TK_PRINT,$00				* ?
01:0000F307 00
                            	  8982: TAB_ASCA
                            	  8983: KEY_ABS
01:0000F308 425328          	  8984: 	dc.b	'BS(',TK_ABS			* ABS(
01:0000F30B C1
                            	  8985: KEY_AND
01:0000F30C 4E44            	  8986: 	dc.b	'ND',TK_AND				* AND
01:0000F30E B7
                            	  8987: KEY_ASC
01:0000F30F 534328          	  8988: 	dc.b	'SC(',TK_ASC			* ASC(
01:0000F312 D3
                            	  8989: KEY_ATN
01:0000F313 544E28          	  8990: 	dc.b	'TN(',TK_ATN			* ATN(
01:0000F316 CC
01:0000F317 00              	  8991: 	dc.b	$00
                            	  8992: TAB_ASCB
                            	  8993: KEY_BINS
01:0000F318 494E2428        	  8994: 	dc.b	'IN$(',TK_BINS			* BIN$(
01:0000F31C D8
                            	  8995: KEY_BITCLR
01:0000F31D 4954434C52      	  8996: 	dc.b	'ITCLR',TK_BITCLR			* BITCLR
01:0000F322 A7
                            	  8997: KEY_BITSET
01:0000F323 4954534554      	  8998: 	dc.b	'ITSET',TK_BITSET			* BITSET
01:0000F328 A6
                            	  8999: KEY_BITTST
01:0000F329 495454535428    	  9000: 	dc.b	'ITTST(',TK_BITTST		* BITTST(
01:0000F32F D9
01:0000F330 00              	  9001: 	dc.b	$00
                            	  9002: TAB_ASCC
                            	  9003: KEY_CALL
01:0000F331 414C4C          	  9004: 	dc.b	'ALL',TK_CALL			* CALL
01:0000F334 9B
                            	  9005: KEY_CHRS
01:0000F335 48522428        	  9006: 	dc.b	'HR$(',TK_CHRS			* CHR$(
01:0000F339 D6
                            	  9007: KEY_CLEAR
01:0000F33A 4C454152        	  9008: 	dc.b	'LEAR',TK_CLEAR			* CLEAR
01:0000F33E A1
                            	  9009: KEY_CONT
01:0000F33F 4F4E54          	  9010: 	dc.b	'ONT',TK_CONT			* CONT
01:0000F342 9F
                            	  9011: KEY_COS
01:0000F343 4F5328          	  9012: 	dc.b	'OS(',TK_COS			* COS(
01:0000F346 C9
01:0000F347 00              	  9013: 	dc.b	$00
                            	  9014: TAB_ASCD
                            	  9015: KEY_DATA
01:0000F348 415441          	  9016: 	dc.b	'ATA',TK_DATA			* DATA
01:0000F34B 83
                            	  9017: KEY_DEC
01:0000F34C 4543            	  9018: 	dc.b	'EC',TK_DEC				* DEC
01:0000F34E 88
                            	  9019: KEY_DEEK
01:0000F34F 45454B28        	  9020: 	dc.b	'EEK(',TK_DEEK			* DEEK(
01:0000F353 CE
                            	  9021: KEY_DEF
01:0000F354 4546            	  9022: 	dc.b	'EF',TK_DEF				* DEF
01:0000F356 97
                            	  9023: KEY_DIM
01:0000F357 494D            	  9024: 	dc.b	'IM',TK_DIM				* DIM
01:0000F359 85
                            	  9025: KEY_DOKE
01:0000F35A 4F4B45          	  9026: 	dc.b	'OKE',TK_DOKE			* DOKE
01:0000F35D 99
                            	  9027: KEY_DO
01:0000F35E 4F              	  9028: 	dc.b	'O',TK_DO				* DO
01:0000F35F 9C
01:0000F360 00              	  9029: 	dc.b	$00
                            	  9030: TAB_ASCE
                            	  9031: KEY_ELSE
01:0000F361 4C5345          	  9032: 	dc.b	'LSE',TK_ELSE			* ELSE
01:0000F364 A9
                            	  9033: KEY_END
01:0000F365 4E44            	  9034: 	dc.b	'ND',TK_END				* END
01:0000F367 80
                            	  9035: KEY_EOR
01:0000F368 4F52            	  9036: 	dc.b	'OR',TK_EOR				* EOR
01:0000F36A B8
                            	  9037: KEY_EXP
01:0000F36B 585028          	  9038: 	dc.b	'XP(',TK_EXP			* EXP(
01:0000F36E C8
01:0000F36F 00              	  9039: 	dc.b	$00
                            	  9040: TAB_ASCF
                            	  9041: KEY_FOR
01:0000F370 4F52            	  9042: 	dc.b	'OR',TK_FOR				* FOR
01:0000F372 81
                            	  9043: KEY_FN
01:0000F373 4E              	  9044: 	dc.b	'N',TK_FN				* FN
01:0000F374 AB
                            	  9045: KEY_FRE
01:0000F375 524528          	  9046: 	dc.b	'RE(',TK_FRE			* FRE(
01:0000F378 C3
01:0000F379 00              	  9047: 	dc.b	$00
                            	  9048: TAB_ASCG
                            	  9049: KEY_GET
01:0000F37A 4554            	  9050: 	dc.b	'ET',TK_GET				* GET
01:0000F37C A4
                            	  9051: KEY_GOTO
01:0000F37D 4F544F          	  9052: 	dc.b	'OTO',TK_GOTO			* GOTO
01:0000F380 89
                            	  9053: KEY_GOSUB
01:0000F381 4F535542        	  9054: 	dc.b	'OSUB',TK_GOSUB			* GOSUB
01:0000F385 8D
01:0000F386 00              	  9055: 	dc.b	$00
                            	  9056: TAB_ASCH
                            	  9057: KEY_HEXS
01:0000F387 45582428        	  9058: 	dc.b	'EX$(',TK_HEXS,$00		* HEX$(
01:0000F38B D7
01:0000F38C 00
                            	  9059: TAB_ASCI
                            	  9060: KEY_IF
01:0000F38D 46              	  9061: 	dc.b	'F',TK_IF				* IF
01:0000F38E 8B
                            	  9062: KEY_INC
01:0000F38F 4E43            	  9063: 	dc.b	'NC',TK_INC				* INC
01:0000F391 93
                            	  9064: KEY_INPUT
01:0000F392 4E505554        	  9065: 	dc.b	'NPUT',TK_INPUT			* INPUT
01:0000F396 84
                            	  9066: KEY_INT
01:0000F397 4E5428          	  9067: 	dc.b	'NT(',TK_INT			* INT(
01:0000F39A C0
01:0000F39B 00              	  9068: 	dc.b	$00
                            	  9069: TAB_ASCL
                            	  9070: KEY_LCASES
01:0000F39C 434153452428    	  9071: 	dc.b	'CASE$(',TK_LCASES		* LCASE$(
01:0000F3A2 D5
                            	  9072: KEY_LEEK
01:0000F3A3 45454B28        	  9073: 	dc.b	'EEK(',TK_LEEK			* LEEK(
01:0000F3A7 CF
                            	  9074: KEY_LEFTS
01:0000F3A8 4546542428      	  9075: 	dc.b	'EFT$(',TK_LEFTS			* LEFT$(
01:0000F3AD E1
                            	  9076: KEY_LEN
01:0000F3AE 454E28          	  9077: 	dc.b	'EN(',TK_LEN			* LEN(
01:0000F3B1 D0
                            	  9078: KEY_LET
01:0000F3B2 4554            	  9079: 	dc.b	'ET',TK_LET				* LET
01:0000F3B4 87
                            	  9080: KEY_LIST
01:0000F3B5 495354          	  9081: 	dc.b	'IST',TK_LIST			* LIST
01:0000F3B8 A0
                            	  9082: KEY_LOAD
01:0000F3B9 4F4144          	  9083: 	dc.b	'OAD',TK_LOAD			* LOAD
01:0000F3BC 95
                            	  9084: KEY_LOG
01:0000F3BD 4F4728          	  9085: 	dc.b	'OG(',TK_LOG			* LOG(
01:0000F3C0 C7
                            	  9086: KEY_LOKE
01:0000F3C1 4F4B45          	  9087: 	dc.b	'OKE',TK_LOKE			* LOKE
01:0000F3C4 9A
                            	  9088: KEY_LOOP
01:0000F3C5 4F4F50          	  9089: 	dc.b	'OOP',TK_LOOP			* LOOP
01:0000F3C8 9D
01:0000F3C9 00              	  9090: 	dc.b	$00
                            	  9091: TAB_ASCM
                            	  9092: KEY_MAX
01:0000F3CA 415828          	  9093: 	dc.b	'AX(',TK_MAX			* MAX(
01:0000F3CD DA
                            	  9094: KEY_MIDS
01:0000F3CE 49442428        	  9095: 	dc.b	'ID$(',TK_MIDS			* MID$(
01:0000F3D2 E3
                            	  9096: KEY_MIN
01:0000F3D3 494E28          	  9097: 	dc.b	'IN(',TK_MIN			* MIN(
01:0000F3D6 DB
01:0000F3D7 00              	  9098: 	dc.b	$00
                            	  9099: TAB_ASCN
                            	  9100: KEY_NEW
01:0000F3D8 4557            	  9101: 	dc.b	'EW',TK_NEW				* NEW
01:0000F3DA A2
                            	  9102: KEY_NEXT
01:0000F3DB 455854          	  9103: 	dc.b	'EXT',TK_NEXT			* NEXT
01:0000F3DE 82
                            	  9104: KEY_NOT
01:0000F3DF 4F54            	  9105: 	dc.b	'OT',TK_NOT				* NOT
01:0000F3E1 AE
                            	  9106: KEY_NULL
01:0000F3E2 554C4C          	  9107: 	dc.b	'ULL',TK_NULL			* NULL
01:0000F3E5 92
01:0000F3E6 00              	  9108: 	dc.b	$00
                            	  9109: TAB_ASCO
                            	  9110: KEY_ON
01:0000F3E7 4E              	  9111: 	dc.b	'N',TK_ON				* ON
01:0000F3E8 91
                            	  9112: KEY_OR
01:0000F3E9 52              	  9113: 	dc.b	'R',TK_OR				* OR
01:0000F3EA B9
01:0000F3EB 00              	  9114: 	dc.b	$00
                            	  9115: TAB_ASCP
                            	  9116: KEY_PEEK
01:0000F3EC 45454B28        	  9117: 	dc.b	'EEK(',TK_PEEK			* PEEK(
01:0000F3F0 CD
                            	  9118: KEY_PI
01:0000F3F1 49              	  9119: 	dc.b	'I',TK_PI				* PI
01:0000F3F2 DD
                            	  9120: KEY_POKE
01:0000F3F3 4F4B45          	  9121: 	dc.b	'OKE',TK_POKE			* POKE
01:0000F3F6 98
                            	  9122: KEY_POS
01:0000F3F7 4F5328          	  9123: 	dc.b	'OS(',TK_POS			* POS(
01:0000F3FA C4
                            	  9124: KEY_PRINT
01:0000F3FB 52494E54        	  9125: 	dc.b	'RINT',TK_PRINT			* PRINT
01:0000F3FF 9E
01:0000F400 00              	  9126: 	dc.b	$00
                            	  9127: TAB_ASCR
                            	  9128: KEY_RAM
01:0000F401 414D42415345    	  9129: 	dc.b	'AMBASE',TK_RAM			* RAMBASE
01:0000F407 DC
                            	  9130: KEY_READ
01:0000F408 454144          	  9131: 	dc.b	'EAD',TK_READ			* READ
01:0000F40B 86
                            	  9132: KEY_REM
01:0000F40C 454D            	  9133: 	dc.b	'EM',TK_REM				* REM
01:0000F40E 8F
                            	  9134: KEY_RESTORE
01:0000F40F 4553544F5245    	  9135: 	dc.b	'ESTORE',TK_RESTORE		* RESTORE
01:0000F415 8C
                            	  9136: KEY_RETURN
01:0000F416 455455524E      	  9137: 	dc.b	'ETURN',TK_RETURN			* RETURN
01:0000F41B 8E
                            	  9138: KEY_RIGHTS
01:0000F41C 494748542428    	  9139: 	dc.b	'IGHT$(',TK_RIGHTS		* RIGHT$(
01:0000F422 E2
                            	  9140: KEY_RND
01:0000F423 4E4428          	  9141: 	dc.b	'ND(',TK_RND			* RND(
01:0000F426 C6
                            	  9142: KEY_RUN
01:0000F427 554E            	  9143: 	dc.b	'UN',TK_RUN				* RUN
01:0000F429 8A
01:0000F42A 00              	  9144: 	dc.b	$00
                            	  9145: TAB_ASCS
                            	  9146: KEY_SADD
01:0000F42B 41444428        	  9147: 	dc.b	'ADD(',TK_SADD			* SADD(
01:0000F42F E0
                            	  9148: KEY_SAVE
01:0000F430 415645          	  9149: 	dc.b	'AVE',TK_SAVE			* SAVE
01:0000F433 96
                            	  9150: KEY_SGN
01:0000F434 474E28          	  9151: 	dc.b	'GN(',TK_SGN			* SGN(
01:0000F437 BF
                            	  9152: KEY_SIN
01:0000F438 494E28          	  9153: 	dc.b	'IN(',TK_SIN			* SIN(
01:0000F43B CA
                            	  9154: KEY_SPC
01:0000F43C 504328          	  9155: 	dc.b	'PC(',TK_SPC			* SPC(
01:0000F43F AC
                            	  9156: KEY_SQR
01:0000F440 515228          	  9157: 	dc.b	'QR(',TK_SQR			* SQR(
01:0000F443 C5
                            	  9158: KEY_STEP
01:0000F444 544550          	  9159: 	dc.b	'TEP',TK_STEP			* STEP
01:0000F447 AF
                            	  9160: KEY_STOP
01:0000F448 544F50          	  9161: 	dc.b	'TOP',TK_STOP			* STOP
01:0000F44B 90
                            	  9162: KEY_STRS
01:0000F44C 54522428        	  9163: 	dc.b	'TR$(',TK_STRS			* STR$(
01:0000F450 D1
                            	  9164: KEY_SWAP
01:0000F451 574150          	  9165: 	dc.b	'WAP',TK_SWAP			* SWAP
01:0000F454 A5
01:0000F455 00              	  9166: 	dc.b	$00
                            	  9167: TAB_ASCT
                            	  9168: KEY_TAB
01:0000F456 414228          	  9169: 	dc.b	'AB(',TK_TAB			* TAB(
01:0000F459 A8
                            	  9170: KEY_TAN
01:0000F45A 414E28          	  9171: 	dc.b	'AN(',TK_TAN			* TAN
01:0000F45D CB
                            	  9172: KEY_THEN
01:0000F45E 48454E          	  9173: 	dc.b	'HEN',TK_THEN			* THEN
01:0000F461 AD
                            	  9174: KEY_TO
01:0000F462 4F              	  9175: 	dc.b	'O',TK_TO				* TO
01:0000F463 AA
                            	  9176: KEY_TWOPI
01:0000F464 574F5049        	  9177: 	dc.b	'WOPI',TK_TWOPI			* TWOPI
01:0000F468 DE
01:0000F469 00              	  9178: 	dc.b	$00
                            	  9179: TAB_ASCU
                            	  9180: KEY_UCASES
01:0000F46A 434153452428    	  9181: 	dc.b	'CASE$(',TK_UCASES		* UCASE$(
01:0000F470 D4
                            	  9182: KEY_UNTIL
01:0000F471 4E54494C        	  9183: 	dc.b	'NTIL',TK_UNTIL			* UNTIL
01:0000F475 B0
                            	  9184: KEY_USINGS
01:0000F476 53494E472428    	  9185: 	dc.b	'SING$(',TK_USINGS		* USING$(
01:0000F47C E4
                            	  9186: KEY_USR
01:0000F47D 535228          	  9187: 	dc.b	'SR(',TK_USR			* USR(
01:0000F480 C2
01:0000F481 00              	  9188: 	dc.b	$00
                            	  9189: TAB_ASCV
                            	  9190: KEY_VAL
01:0000F482 414C28          	  9191: 	dc.b	'AL(',TK_VAL			* VAL(
01:0000F485 D2
                            	  9192: KEY_VPTR
01:0000F486 415250545228    	  9193: 	dc.b	'ARPTR(',TK_VPTR			* VARPTR(
01:0000F48C DF
01:0000F48D 00              	  9194: 	dc.b	$00
                            	  9195: TAB_ASCW
                            	  9196: KEY_WAIT
01:0000F48E 414954          	  9197: 	dc.b	'AIT',TK_WAIT			* WAIT
01:0000F491 94
                            	  9198: KEY_WHILE
01:0000F492 48494C45        	  9199: 	dc.b	'HILE',TK_WHILE			* WHILE
01:0000F496 B1
                            	  9200: KEY_WIDTH
01:0000F497 49445448        	  9201: 	dc.b	'IDTH',TK_WIDTH			* WIDTH
01:0000F49B A3
01:0000F49C 00              	  9202: 	dc.b	$00
                            	  9203: TAB_POWR
                            	  9204: KEY_POWER
01:0000F49D B6              	  9205: 	dc.b	TK_POWER,$00			* ^
01:0000F49E 00
                            	  9206: 
                            	  9207: 
                            	  9208: *************************************************************************************
                            	  9209: *
                            	  9210: * just messages
                            	  9211: 
                            	  9212: LAB_BMSG
01:0000F49F 0D              	  9213: 	dc.b	$0D,$0A,'Break',$00
01:0000F4A0 0A
01:0000F4A1 427265616B
01:0000F4A6 00
                            	  9214: LAB_EMSG
01:0000F4A7 204572726F72    	  9215: 	dc.b	' Error',$00
01:0000F4AD 00
                            	  9216: LAB_LMSG
01:0000F4AE 20696E206C696E65	  9217: 	dc.b	' in line ',$00
01:0000F4B6 20
01:0000F4B7 00
                            	  9218: LAB_IMSG
01:0000F4B8 4578747261206967	  9219: 	dc.b	'Extra ignored',$0D,$0A,$00
01:0000F4C0 6E6F726564
01:0000F4C5 0D
01:0000F4C6 0A
01:0000F4C7 00
                            	  9220: LAB_REDO
01:0000F4C8 5265646F2066726F	  9221: 	dc.b	'Redo from start',$0D,$0A,$00
01:0000F4D0 6D207374617274
01:0000F4D7 0D
01:0000F4D8 0A
01:0000F4D9 00
                            	  9222: LAB_RMSG
01:0000F4DA 0D              	  9223: 	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
01:0000F4DB 0A
01:0000F4DC 5265616479
01:0000F4E1 0D
01:0000F4E2 0A
01:0000F4E3 00
                            	  9224: LAB_SMSG
01:0000F4E4 2042797465732066	  9225: 	dc.b	' Bytes free',$0D,$0A,$0A
01:0000F4EC 726565
01:0000F4EF 0D
01:0000F4F0 0A
01:0000F4F1 0A
01:0000F4F2 456E68616E636564	  9226: 	dc.b	'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
01:0000F4FA 2036386B20424153
01:0000F502 4943205665727369
01:0000F50A 6F6E20332E3534
01:0000F511 0D
01:0000F512 0A
01:0000F513 00
                            	  9227: 
                            	  9228: 
                            	  9229: *************************************************************************************
                            	  9230: * EhBASIC keywords quick reference list								*
                            	  9231: *************************************************************************************
                            	  9232: 
                            	  9233: * glossary
                            	  9234: 
                            	  9235: *		<.>		  required
                            	  9236: *		{.|.}		  one of required
                            	  9237: *		[.]		  optional
                            	  9238: *		...		  may repeat as last
                            	  9239: 
                            	  9240: *		any		= anything
                            	  9241: *		num		= number
                            	  9242: *		state		= statement
                            	  9243: *		n		= positive integer
                            	  9244: *		str		= string
                            	  9245: *		var		= variable
                            	  9246: *		nvar		= numeric variable
                            	  9247: *		svar		= string variable
                            	  9248: *		expr		= expression
                            	  9249: *		nexpr		= numeric expression
                            	  9250: *		sexpr		= string expression
                            	  9251: 
                            	  9252: * statement separator
                            	  9253: 
                            	  9254: * :		. [<state>] : [<state>]						* done
                            	  9255: 
                            	  9256: * number bases
                            	  9257: 
                            	  9258: * %		. %<binary num>							* done
                            	  9259: * $		. $<hex num>							* done
                            	  9260: 
                            	  9261: * commands
                            	  9262: 
                            	  9263: * END		. END									* done
                            	  9264: * FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
                            	  9265: * NEXT	. NEXT [<nvar>[,<nvar>]...]					* done
                            	  9266: * DATA	. DATA [{num|["]str["]}[,{num|["]str["]}]...]		* done
                            	  9267: * INPUT	. INPUT [<">str<">;] <var>[,<var>[,<var>]...]		* done
                            	  9268: * DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])			* done
                            	  9269: * READ	. READ <var>[,<var>[,<var>]...]				* done
                            	  9270: * LET		. [LET] <var>=<expr>						* done
                            	  9271: * DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]				* done
                            	  9272: * GOTO	. GOTO <n>								* done
                            	  9273: * RUN		. RUN [<n>]								* done
                            	  9274: * IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	* done
                            	  9275: * RESTORE	. RESTORE [<n>]							* done
                            	  9276: * GOSUB	. GOSUB <n>								* done
                            	  9277: * RETURN	. RETURN								* done
                            	  9278: * REM		. REM [<any>]							* done
                            	  9279: * STOP	. STOP								* done
                            	  9280: * ON		. ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]		* done
                            	  9281: * NULL	. NULL <nexpr>							* done
                            	  9282: * INC		. INC <nvar>[,<nvar>[,<nvar>]...]				* done
                            	  9283: * WAIT	. WAIT <nexpr>,<nexpr>[,<nexpr>]				* done
                            	  9284: * LOAD	. LOAD [<sexpr>]							* done for sim
                            	  9285: * SAVE	. SAVE [<sexpr>][,[<n>][-<n>]]				* done for sim
                            	  9286: * DEF		. DEF FN<var>(<var>)=<expr>					* done
                            	  9287: * POKE	. POKE <nexpr>,<nexpr>						* done
                            	  9288: * DOKE	. DOKE <nexpr>,<nexpr>						* done
                            	  9289: * LOKE	. LOKE <nexpr>,<nexpr>						* done
                            	  9290: * CALL	. CALL <nexpr>							* done
                            	  9291: * DO		. DO									* done
                            	  9292: * LOOP	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
                            	  9293: * PRINT	. PRINT [{;|,}][<expr>][{;|,}[<expr>]...]			* done
                            	  9294: * CONT	. CONT								* done
                            	  9295: * LIST	. LIST [<n>][-<n>]						* done
                            	  9296: * CLEAR	. CLEAR								* done
                            	  9297: * NEW		. NEW									* done
                            	  9298: * WIDTH	. WIDTH [<n>][,<n>]						* done
                            	  9299: * GET		. GET <var>								* done
                            	  9300: * SWAP	. SWAP <var>,<var>						* done
                            	  9301: * BITSET	. BITSET <nexpr>,<nexpr>					* done
                            	  9302: * BITCLR	. BITCLR <nexpr>,<nexpr>					* done
                            	  9303: 
                            	  9304: * sub commands (may not start a statement)
                            	  9305: 
                            	  9306: * TAB		. TAB(<nexpr>)							* done
                            	  9307: * ELSE	. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	* done
                            	  9308: * TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
                            	  9309: * FN		. FN <var>(<expr>)						* done
                            	  9310: * SPC		. SPC(<nexpr>)							* done
                            	  9311: * THEN	. IF <nexpr> {THEN <{n|comm}>|GOTO <n>}			* done
                            	  9312: * NOT		. NOT <nexpr>							* done
                            	  9313: * STEP	. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
                            	  9314: * UNTIL	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
                            	  9315: * WHILE	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
                            	  9316: 
                            	  9317: * operators
                            	  9318: 
                            	  9319: * +		. [expr] + <expr>							* done
                            	  9320: * -		. [nexpr] - <nexpr>						* done
                            	  9321: * *		. <nexpr> * <nexpr>						* done fast hardware
                            	  9322: * /		. <nexpr> / <nexpr>						* done fast hardware
                            	  9323: * ^		. <nexpr> ^ <nexpr>						* done
                            	  9324: * AND		. <nexpr> AND <nexpr>						* done
                            	  9325: * EOR		. <nexpr> EOR <nexpr>						* done
                            	  9326: * OR		. <nexpr> OR <nexpr>						* done
                            	  9327: * >>		. <nexpr> >> <nexpr>						* done
                            	  9328: * <<		. <nexpr> << <nexpr>						* done
                            	  9329: 
                            	  9330: * compare functions
                            	  9331: 
                            	  9332: * <		. <expr> < <expr>							* done
                            	  9333: * =		. <expr> = <expr>							* done
                            	  9334: * >		. <expr> > <expr>							* done
                            	  9335: 
                            	  9336: * functions
                            	  9337: 
                            	  9338: * SGN		. SGN(<nexpr>)							* done
                            	  9339: * INT		. INT(<nexpr>)							* done
                            	  9340: * ABS		. ABS(<nexpr>)							* done
                            	  9341: * USR		. USR(<expr>)							* done
                            	  9342: * FRE		. FRE(<expr>)							* done
                            	  9343: * POS		. POS(<expr>)							* done
                            	  9344: * SQR		. SQR(<nexpr>)							* done fast shift/sub
                            	  9345: * RND		. RND(<nexpr>)							* done 32 bit PRNG
                            	  9346: * LOG		. LOG(<nexpr>)							* done fast cordic
                            	  9347: * EXP		. EXP(<nexpr>)							* done fast cordic
                            	  9348: * COS		. COS(<nexpr>)							* done fast cordic
                            	  9349: * SIN		. SIN(<nexpr>)							* done fast cordic
                            	  9350: * TAN		. TAN(<nexpr>)							* done fast cordic
                            	  9351: * ATN		. ATN(<nexpr>)							* done fast cordic
                            	  9352: * PEEK	. PEEK(<nexpr>)							* done
                            	  9353: * DEEK	. DEEK(<nexpr>)							* done
                            	  9354: * LEEK	. LEEK(<nexpr>)							* done
                            	  9355: * LEN		. LEN(<sexpr>)							* done
                            	  9356: * STR$	. STR$(<nexpr>)							* done
                            	  9357: * VAL		. VAL(<sexpr>)							* done
                            	  9358: * ASC		. ASC(<sexpr>)							* done
                            	  9359: * UCASE$	. UCASE$(<sexpr>)							* done
                            	  9360: * LCASE$	. LCASE$(<sexpr>)							* done
                            	  9361: * CHR$	. CHR$(<nexpr>)							* done
                            	  9362: * HEX$	. HEX$(<nexpr>)							* done
                            	  9363: * BIN$	. BIN$(<nexpr>)							* done
                            	  9364: * BTST	. BTST(<nexpr>,<nexpr>)						* done
                            	  9365: * MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])			* done
                            	  9366: * MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])			* done
                            	  9367: * PI		. PI									* done
                            	  9368: * TWOPI	. TWOPI								* done
                            	  9369: * VARPTR	. VARPTR(<var>)							* done
                            	  9370: * SADD	. SADD(<svar>)							* done
                            	  9371: * LEFT$	. LEFT$(<sexpr>,<nexpr>)					* done
                            	  9372: * RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					* done
                            	  9373: * MID$	. MID$(<sexpr>,<nexpr>[,<nexpr>])				* done
                            	  9374: * USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])			* done
                            	  9375: 
                            	  9376: 
                            	  9377: *************************************************************************************
                            	  9378: 
                            	  9379: 	END	code_start
                            	  9380: 
                            	  9381: *************************************************************************************
                            	  9382: 


Symbols by name:
AC1gtAC2                         A:0000DAF8
ACIA_1                           E:00010040
ACIA_2                           E:00010041
Asptl                            A:000005A8
Asrch                            A:000005DA
Astrtl                           A:000005AC
BHsend                           A:000005D6
Bin2dec                          A:0000EAA8
BinPr                            A:0000E690
Binss                            A:000005B6
Blinel                           A:00000456
Breakf                           A:000005DC
Cflag                            A:000005E1
Clinel                           A:00000452
Cpntrl                           A:0000045A
Cvaral                           A:0000046E
Decss                            A:000005C6
Defdim                           A:000005B4
Dimcnt                           A:000005DB
Dlinel                           A:0000045E
DoCmp                            A:0000C70E
DoRest                           A:0000C6FA
Dptrl                            A:00000462
Dtypef                           E:000005B5
Earryl                           A:00000442
Ememl                            A:0000044A
EndBHS                           A:0000E66A
FAC1_e                           A:00000594
FAC1_m                           A:00000590
FAC1_s                           E:00000595
FAC2_e                           A:0000059C
FAC2_m                           A:00000598
FAC2_s                           E:0000059D
FAC_sc                           E:0000059E
FLASH_SUPPORT                    E:00000000
Gclctd                           A:000005DE
GetFirst                         A:0000CEDC
GetPair                          A:0000CF98
GoPr                             A:0000E69A
Hexss                            A:000005CE
INGET                            A:0000E6EE
Ibuffe                           A:00000590
Ibuffs                           A:00000490
Iclim                            A:000005E7
Imode                            A:000005E0
Itemp                            A:0000042A
KEY_ABS                          A:0000F308
KEY_AND                          A:0000F30C
KEY_ASC                          A:0000F30F
KEY_ATN                          A:0000F313
KEY_BINS                         A:0000F318
KEY_BITCLR                       A:0000F31D
KEY_BITSET                       A:0000F323
KEY_BITTST                       A:0000F329
KEY_CALL                         A:0000F331
KEY_CHRS                         A:0000F335
KEY_CLEAR                        A:0000F33A
KEY_CONT                         A:0000F33F
KEY_COS                          A:0000F343
KEY_DATA                         A:0000F348
KEY_DEC                          A:0000F34C
KEY_DEEK                         A:0000F34F
KEY_DEF                          A:0000F354
KEY_DIM                          A:0000F357
KEY_DIV                          A:0000F2FA
KEY_DO                           A:0000F35E
KEY_DOKE                         A:0000F35A
KEY_ELSE                         A:0000F361
KEY_END                          A:0000F365
KEY_EOR                          A:0000F368
KEY_EQUAL                        A:0000F300
KEY_EXP                          A:0000F36B
KEY_FN                           A:0000F373
KEY_FOR                          A:0000F370
KEY_FRE                          A:0000F375
KEY_GET                          A:0000F37A
KEY_GOSUB                        A:0000F381
KEY_GOTO                         A:0000F37D
KEY_GT                           A:0000F304
KEY_HEXS                         A:0000F387
KEY_IF                           A:0000F38D
KEY_INC                          A:0000F38F
KEY_INPUT                        A:0000F392
KEY_INT                          A:0000F397
KEY_LCASES                       A:0000F39C
KEY_LEEK                         A:0000F3A3
KEY_LEFTS                        A:0000F3A8
KEY_LEN                          A:0000F3AE
KEY_LET                          A:0000F3B2
KEY_LIST                         A:0000F3B5
KEY_LOAD                         A:0000F3B9
KEY_LOG                          A:0000F3BD
KEY_LOKE                         A:0000F3C1
KEY_LOOP                         A:0000F3C5
KEY_LSHIFT                       A:0000F2FC
KEY_LT                           A:0000F2FE
KEY_MAX                          A:0000F3CA
KEY_MIDS                         A:0000F3CE
KEY_MIN                          A:0000F3D3
KEY_MINUS                        A:0000F2F8
KEY_MULT                         A:0000F2F4
KEY_NEW                          A:0000F3D8
KEY_NEXT                         A:0000F3DB
KEY_NOT                          A:0000F3DF
KEY_NULL                         A:0000F3E2
KEY_ON                           A:0000F3E7
KEY_OR                           A:0000F3E9
KEY_PEEK                         A:0000F3EC
KEY_PI                           A:0000F3F1
KEY_PLUS                         A:0000F2F6
KEY_POKE                         A:0000F3F3
KEY_POS                          A:0000F3F7
KEY_POWER                        A:0000F49D
KEY_PRINT                        A:0000F3FB
KEY_RAM                          A:0000F401
KEY_READ                         A:0000F408
KEY_REM                          A:0000F40C
KEY_RESTORE                      A:0000F40F
KEY_RETURN                       A:0000F416
KEY_RIGHTS                       A:0000F41C
KEY_RND                          A:0000F423
KEY_RSHIFT                       A:0000F302
KEY_RUN                          A:0000F427
KEY_SADD                         A:0000F42B
KEY_SAVE                         A:0000F430
KEY_SGN                          A:0000F434
KEY_SIN                          A:0000F438
KEY_SPC                          A:0000F43C
KEY_SQR                          A:0000F440
KEY_STEP                         A:0000F444
KEY_STOP                         A:0000F448
KEY_STRS                         A:0000F44C
KEY_SWAP                         A:0000F451
KEY_TAB                          A:0000F456
KEY_TAN                          A:0000F45A
KEY_THEN                         A:0000F45E
KEY_TO                           A:0000F462
KEY_TWOPI                        A:0000F464
KEY_UCASES                       A:0000F46A
KEY_UNTIL                        A:0000F471
KEY_USINGS                       A:0000F476
KEY_USR                          A:0000F47D
KEY_VAL                          A:0000F482
KEY_VPTR                         A:0000F486
KEY_WAIT                         A:0000F48E
KEY_WHILE                        A:0000F492
KEY_WIDTH                        A:0000F497
KFCTSEED                         E:26A3D110
LAB_11A5                         A:0000CBAE
LAB_11A6                         A:0000CBB0
LAB_11BD                         A:0000CBBC
LAB_1269                         A:0000C1A2
LAB_1274                         A:0000C1B0
LAB_127D                         A:0000C1B8
LAB_127E                         A:0000C1C6
LAB_1295                         A:0000C1DA
LAB_12AE                         A:0000C1FC
LAB_12B0                         A:0000C1FE
LAB_12E6                         A:0000C21E
LAB_12FF                         A:0000C250
LAB_1301                         A:0000C252
LAB_1303                         A:0000C270
LAB_1325                         A:0000C288
LAB_132E                         A:0000C278
LAB_1330                         A:0000C27A
LAB_134B                         A:0000C296
LAB_1357                         A:0000C2B4
LAB_1359                         A:0000C2BA
LAB_1374                         A:0000C2DA
LAB_1378                         A:0000C2E0
LAB_137F                         A:0000C2EC
LAB_138E                         A:0000C2F2
LAB_1392                         A:0000C2F6
LAB_13A6                         A:0000C32A
LAB_13AC                         A:0000C332
LAB_13C6                         A:0000C35C
LAB_13CC                         A:0000C362
LAB_13D6                         A:0000C384
LAB_13D8                         A:0000C38A
LAB_13EA                         A:0000C396
LAB_13EC                         A:0000C398
LAB_13FF                         A:0000C3B0
LAB_1401                         A:0000C3B4
LAB_1408                         A:0000C3C0
LAB_1410                         A:0000C3CC
LAB_1417                         A:0000C3D6
LAB_141B                         A:0000C3D8
LAB_141F                         A:0000C3E8
LAB_142A                         A:0000C3EE
LAB_142C                         A:0000C3FA
LAB_145E                         A:0000C414
LAB_145F                         A:0000C406
LAB_1463                         A:0000C41C
LAB_1477                         A:0000C428
LAB_147A                         A:0000C42E
LAB_1480                         A:0000C448
LAB_1491                         A:0000C452
LAB_14BD                         A:0000C482
LAB_14C0                         A:0000C486
LAB_14D4                         A:0000C4A6
LAB_14E2                         A:0000C4C2
LAB_150C                         A:0000C4D0
LAB_1519                         A:0000C4DE
LAB_152E                         A:0000C4EA
LAB_1540                         A:0000C516
LAB_15B3                         A:0000C576
LAB_15C2                         A:0000C5A0
LAB_15D1                         A:0000C5AC
LAB_15DC                         A:0000C588
LAB_15F6                         A:0000C59A
LAB_15FF                         A:0000C5BA
LAB_1602                         A:0000C5BE
LAB_1624                         A:0000C642
LAB_1629                         A:0000C5E2
LAB_1636                         A:0000C5E6
LAB_1639                         A:0000C5EC
LAB_163B                         A:0000C5F8
LAB_1647                         A:0000C604
LAB_164F                         A:0000C60A
LAB_16B0                         A:0000C6A2
LAB_16D0                         A:0000C6C6
LAB_1723                         A:0000C760
LAB_1725                         A:0000C764
LAB_172C                         A:0000C750
LAB_172D                         A:0000C758
LAB_174B                         A:0000C78C
LAB_174E                         A:0000C7B0
LAB_1750                         A:0000C7B8
LAB_1752                         A:0000C7C4
LAB_1754                         A:0000C7DC
LAB_1756                         A:0000C7C8
LAB_176C                         A:0000C7FA
LAB_1773                         A:0000C804
LAB_1785                         A:0000C820
LAB_1786                         A:0000C84C
LAB_17B7                         A:0000C862
LAB_17B8                         A:0000C85E
LAB_17D5                         A:0000C8DC
LAB_17D6                         A:0000C8E0
LAB_1810                         A:0000C8F2
LAB_1811                         A:0000C902
LAB_1813                         A:0000C908
LAB_1829                         A:0000C940
LAB_182C                         A:0000C944
LAB_1831                         A:0000C94A
LAB_185E                         A:0000C98A
LAB_1866                         A:0000C98E
LAB_1880                         A:0000CA50
LAB_1886                         A:0000CA5A
LAB_188A                         A:0000CA5E
LAB_188B                         A:0000C99C
LAB_1898                         A:0000C9AA
LAB_18A2                         A:0000C9B4
LAB_18B7                         A:0000C9D6
LAB_18B8                         A:0000C9E2
LAB_18BD                         A:0000C9E8
LAB_18C3                         A:0000C9F2
LAB_18C6                         A:0000C9F6
LAB_18CD                         A:0000CA00
LAB_18E3                         A:0000CA0A
LAB_18F0                         A:0000CA2A
LAB_18F7                         A:0000CA38
LAB_18F9                         A:0000CA3C
LAB_1904                         A:0000CA62
LAB_1913                         A:0000CA74
LAB_1934                         A:0000CA9A
LAB_1953                         A:0000CAAE
LAB_195B                         A:0000CAB6
LAB_1961                         A:0000CAC0
LAB_1984                         A:0000CAE0
LAB_1985                         A:0000CAE4
LAB_1986                         A:0000CAE8
LAB_1999                         A:0000CAFC
LAB_19B0                         A:0000CB0E
LAB_19B6                         A:0000CB1E
LAB_19C2                         A:0000CB2E
LAB_19DD                         A:0000CB42
LAB_19F6                         A:0000CB62
LAB_1A03                         A:0000CB70
LAB_1A0E                         A:0000CB80
LAB_1A1B                         A:0000CB86
LAB_1A46                         A:0000CBA0
LAB_1A90                         A:0000CC1E
LAB_1A9B                         A:0000CC2C
LAB_1ABA                         A:0000CC56
LAB_1ACD                         A:0000CC82
LAB_1ADB                         A:0000CC8E
LAB_1ADE                         A:0000CC92
LAB_1AE0                         A:0000CCA8
LAB_1AFA                         A:0000CCC2
LAB_1B0B                         A:0000CCD8
LAB_1B13                         A:0000CCE0
LAB_1B1C                         A:0000CCF0
LAB_1B1D                         A:0000CCF2
LAB_1B2A                         A:0000CD04
LAB_1B3C                         A:0000CD20
LAB_1B43                         A:0000CC66
LAB_1B78                         A:0000CD2C
LAB_1B7B                         A:0000CD30
LAB_1B7D                         A:0000CD32
LAB_1B84                         A:0000CD3C
LAB_1B86                         A:0000CD40
LAB_1B9D                         A:0000CD64
LAB_1BC1                         A:0000CD94
LAB_1BD0                         A:0000CE00
LAB_1BE7                         A:0000CE1A
LAB_1BF3                         A:0000CDA0
LAB_1BF7                         A:0000CDA6
LAB_1BFB                         A:0000CDAA
LAB_1C01                         A:0000CDB2
LAB_1C11                         A:0000CDDA
LAB_1C13                         A:0000CDE0
LAB_1C18                         A:0000CDE6
LAB_1C19                         A:0000CDEA
LAB_1C1A                         A:0000CDFA
LAB_1C2A                         A:0000CE58
LAB_1CAE                         A:0000CF00
LAB_1CB5                         A:0000CF1E
LAB_1CD4                         A:0000CF28
LAB_1CD5                         A:0000CF2E
LAB_1CD6                         A:0000CF30
LAB_1CDB                         A:0000CF40
LAB_1CE6                         A:0000CF32
LAB_1CF2                         A:0000CF42
LAB_1CFE                         A:0000CF58
LAB_1D10                         A:0000CFD0
LAB_1D12                         A:0000CFD4
LAB_1D2D                         A:0000CFE6
LAB_1D2E                         A:0000CFF2
LAB_1D44                         A:0000D00E
LAB_1D45                         A:0000D01E
LAB_1D48                         A:0000D032
LAB_1D49                         A:0000D03A
LAB_1D4A                         A:0000D03E
LAB_1D4B                         A:0000D04E
LAB_1D5D                         A:0000D056
LAB_1D5E                         A:0000D05C
LAB_1D83                         A:0000CFC0
LAB_1D8A                         A:0000CFBA
LAB_1D94                         A:0000D070
LAB_1D96                         A:0000ED9E
LAB_1D98                         A:0000D07A
LAB_1DAC                         A:0000D094
LAB_1DAE                         A:0000D096
LAB_1DAF                         A:0000D0A2
LAB_1DB0                         A:0000D0B0
LAB_1DB1                         A:0000D0B4
LAB_1DB2                         A:0000D0B8
LAB_1DD7                         A:0000D0D0
LAB_1DE6                         A:0000D0EA
LAB_1E17                         A:0000D12C
LAB_1E1F                         A:0000D132
LAB_1E5C                         A:0000D16C
LAB_1E8D                         A:0000D188
LAB_1EA1                         A:0000D1A4
LAB_1EC0                         A:0000D1CC
LAB_1ED6                         A:0000D1F8
LAB_1ED8                         A:0000D206
LAB_1EDF                         A:0000D1C0
LAB_1F07                         A:0000D218
LAB_1F28                         A:0000D232
LAB_1F2C                         A:0000D238
LAB_1F5A                         A:0000D246
LAB_1F6A                         A:0000D26E
LAB_1F6B                         A:0000D27A
LAB_1F7C                         A:0000D280
LAB_1FB4                         A:0000D2AE
LAB_1FD0                         A:0000D2DA
LAB_201E                         A:0000D334
LAB_2043                         A:0000D382
LAB_2044                         A:0000D3B4
LAB_2045                         A:0000D3BE
LAB_204S                         A:0000D384
LAB_204T                         A:0000D3B2
LAB_20AE                         A:0000D3D0
LAB_20B4                         A:0000D3D4
LAB_20BE                         A:0000D3DA
LAB_20C9                         A:0000D3FE
LAB_20CB                         A:0000D3EA
LAB_20D0                         A:0000D3F2
LAB_20D8                         A:0000D408
LAB_20E0                         A:0000D410
LAB_2115                         A:0000D430
LAB_2117                         A:0000D448
LAB_2128                         A:0000D462
LAB_2137                         A:0000D466
LAB_214B                         A:0000D486
LAB_2161                         A:0000D49A
LAB_2176                         A:0000D4A0
LAB_217E                         A:0000D4AC
LAB_2183                         A:0000D4C6
LAB_218B                         A:0000D4CE
LAB_218F                         A:0000D4D0
LAB_21C2                         A:0000D4DC
LAB_21C4                         A:0000D4E0
LAB_21D1                         A:0000D514
LAB_2206                         A:0000D51A
LAB_2212                         A:0000D542
LAB_2216                         A:0000D504
LAB_2240                         A:0000D50C
LAB_224D                         A:0000D548
LAB_224E                         A:0000D55E
LAB_229E                         A:0000D5A2
LAB_22A0                         A:0000D5AE
LAB_22B6                         A:0000D5BC
LAB_22BA                         A:0000D5C0
LAB_22BD                         A:0000D5CA
LAB_22E6                         A:0000D5E4
LAB_2316                         A:0000D624
LAB_2317                         A:0000D626
LAB_231C                         A:0000D62A
LAB_2358                         A:0000D65E
LAB_2368                         A:0000D67E
LAB_2441                         A:0000D870
LAB_2445                         A:0000D874
LAB_2467                         A:0000D8C4
LAB_2468                         A:0000D8C8
LAB_249C                         A:0000D8B6
LAB_24A8                         A:0000D8CC
LAB_24B4                         A:0000D8F6
LAB_24D0                         A:0000D902
LAB_24D5                         A:0000D90C
LAB_24D6                         A:0000D926
LAB_24D7                         A:0000D934
LAB_24D8                         A:0000D93A
LAB_24D9                         A:0000D91A
LAB_24DA                         A:0000D940
LAB_24F7                         A:0000D8E6
LAB_24F8                         A:0000D8EC
LAB_2778                         A:0000DBA8
LAB_277C                         A:0000DBAA
LAB_279B                         A:0000DBCE
LAB_27BA                         A:0000DBDC
LAB_27C3                         A:0000DBF8
LAB_27C4                         A:0000DC02
LAB_27CA                         A:0000DC08
LAB_27CE                         A:0000DC10
LAB_27D0                         A:0000DC14
LAB_27DB                         A:0000DC22
LAB_27F0                         A:0000DEDE
LAB_27F1                         A:0000DEF4
LAB_27F2                         A:0000DEFA
LAB_27F3                         A:0000DEFC
LAB_27FA                         A:0000DC3A
LAB_2828                         A:0000DC5A
LAB_282E                         A:0000DC60
LAB_282F                         A:0000DC62
LAB_2831                         A:0000DC66
LAB_284G                         A:0000DC88
LAB_284H                         A:0000DC9A
LAB_284J                         A:0000DC9C
LAB_284L                         A:0000DC90
LAB_2887                         A:0000E896
LAB_289A                         A:0000E8C0
LAB_289C                         A:0000E8C6
LAB_289D                         A:0000E8CC
LAB_28FD                         A:0000E8E8
LAB_28FE                         A:0000E8EE
LAB_28FF                         A:0000E8F4
LAB_2900                         A:0000E902
LAB_2901                         A:0000E908
LAB_2902                         A:0000E95A
LAB_2903                         A:0000E962
LAB_2904                         A:0000E964
LAB_2953                         A:0000DCBC
LAB_295E                         A:0000DCC8
LAB_2967                         A:0000DCD4
LAB_2968                         A:0000DCDC
LAB_2969                         A:0000DCEE
LAB_296A                         A:0000DCF8
LAB_2970                         A:0000DD0E
LAB_2978                         A:0000DD1E
LAB_2989                         A:0000DD2E
LAB_299C                         A:0000DD82
LAB_29A7                         A:0000DDAA
LAB_29B7                         A:0000DDC2
LAB_29B9                         A:0000DD5A
LAB_29C0                         A:0000DDD0
LAB_29C3                         A:0000DDE8
LAB_29D9                         A:0000DE02
LAB_29E4                         A:0000DE14
LAB_29F7                         A:0000DE28
LAB_29FB                         A:0000DE2C
LAB_29FD                         A:0000DE34
LAB_2A18                         A:0000DE44
LAB_2A1A                         A:0000DE46
LAB_2A21                         A:0000DE4E
LAB_2A3B                         A:0000DE6E
LAB_2A4B                         A:0000DE7C
LAB_2A58                         A:0000DE90
LAB_2A68                         A:0000DEA8
LAB_2A74                         A:0000DEB4
LAB_2A89                         A:0000DED0
LAB_2A8C                         A:0000DED4
LAB_2A91                         A:0000DEDA
LAB_2A9A                         A:0000EF42
LAB_2A9B                         A:0000EF5E
LAB_2X01                         A:0000E920
LAB_2X02                         A:0000E928
LAB_2X03                         A:0000E936
LAB_2X04                         A:0000E93C
LAB_2X05                         A:0000E952
LAB_2Y01                         A:0000E972
LAB_2Y02                         A:0000E97A
LAB_2Y03                         A:0000E986
LAB_2Y04                         A:0000E98C
LAB_3216                         A:0000DB42
LAB_32_16                        A:0000DB40
LAB_ABER                         A:0000C164
LAB_ABS                          A:0000DC32
LAB_AD                           A:0000F2D5
LAB_ADD                          A:0000D892
LAB_ADER                         A:0000C130
LAB_AND                          A:0000CED4
LAB_ASC                          A:0000D708
LAB_ATCD                         A:0000E276
LAB_ATGO                         A:0000E234
LAB_ATLE                         A:0000E252
LAB_ATN                          A:0000E216
LAB_ATNP                         A:0000E270
LAB_AYFC                         A:0000D2BA
LAB_BAER                         A:0000F15C
LAB_BHCB                         A:0000CEBA
LAB_BHSS                         A:0000CE94
LAB_BINS                         A:0000E64C
LAB_BITCLR                       A:0000E2D8
LAB_BITSET                       A:0000E2C8
LAB_BMSG                         A:0000F49F
LAB_BS                           A:0000F1FE
LAB_BTST                         A:0000E2E8
LAB_CALL                         A:0000D850
LAB_CASC                         A:0000CFAA
LAB_CATN                         A:0000E27C
LAB_CAUC                         A:0000CFB0
LAB_CBIN                         A:0000EA46
LAB_CBX1                         A:0000EA60
LAB_CBXN                         A:0000EA4E
LAB_CCER                         A:0000C148
LAB_CHEX                         A:0000E9E4
LAB_CHRS                         A:0000D5EE
LAB_CHX1                         A:0000EA0A
LAB_CHX2                         A:0000EA2E
LAB_CHX3                         A:0000EA26
LAB_CHXX                         A:0000E9EC
LAB_CKRN                         A:0000D2E2
LAB_CKTM                         A:0000CC48
LAB_CLEAR                        A:0000C46A
LAB_CN                           A:0000F26B
LAB_COLD                         A:0000C06A
LAB_CONT                         A:0000C654
LAB_CORD                         A:0000E1AE
LAB_COS                          A:0000E13E
LAB_CRLF                         A:0000C994
LAB_CTBL                         A:0000EE26
LAB_CTNM                         A:0000CC46
LAB_D0                           A:0000F21C
LAB_D002                         A:0000E5B0
LAB_D00A                         A:0000E5C0
LAB_D00E                         A:0000E5D0
LAB_DATA                         A:0000C742
LAB_DD                           A:0000F20B
LAB_DDER                         A:0000C160
LAB_DEC                          A:0000C852
LAB_DECI                         A:0000C8B0
LAB_DEEK                         A:0000D7CE
LAB_DEF                          A:0000D2EC
LAB_DIM                          A:0000CF5C
LAB_DIV0                         A:0000DB3A
LAB_DIVIDE                       A:0000DAC0
LAB_DIVX                         A:0000DB10
LAB_DO                           A:0000C686
LAB_DOKE                         A:0000D7F8
LAB_DZER                         A:0000C15C
LAB_DupFmt                       A:0000E598
LAB_EMSG                         A:0000F4A7
LAB_END                          A:0000C5EE
LAB_EOR                          A:0000CEC4
LAB_EQUAL                        A:0000CEEA
LAB_ESML                         A:0000E054
LAB_EVBY                         A:0000D720
LAB_EVEX                         A:0000CC5C
LAB_EVEZ                         A:0000CC5E
LAB_EVIN                         A:0000D0F6
LAB_EVIR                         A:0000D106
LAB_EVNM                         A:0000CC44
LAB_EVPI                         A:0000D0FE
LAB_EX1                          A:0000DF8C
LAB_EXAD                         A:0000E0DE
LAB_EXCC                         A:0000E0C4
LAB_EXCM                         A:0000DFF6
LAB_EXNN                         A:0000E0B0
LAB_EXOF                         A:0000DFB0
LAB_EXOL                         A:0000DFC6
LAB_EXOU                         A:0000DF9C
LAB_EXP                          A:0000DFD0
LAB_EXPL                         A:0000E0AA
LAB_EXPS                         A:0000E008
LAB_EXRN                         A:0000E0B6
LAB_FB95                         A:0000E6FE
LAB_FBA0                         A:0000E6E2
LAB_FC                           A:0000F1C5
LAB_FCER                         A:0000C174
LAB_FO                           A:0000F2DD
LAB_FOER                         A:0000C12C
LAB_FOR                          A:0000C522
LAB_FRE                          A:0000D2A4
LAB_FTBL                         A:0000EEC2
LAB_FTPP                         A:0000EE76
LAB_FVAR                         A:0000CFC8
LAB_GADB                         A:0000D772
LAB_GADW                         A:0000D786
LAB_GARB                         A:0000D47C
LAB_GBYT                         A:0000CDBE
LAB_GEAD                         A:0000D7A6
LAB_GET                          A:0000C90E
LAB_GETS                         A:0000C928
LAB_GFPN                         A:0000C814
LAB_GOSUB                        A:0000C698
LAB_GOTO                         A:0000C6AA
LAB_GOTs                         A:0000C6BA
LAB_GSCH                         A:0000C63A
LAB_GTBY                         A:0000D71C
LAB_GTHAN                        A:0000DF7E
LAB_GTWO                         A:0000D730
LAB_GVAL                         A:0000CD6A
LAB_GVAR                         A:0000CFCA
LAB_HEXS                         A:0000E69E
LAB_ID                           A:0000F22B
LAB_IDER                         A:0000C158
LAB_IF                           A:0000C76A
LAB_IGBY                         A:0000CDBC
LAB_IMSG                         A:0000F4B8
LAB_INC                          A:0000C858
LAB_INCI                         A:0000C8A6
LAB_INCT                         A:0000C898
LAB_INLN                         A:0000C2AA
LAB_INPUT                        A:0000CA82
LAB_INT                          A:0000DCA2
LAB_IRTS                         A:0000DCBA
LAB_ISHN                         A:0000EA06
LAB_KEYT                         A:0000EFC8
LAB_LAAD                         A:0000D9BA
LAB_LCASE                        A:0000D686
LAB_LD                           A:0000F28D
LAB_LDER                         A:0000C140
LAB_LEEK                         A:0000D7E4
LAB_LEFT                         A:0000D5FE
LAB_LENS                         A:0000D700
LAB_LET                          A:0000C8B4
LAB_LIST                         A:0000C46E
LAB_LMSG                         A:0000F4AE
LAB_LOAD                         A:0000D848
LAB_LOCC                         A:0000D9C0
LAB_LOCX                         A:0000D9DC
LAB_LOG                          A:0000D942
LAB_LOKE                         A:0000D7FE
LAB_LOLP                         A:0000D9CA
LAB_LONE                         A:0000D9F8
LAB_LONN                         A:0000D9E0
LAB_LOOP                         A:0000C6D8
LAB_LOWZ                         A:0000DA32
LAB_LOXO                         A:0000D9FE
LAB_LOXP                         A:0000D9EE
LAB_LRMS                         A:0000CE72
LAB_LS                           A:0000F248
LAB_LSHIFT                       A:0000CF68
LAB_LTHAN                        A:0000CEF4
LAB_LTPF                         A:0000E1BC
LAB_LTPT                         A:0000E1C8
LAB_LT_1                         A:0000DB4E
LAB_MADD                         A:0000DA60
LAB_MAN1                         A:0000DB34
LAB_MAX                          A:0000E70A
LAB_MAXN                         A:0000E716
LAB_MIDS                         A:0000D642
LAB_MIN                          A:0000E720
LAB_MINN                         A:0000E72C
LAB_MKCHR                        A:0000D5F2
LAB_MMEC                         A:0000E736
LAB_MNOC                         A:0000DA5A
LAB_MUEX                         A:0000DAAE
LAB_MUF1                         A:0000DA8A
LAB_MUF2                         A:0000DA94
LAB_MUF3                         A:0000DAAA
LAB_MULTIPLY                     A:0000DA34
LAB_MUUF                         A:0000DAB4
LAB_NB1T                         A:0000DB86
LAB_NEW                          A:0000C41A
LAB_NEXT                         A:0000CB8E
LAB_NF                           A:0000F18C
LAB_NFER                         A:0000C184
LAB_NI                           A:0000F2E4
LAB_NSTT                         A:0000E79A
LAB_NULL                         A:0000C64A
LAB_NoSt                         A:0000C93A
LAB_OD                           A:0000F1B9
LAB_ODER                         A:0000C178
LAB_OFER                         A:0000C170
LAB_OM                           A:0000F1DC
LAB_OMER                         A:0000C16C
LAB_ON                           A:0000C7E0
LAB_OPPT                         A:0000EF0E
LAB_OR                           A:0000CECC
LAB_OV                           A:0000F1D3
LAB_P004                         A:0000E5EE
LAB_P008                         A:0000E604
LAB_P00C                         A:0000E60C
LAB_P00E                         A:0000E618
LAB_P010                         A:0000E61C
LAB_P018                         A:0000E636
LAB_P01A                         A:0000E63A
LAB_P01E                         A:0000E642
LAB_PEEK                         A:0000D7BC
LAB_PFAC                         A:0000DB90
LAB_PHFA                         A:0000E744
LAB_PI                           A:0000E876
LAB_POKE                         A:0000D7C8
LAB_POON                         A:0000DEFE
LAB_POS                          A:0000D2D6
LAB_POWER                        A:0000DF1A
LAB_POWP                         A:0000DF4C
LAB_POZE                         A:0000DF0E
LAB_PPBI                         A:0000CE68
LAB_PPFN                         A:0000CE5A
LAB_PPFS                         A:0000CE4C
LAB_PRINT                        A:0000C948
LAB_PRNA                         A:0000CA0C
LAB_P_10                         A:0000EBB8
LAB_ProcFo                       A:0000E5D6
LAB_RAM                          A:0000E86C
LAB_READ                         A:0000CAA8
LAB_REDO                         A:0000F4C8
LAB_REM                          A:0000C7D8
LAB_REMM                         A:0000DB66
LAB_RESTORE                      A:0000C61C
LAB_RESs                         A:0000C62E
LAB_RETURN                       A:0000C72E
LAB_RG                           A:0000F1A4
LAB_RGER                         A:0000C17C
LAB_RIGHT                        A:0000D612
LAB_RMSG                         A:0000F4DA
LAB_RND                          A:0000E0EA
LAB_RSED                         A:0000EAD0
LAB_RSHIFT                       A:0000CF78
LAB_RTST                         A:0000D416
LAB_RUN                          A:0000C672
LAB_RUNn                         A:0000C680
LAB_SADD                         A:0000D6E8
LAB_SAVE                         A:0000D84C
LAB_SCCA                         A:0000CDB4
LAB_SCER                         A:0000C14C
LAB_SCGB                         A:0000CDAE
LAB_SCL0                         A:0000E1A4
LAB_SCLN                         A:0000C408
LAB_SCZE                         A:0000E196
LAB_SET1                         A:0000DB18
LAB_SGBY                         A:0000D718
LAB_SGN                          A:0000DC20
LAB_SIN                          A:0000E156
LAB_SLER                         A:0000C150
LAB_SMSG                         A:0000F4E4
LAB_SN                           A:0000F19D
LAB_SNBS                         A:0000C748
LAB_SNER                         A:0000C180
LAB_SQE1                         A:0000E81E
LAB_SQE2                         A:0000E824
LAB_SQNA                         A:0000E84C
LAB_SQNS                         A:0000E836
LAB_SQR                          A:0000E7FA
LAB_SSLN                         A:0000C400
LAB_ST                           A:0000F258
LAB_STOP                         A:0000C5F6
LAB_STRS                         A:0000D3CC
LAB_SUBTRACT                     A:0000D87E
LAB_SVAR                         A:0000CFC6
LAB_SVTB                         A:0000E7CC
LAB_SWAP                         A:0000D812
LAB_TAN                          A:0000E11C
LAB_TBSZ                         A:0000E7AC
LAB_TM                           A:0000F23A
LAB_TMER                         A:0000C154
LAB_TWOPI                        A:0000E886
LAB_U002                         A:0000E340
LAB_U004                         A:0000E396
LAB_U005                         A:0000E3A6
LAB_U006                         A:0000E3A8
LAB_U008                         A:0000E3BC
LAB_U009                         A:0000E3DE
LAB_U00A                         A:0000E3E6
LAB_U00B                         A:0000E3F0
LAB_U00C                         A:0000E404
LAB_U00D                         A:0000E408
LAB_U00E                         A:0000E41A
LAB_U00F                         A:0000E426
LAB_U010                         A:0000E42A
LAB_U014                         A:0000E430
LAB_U018                         A:0000E438
LAB_U01C                         A:0000E44E
LAB_U020                         A:0000E45A
LAB_U022                         A:0000E460
LAB_U026                         A:0000E470
LAB_U02A                         A:0000E47A
LAB_U02B                         A:0000E492
LAB_U02C                         A:0000E498
LAB_U02E                         A:0000E4AA
LAB_U030                         A:0000E4AE
LAB_U034                         A:0000E4C4
LAB_U036                         A:0000E4CA
LAB_U038                         A:0000E4D2
LAB_U03C                         A:0000E4DA
LAB_U03E                         A:0000E4E0
LAB_U040                         A:0000E4F8
LAB_U044                         A:0000E508
LAB_U046                         A:0000E530
LAB_U048                         A:0000E532
LAB_U04A                         A:0000E53C
LAB_U04C                         A:0000E56E
LAB_UA                           A:0000F2B0
LAB_UCASE                        A:0000D6B6
LAB_UDER                         A:0000C138
LAB_UF                           A:0000F27A
LAB_UFAC                         A:0000DB74
LAB_UFER                         A:0000C144
LAB_US                           A:0000F1EA
LAB_USER                         A:0000C168
LAB_USINGS                       A:0000E316
LAB_USR                          A:0000D840
LAB_UV                           A:0000F29D
LAB_UVER                         A:0000C13C
LAB_VAL                          A:0000D744
LAB_VALZ                         A:0000D76C
LAB_VARCALL                      A:0000E85E
LAB_VARPTR                       A:0000E85C
LAB_WAIT                         A:0000D85A
LAB_WARM                         A:00000400
LAB_WD                           A:0000F2C4
LAB_WDER                         A:0000C134
LAB_WDLP                         A:0000E7E0
LAB_WDTH                         A:0000E77A
LAB_XDIV                         A:0000DB28
LAB_XERR                         A:0000C186
LAB_XGADW                        A:0000D7A0
LAB_exxf                         A:0000EA34
LAB_ret0                         A:0000E9D2
LAB_rtn0                         A:0000E9D4
LAB_sizok                        A:0000C07A
LC_loop                          A:0000D69C
L_DDIV                           A:0000DB6E
L_DIVRND                         A:0000DB1C
LoopAlways                       A:0000C714
LoopDone                         A:0000C728
Lvarpl                           A:00000472
NextB1                           A:0000E65C
NextB2                           A:0000E682
NextH1                           A:0000E6AE
NextPRN                          A:0000E0F8
Ninc0                            A:0000E100
Ninc1                            A:0000E106
NoLcase                          A:0000D6DE
NoShift                          A:0000CF74
NoString                         A:0000D6E4
NoUcase                          A:0000D6AE
Not2Big                          A:0000CF8C
Nullct                           A:000005E4
Oquote                           A:000005DD
PRNlword                         A:000005A0
RTS_001                          A:0000CDD8
RTS_005                          A:0000C468
RTS_006                          A:0000C648
RTS_007                          A:0000C746
RTS_007a                         A:0000C75C
RTS_008                          A:0000C90C
RTS_009                          A:0000CA08
RTS_011                          A:0000D27E
RTS_012                          A:0000D546
RTS_013                          A:0000D5BA
RTS_015                          A:0000D810
RTS_016                          A:0000D8EA
RTS_017                          A:0000DC06
RTS_020                          A:0000DF8A
RTS_021                          A:0000E2C6
RTS_022                          A:0000E6EC
RTS_023                          A:0000E7F8
RTS_024                          A:0000EA44
RTS_025                          A:0000EAA6
RXNOTREADY                       A:0000C03A
Rdptrl                           A:00000466
Sarryl                           A:0000043E
Sfncl                            A:00000432
Smeml                            A:0000042E
Sstorl                           A:00000446
Sstrl                            A:0000043A
Sufnxf                           A:000005DF
Sutill                           A:0000044E
Svarl                            A:00000436
TAB_ASCA                         A:0000F308
TAB_ASCB                         A:0000F318
TAB_ASCC                         A:0000F331
TAB_ASCD                         A:0000F348
TAB_ASCE                         A:0000F361
TAB_ASCF                         A:0000F370
TAB_ASCG                         A:0000F37A
TAB_ASCH                         A:0000F387
TAB_ASCI                         A:0000F38D
TAB_ASCL                         A:0000F39C
TAB_ASCM                         A:0000F3CA
TAB_ASCN                         A:0000F3D8
TAB_ASCO                         A:0000F3E7
TAB_ASCP                         A:0000F3EC
TAB_ASCR                         A:0000F401
TAB_ASCS                         A:0000F42B
TAB_ASCT                         A:0000F456
TAB_ASCU                         A:0000F46A
TAB_ASCV                         A:0000F482
TAB_ASCW                         A:0000F48E
TAB_ATNC                         A:0000ED26
TAB_CHRT                         A:0000EF5E
TAB_EQUL                         A:0000F300
TAB_HTHET                        A:0000EDA6
TAB_LESS                         A:0000F2FC
TAB_MNUS                         A:0000F2F8
TAB_MORE                         A:0000F302
TAB_PLUS                         A:0000F2F6
TAB_POWR                         A:0000F49D
TAB_QEST                         A:0000F306
TAB_SLAS                         A:0000F2FA
TAB_SNCO                         A:0000ECA6
TAB_STAR                         A:0000F2F4
TK_ABS                           E:000000C1
TK_AND                           E:000000B7
TK_ASC                           E:000000D3
TK_ATN                           E:000000CC
TK_BINS                          E:000000D8
TK_BITCLR                        E:000000A7
TK_BITSET                        E:000000A6
TK_BITTST                        E:000000D9
TK_CALL                          E:0000009B
TK_CHRS                          E:000000D6
TK_CLEAR                         E:000000A1
TK_CONT                          E:0000009F
TK_COS                           E:000000C9
TK_DATA                          E:00000083
TK_DEC                           E:00000088
TK_DEEK                          E:000000CE
TK_DEF                           E:00000097
TK_DIM                           E:00000085
TK_DIV                           E:000000B5
TK_DO                            E:0000009C
TK_DOKE                          E:00000099
TK_ELSE                          E:000000A9
TK_END                           E:00000080
TK_EOR                           E:000000B8
TK_EQUAL                         E:000000BD
TK_EXP                           E:000000C8
TK_FN                            E:000000AB
TK_FOR                           E:00000081
TK_FRE                           E:000000C3
TK_GET                           E:000000A4
TK_GOSUB                         E:0000008D
TK_GOTO                          E:00000089
TK_GT                            E:000000BC
TK_HEXS                          E:000000D7
TK_IF                            E:0000008B
TK_INC                           E:00000093
TK_INPUT                         E:00000084
TK_INT                           E:000000C0
TK_LCASES                        E:000000D5
TK_LEEK                          E:000000CF
TK_LEFTS                         E:000000E1
TK_LEN                           E:000000D0
TK_LET                           E:00000087
TK_LIST                          E:000000A0
TK_LOAD                          E:00000095
TK_LOG                           E:000000C7
TK_LOKE                          E:0000009A
TK_LOOP                          E:0000009D
TK_LSHIFT                        E:000000BB
TK_LT                            E:000000BE
TK_MAX                           E:000000DA
TK_MIDS                          E:000000E3
TK_MIN                           E:000000DB
TK_MINUS                         E:000000B3
TK_MULT                          E:000000B4
TK_NEW                           E:000000A2
TK_NEXT                          E:00000082
TK_NOT                           E:000000AE
TK_NULL                          E:00000092
TK_ON                            E:00000091
TK_OR                            E:000000B9
TK_PEEK                          E:000000CD
TK_PI                            E:000000DD
TK_PLUS                          E:000000B2
TK_POKE                          E:00000098
TK_POS                           E:000000C4
TK_POWER                         E:000000B6
TK_PRINT                         E:0000009E
TK_RAM                           E:000000DC
TK_READ                          E:00000086
TK_REM                           E:0000008F
TK_RESTORE                       E:0000008C
TK_RETURN                        E:0000008E
TK_RIGHTS                        E:000000E2
TK_RND                           E:000000C6
TK_RSHIFT                        E:000000BA
TK_RUN                           E:0000008A
TK_SADD                          E:000000E0
TK_SAVE                          E:00000096
TK_SGN                           E:000000BF
TK_SIN                           E:000000CA
TK_SPC                           E:000000AC
TK_SQR                           E:000000C5
TK_STEP                          E:000000AF
TK_STOP                          E:00000090
TK_STRS                          E:000000D1
TK_SWAP                          E:000000A5
TK_TAB                           E:000000A8
TK_TAN                           E:000000CB
TK_THEN                          E:000000AD
TK_TO                            E:000000AA
TK_TWOPI                         E:000000DE
TK_UCASES                        E:000000D4
TK_UNTIL                         E:000000B0
TK_USINGS                        E:000000E4
TK_USR                           E:000000C2
TK_VAL                           E:000000D2
TK_VPTR                          E:000000DF
TK_WAIT                          E:00000094
TK_WHILE                         E:000000B1
TK_WIDTH                         E:000000A3
TPos                             A:000005E5
TWidth                           A:000005E6
TXNOTREADY                       A:0000C00A
TabSiz                           A:000005E2
TooBig                           A:0000CF92
UC_loop                          A:0000D6CC
Usdss                            A:000005CC
Usrjmp                           A:00000406
Usrjpv                           A:00000408
VEC_CC                           A:0000E6C8
VEC_IN                           A:0000C01C
VEC_LD                           A:0000C044
VEC_OUT                          A:0000C002
VEC_SV                           A:0000C04A
V_CTLC                           A:00000424
V_CTLCv                          A:00000426
V_INPT                           A:0000040C
V_INPTv                          A:0000040E
V_LOAD                           A:00000418
V_LOADv                          A:0000041A
V_OUTP                           A:00000412
V_OUTPv                          A:00000414
V_SAVE                           A:0000041E
V_SAVEv                          A:00000420
Varname                          A:0000046A
WExit                            A:0000E7D0
Wrmjpv                           A:00000402
ccbyte                           A:000005E9
ccflag                           A:000005E8
ccnull                           A:000005EA
code_start                       A:0000C050
comp_f                           A:000005E3
cosout                           E:000005B4
d1x02                            A:0000EA82
d1x10                            A:0000EA98
d1x16                            A:0000EA74
des_sk                           A:0000048E
des_sk_e                         A:00000476
expcnt                           E:000005AD
expneg                           E:000005AF
fend                             E:00000008
flag                             E:0000059F
fsd                              E:00000000
fsdc                             E:0000000A
fsdpi                            E:00000008
fsli                             E:00000006
fsti                             E:00000004
func_l                           A:000005B0
mainloop                         A:0000E1E0
nexta                            A:0000E1F2
nobrk                            E:00000000
novar                            E:00000000
numexp                           E:000005AC
ofchr                            E:00000023
outloop                          A:0000E200
prg_strt                         A:000005EC
prstk                            A:000005D8
ram_addr                         E:00002000
ram_base                         A:00000400
ram_size                         E:00006000
ram_strt                         A:00000000
subexit                          A:0000E20A
subloop                          A:0000E1D8
tpower                           A:000005D9
ut1_pl                           A:000005A4

Symbols by value:
00000000 FLASH_SUPPORT
00000000 fsd
00000000 nobrk
00000000 novar
00000000 ram_strt
00000004 fsti
00000006 fsli
00000008 fend
00000008 fsdpi
0000000A fsdc
00000023 ofchr
00000080 TK_END
00000081 TK_FOR
00000082 TK_NEXT
00000083 TK_DATA
00000084 TK_INPUT
00000085 TK_DIM
00000086 TK_READ
00000087 TK_LET
00000088 TK_DEC
00000089 TK_GOTO
0000008A TK_RUN
0000008B TK_IF
0000008C TK_RESTORE
0000008D TK_GOSUB
0000008E TK_RETURN
0000008F TK_REM
00000090 TK_STOP
00000091 TK_ON
00000092 TK_NULL
00000093 TK_INC
00000094 TK_WAIT
00000095 TK_LOAD
00000096 TK_SAVE
00000097 TK_DEF
00000098 TK_POKE
00000099 TK_DOKE
0000009A TK_LOKE
0000009B TK_CALL
0000009C TK_DO
0000009D TK_LOOP
0000009E TK_PRINT
0000009F TK_CONT
000000A0 TK_LIST
000000A1 TK_CLEAR
000000A2 TK_NEW
000000A3 TK_WIDTH
000000A4 TK_GET
000000A5 TK_SWAP
000000A6 TK_BITSET
000000A7 TK_BITCLR
000000A8 TK_TAB
000000A9 TK_ELSE
000000AA TK_TO
000000AB TK_FN
000000AC TK_SPC
000000AD TK_THEN
000000AE TK_NOT
000000AF TK_STEP
000000B0 TK_UNTIL
000000B1 TK_WHILE
000000B2 TK_PLUS
000000B3 TK_MINUS
000000B4 TK_MULT
000000B5 TK_DIV
000000B6 TK_POWER
000000B7 TK_AND
000000B8 TK_EOR
000000B9 TK_OR
000000BA TK_RSHIFT
000000BB TK_LSHIFT
000000BC TK_GT
000000BD TK_EQUAL
000000BE TK_LT
000000BF TK_SGN
000000C0 TK_INT
000000C1 TK_ABS
000000C2 TK_USR
000000C3 TK_FRE
000000C4 TK_POS
000000C5 TK_SQR
000000C6 TK_RND
000000C7 TK_LOG
000000C8 TK_EXP
000000C9 TK_COS
000000CA TK_SIN
000000CB TK_TAN
000000CC TK_ATN
000000CD TK_PEEK
000000CE TK_DEEK
000000CF TK_LEEK
000000D0 TK_LEN
000000D1 TK_STRS
000000D2 TK_VAL
000000D3 TK_ASC
000000D4 TK_UCASES
000000D5 TK_LCASES
000000D6 TK_CHRS
000000D7 TK_HEXS
000000D8 TK_BINS
000000D9 TK_BITTST
000000DA TK_MAX
000000DB TK_MIN
000000DC TK_RAM
000000DD TK_PI
000000DE TK_TWOPI
000000DF TK_VPTR
000000E0 TK_SADD
000000E1 TK_LEFTS
000000E2 TK_RIGHTS
000000E3 TK_MIDS
000000E4 TK_USINGS
00000400 LAB_WARM
00000400 ram_base
00000402 Wrmjpv
00000406 Usrjmp
00000408 Usrjpv
0000040C V_INPT
0000040E V_INPTv
00000412 V_OUTP
00000414 V_OUTPv
00000418 V_LOAD
0000041A V_LOADv
0000041E V_SAVE
00000420 V_SAVEv
00000424 V_CTLC
00000426 V_CTLCv
0000042A Itemp
0000042E Smeml
00000432 Sfncl
00000436 Svarl
0000043A Sstrl
0000043E Sarryl
00000442 Earryl
00000446 Sstorl
0000044A Ememl
0000044E Sutill
00000452 Clinel
00000456 Blinel
0000045A Cpntrl
0000045E Dlinel
00000462 Dptrl
00000466 Rdptrl
0000046A Varname
0000046E Cvaral
00000472 Lvarpl
00000476 des_sk_e
0000048E des_sk
00000490 Ibuffs
00000590 FAC1_m
00000590 Ibuffe
00000594 FAC1_e
00000595 FAC1_s
00000598 FAC2_m
0000059C FAC2_e
0000059D FAC2_s
0000059E FAC_sc
0000059F flag
000005A0 PRNlword
000005A4 ut1_pl
000005A8 Asptl
000005AC Astrtl
000005AC numexp
000005AD expcnt
000005AF expneg
000005B0 func_l
000005B4 Defdim
000005B4 cosout
000005B5 Dtypef
000005B6 Binss
000005C6 Decss
000005CC Usdss
000005CE Hexss
000005D6 BHsend
000005D8 prstk
000005D9 tpower
000005DA Asrch
000005DB Dimcnt
000005DC Breakf
000005DD Oquote
000005DE Gclctd
000005DF Sufnxf
000005E0 Imode
000005E1 Cflag
000005E2 TabSiz
000005E3 comp_f
000005E4 Nullct
000005E5 TPos
000005E6 TWidth
000005E7 Iclim
000005E8 ccflag
000005E9 ccbyte
000005EA ccnull
000005EC prg_strt
00002000 ram_addr
00006000 ram_size
0000C002 VEC_OUT
0000C00A TXNOTREADY
0000C01C VEC_IN
0000C03A RXNOTREADY
0000C044 VEC_LD
0000C04A VEC_SV
0000C050 code_start
0000C06A LAB_COLD
0000C07A LAB_sizok
0000C12C LAB_FOER
0000C130 LAB_ADER
0000C134 LAB_WDER
0000C138 LAB_UDER
0000C13C LAB_UVER
0000C140 LAB_LDER
0000C144 LAB_UFER
0000C148 LAB_CCER
0000C14C LAB_SCER
0000C150 LAB_SLER
0000C154 LAB_TMER
0000C158 LAB_IDER
0000C15C LAB_DZER
0000C160 LAB_DDER
0000C164 LAB_ABER
0000C168 LAB_USER
0000C16C LAB_OMER
0000C170 LAB_OFER
0000C174 LAB_FCER
0000C178 LAB_ODER
0000C17C LAB_RGER
0000C180 LAB_SNER
0000C184 LAB_NFER
0000C186 LAB_XERR
0000C1A2 LAB_1269
0000C1B0 LAB_1274
0000C1B8 LAB_127D
0000C1C6 LAB_127E
0000C1DA LAB_1295
0000C1FC LAB_12AE
0000C1FE LAB_12B0
0000C21E LAB_12E6
0000C250 LAB_12FF
0000C252 LAB_1301
0000C270 LAB_1303
0000C278 LAB_132E
0000C27A LAB_1330
0000C288 LAB_1325
0000C296 LAB_134B
0000C2AA LAB_INLN
0000C2B4 LAB_1357
0000C2BA LAB_1359
0000C2DA LAB_1374
0000C2E0 LAB_1378
0000C2EC LAB_137F
0000C2F2 LAB_138E
0000C2F6 LAB_1392
0000C32A LAB_13A6
0000C332 LAB_13AC
0000C35C LAB_13C6
0000C362 LAB_13CC
0000C384 LAB_13D6
0000C38A LAB_13D8
0000C396 LAB_13EA
0000C398 LAB_13EC
0000C3B0 LAB_13FF
0000C3B4 LAB_1401
0000C3C0 LAB_1408
0000C3CC LAB_1410
0000C3D6 LAB_1417
0000C3D8 LAB_141B
0000C3E8 LAB_141F
0000C3EE LAB_142A
0000C3FA LAB_142C
0000C400 LAB_SSLN
0000C406 LAB_145F
0000C408 LAB_SCLN
0000C414 LAB_145E
0000C41A LAB_NEW
0000C41C LAB_1463
0000C428 LAB_1477
0000C42E LAB_147A
0000C448 LAB_1480
0000C452 LAB_1491
0000C468 RTS_005
0000C46A LAB_CLEAR
0000C46E LAB_LIST
0000C482 LAB_14BD
0000C486 LAB_14C0
0000C4A6 LAB_14D4
0000C4C2 LAB_14E2
0000C4D0 LAB_150C
0000C4DE LAB_1519
0000C4EA LAB_152E
0000C516 LAB_1540
0000C522 LAB_FOR
0000C576 LAB_15B3
0000C588 LAB_15DC
0000C59A LAB_15F6
0000C5A0 LAB_15C2
0000C5AC LAB_15D1
0000C5BA LAB_15FF
0000C5BE LAB_1602
0000C5E2 LAB_1629
0000C5E6 LAB_1636
0000C5EC LAB_1639
0000C5EE LAB_END
0000C5F6 LAB_STOP
0000C5F8 LAB_163B
0000C604 LAB_1647
0000C60A LAB_164F
0000C61C LAB_RESTORE
0000C62E LAB_RESs
0000C63A LAB_GSCH
0000C642 LAB_1624
0000C648 RTS_006
0000C64A LAB_NULL
0000C654 LAB_CONT
0000C672 LAB_RUN
0000C680 LAB_RUNn
0000C686 LAB_DO
0000C698 LAB_GOSUB
0000C6A2 LAB_16B0
0000C6AA LAB_GOTO
0000C6BA LAB_GOTs
0000C6C6 LAB_16D0
0000C6D8 LAB_LOOP
0000C6FA DoRest
0000C70E DoCmp
0000C714 LoopAlways
0000C728 LoopDone
0000C72E LAB_RETURN
0000C742 LAB_DATA
0000C746 RTS_007
0000C748 LAB_SNBS
0000C750 LAB_172C
0000C758 LAB_172D
0000C75C RTS_007a
0000C760 LAB_1723
0000C764 LAB_1725
0000C76A LAB_IF
0000C78C LAB_174B
0000C7B0 LAB_174E
0000C7B8 LAB_1750
0000C7C4 LAB_1752
0000C7C8 LAB_1756
0000C7D8 LAB_REM
0000C7DC LAB_1754
0000C7E0 LAB_ON
0000C7FA LAB_176C
0000C804 LAB_1773
0000C814 LAB_GFPN
0000C820 LAB_1785
0000C84C LAB_1786
0000C852 LAB_DEC
0000C858 LAB_INC
0000C85E LAB_17B8
0000C862 LAB_17B7
0000C898 LAB_INCT
0000C8A6 LAB_INCI
0000C8B0 LAB_DECI
0000C8B4 LAB_LET
0000C8DC LAB_17D5
0000C8E0 LAB_17D6
0000C8F2 LAB_1810
0000C902 LAB_1811
0000C908 LAB_1813
0000C90C RTS_008
0000C90E LAB_GET
0000C928 LAB_GETS
0000C93A LAB_NoSt
0000C940 LAB_1829
0000C944 LAB_182C
0000C948 LAB_PRINT
0000C94A LAB_1831
0000C98A LAB_185E
0000C98E LAB_1866
0000C994 LAB_CRLF
0000C99C LAB_188B
0000C9AA LAB_1898
0000C9B4 LAB_18A2
0000C9D6 LAB_18B7
0000C9E2 LAB_18B8
0000C9E8 LAB_18BD
0000C9F2 LAB_18C3
0000C9F6 LAB_18C6
0000CA00 LAB_18CD
0000CA08 RTS_009
0000CA0A LAB_18E3
0000CA0C LAB_PRNA
0000CA2A LAB_18F0
0000CA38 LAB_18F7
0000CA3C LAB_18F9
0000CA50 LAB_1880
0000CA5A LAB_1886
0000CA5E LAB_188A
0000CA62 LAB_1904
0000CA74 LAB_1913
0000CA82 LAB_INPUT
0000CA9A LAB_1934
0000CAA8 LAB_READ
0000CAAE LAB_1953
0000CAB6 LAB_195B
0000CAC0 LAB_1961
0000CAE0 LAB_1984
0000CAE4 LAB_1985
0000CAE8 LAB_1986
0000CAFC LAB_1999
0000CB0E LAB_19B0
0000CB1E LAB_19B6
0000CB2E LAB_19C2
0000CB42 LAB_19DD
0000CB62 LAB_19F6
0000CB70 LAB_1A03
0000CB80 LAB_1A0E
0000CB86 LAB_1A1B
0000CB8E LAB_NEXT
0000CBA0 LAB_1A46
0000CBAE LAB_11A5
0000CBB0 LAB_11A6
0000CBBC LAB_11BD
0000CC1E LAB_1A90
0000CC2C LAB_1A9B
0000CC44 LAB_EVNM
0000CC46 LAB_CTNM
0000CC48 LAB_CKTM
0000CC56 LAB_1ABA
0000CC5C LAB_EVEX
0000CC5E LAB_EVEZ
0000CC66 LAB_1B43
0000CC82 LAB_1ACD
0000CC8E LAB_1ADB
0000CC92 LAB_1ADE
0000CCA8 LAB_1AE0
0000CCC2 LAB_1AFA
0000CCD8 LAB_1B0B
0000CCE0 LAB_1B13
0000CCF0 LAB_1B1C
0000CCF2 LAB_1B1D
0000CD04 LAB_1B2A
0000CD20 LAB_1B3C
0000CD2C LAB_1B78
0000CD30 LAB_1B7B
0000CD32 LAB_1B7D
0000CD3C LAB_1B84
0000CD40 LAB_1B86
0000CD64 LAB_1B9D
0000CD6A LAB_GVAL
0000CD94 LAB_1BC1
0000CDA0 LAB_1BF3
0000CDA6 LAB_1BF7
0000CDAA LAB_1BFB
0000CDAE LAB_SCGB
0000CDB2 LAB_1C01
0000CDB4 LAB_SCCA
0000CDBC LAB_IGBY
0000CDBE LAB_GBYT
0000CDD8 RTS_001
0000CDDA LAB_1C11
0000CDE0 LAB_1C13
0000CDE6 LAB_1C18
0000CDEA LAB_1C19
0000CDFA LAB_1C1A
0000CE00 LAB_1BD0
0000CE1A LAB_1BE7
0000CE4C LAB_PPFS
0000CE58 LAB_1C2A
0000CE5A LAB_PPFN
0000CE68 LAB_PPBI
0000CE72 LAB_LRMS
0000CE94 LAB_BHSS
0000CEBA LAB_BHCB
0000CEC4 LAB_EOR
0000CECC LAB_OR
0000CED4 LAB_AND
0000CEDC GetFirst
0000CEEA LAB_EQUAL
0000CEF4 LAB_LTHAN
0000CF00 LAB_1CAE
0000CF1E LAB_1CB5
0000CF28 LAB_1CD4
0000CF2E LAB_1CD5
0000CF30 LAB_1CD6
0000CF32 LAB_1CE6
0000CF40 LAB_1CDB
0000CF42 LAB_1CF2
0000CF58 LAB_1CFE
0000CF5C LAB_DIM
0000CF68 LAB_LSHIFT
0000CF74 NoShift
0000CF78 LAB_RSHIFT
0000CF8C Not2Big
0000CF92 TooBig
0000CF98 GetPair
0000CFAA LAB_CASC
0000CFB0 LAB_CAUC
0000CFBA LAB_1D8A
0000CFC0 LAB_1D83
0000CFC6 LAB_SVAR
0000CFC8 LAB_FVAR
0000CFCA LAB_GVAR
0000CFD0 LAB_1D10
0000CFD4 LAB_1D12
0000CFE6 LAB_1D2D
0000CFF2 LAB_1D2E
0000D00E LAB_1D44
0000D01E LAB_1D45
0000D032 LAB_1D48
0000D03A LAB_1D49
0000D03E LAB_1D4A
0000D04E LAB_1D4B
0000D056 LAB_1D5D
0000D05C LAB_1D5E
0000D070 LAB_1D94
0000D07A LAB_1D98
0000D094 LAB_1DAC
0000D096 LAB_1DAE
0000D0A2 LAB_1DAF
0000D0B0 LAB_1DB0
0000D0B4 LAB_1DB1
0000D0B8 LAB_1DB2
0000D0D0 LAB_1DD7
0000D0EA LAB_1DE6
0000D0F6 LAB_EVIN
0000D0FE LAB_EVPI
0000D106 LAB_EVIR
0000D12C LAB_1E17
0000D132 LAB_1E1F
0000D16C LAB_1E5C
0000D188 LAB_1E8D
0000D1A4 LAB_1EA1
0000D1C0 LAB_1EDF
0000D1CC LAB_1EC0
0000D1F8 LAB_1ED6
0000D206 LAB_1ED8
0000D218 LAB_1F07
0000D232 LAB_1F28
0000D238 LAB_1F2C
0000D246 LAB_1F5A
0000D26E LAB_1F6A
0000D27A LAB_1F6B
0000D27E RTS_011
0000D280 LAB_1F7C
0000D2A4 LAB_FRE
0000D2AE LAB_1FB4
0000D2BA LAB_AYFC
0000D2D6 LAB_POS
0000D2DA LAB_1FD0
0000D2E2 LAB_CKRN
0000D2EC LAB_DEF
0000D334 LAB_201E
0000D382 LAB_2043
0000D384 LAB_204S
0000D3B2 LAB_204T
0000D3B4 LAB_2044
0000D3BE LAB_2045
0000D3CC LAB_STRS
0000D3D0 LAB_20AE
0000D3D4 LAB_20B4
0000D3DA LAB_20BE
0000D3EA LAB_20CB
0000D3F2 LAB_20D0
0000D3FE LAB_20C9
0000D408 LAB_20D8
0000D410 LAB_20E0
0000D416 LAB_RTST
0000D430 LAB_2115
0000D448 LAB_2117
0000D462 LAB_2128
0000D466 LAB_2137
0000D47C LAB_GARB
0000D486 LAB_214B
0000D49A LAB_2161
0000D4A0 LAB_2176
0000D4AC LAB_217E
0000D4C6 LAB_2183
0000D4CE LAB_218B
0000D4D0 LAB_218F
0000D4DC LAB_21C2
0000D4E0 LAB_21C4
0000D504 LAB_2216
0000D50C LAB_2240
0000D514 LAB_21D1
0000D51A LAB_2206
0000D542 LAB_2212
0000D546 RTS_012
0000D548 LAB_224D
0000D55E LAB_224E
0000D5A2 LAB_229E
0000D5AE LAB_22A0
0000D5BA RTS_013
0000D5BC LAB_22B6
0000D5C0 LAB_22BA
0000D5CA LAB_22BD
0000D5E4 LAB_22E6
0000D5EE LAB_CHRS
0000D5F2 LAB_MKCHR
0000D5FE LAB_LEFT
0000D612 LAB_RIGHT
0000D624 LAB_2316
0000D626 LAB_2317
0000D62A LAB_231C
0000D642 LAB_MIDS
0000D65E LAB_2358
0000D67E LAB_2368
0000D686 LAB_LCASE
0000D69C LC_loop
0000D6AE NoUcase
0000D6B6 LAB_UCASE
0000D6CC UC_loop
0000D6DE NoLcase
0000D6E4 NoString
0000D6E8 LAB_SADD
0000D700 LAB_LENS
0000D708 LAB_ASC
0000D718 LAB_SGBY
0000D71C LAB_GTBY
0000D720 LAB_EVBY
0000D730 LAB_GTWO
0000D744 LAB_VAL
0000D76C LAB_VALZ
0000D772 LAB_GADB
0000D786 LAB_GADW
0000D7A0 LAB_XGADW
0000D7A6 LAB_GEAD
0000D7BC LAB_PEEK
0000D7C8 LAB_POKE
0000D7CE LAB_DEEK
0000D7E4 LAB_LEEK
0000D7F8 LAB_DOKE
0000D7FE LAB_LOKE
0000D810 RTS_015
0000D812 LAB_SWAP
0000D840 LAB_USR
0000D848 LAB_LOAD
0000D84C LAB_SAVE
0000D850 LAB_CALL
0000D85A LAB_WAIT
0000D870 LAB_2441
0000D874 LAB_2445
0000D87E LAB_SUBTRACT
0000D892 LAB_ADD
0000D8B6 LAB_249C
0000D8C4 LAB_2467
0000D8C8 LAB_2468
0000D8CC LAB_24A8
0000D8E6 LAB_24F7
0000D8EA RTS_016
0000D8EC LAB_24F8
0000D8F6 LAB_24B4
0000D902 LAB_24D0
0000D90C LAB_24D5
0000D91A LAB_24D9
0000D926 LAB_24D6
0000D934 LAB_24D7
0000D93A LAB_24D8
0000D940 LAB_24DA
0000D942 LAB_LOG
0000D9BA LAB_LAAD
0000D9C0 LAB_LOCC
0000D9CA LAB_LOLP
0000D9DC LAB_LOCX
0000D9E0 LAB_LONN
0000D9EE LAB_LOXP
0000D9F8 LAB_LONE
0000D9FE LAB_LOXO
0000DA32 LAB_LOWZ
0000DA34 LAB_MULTIPLY
0000DA5A LAB_MNOC
0000DA60 LAB_MADD
0000DA8A LAB_MUF1
0000DA94 LAB_MUF2
0000DAAA LAB_MUF3
0000DAAE LAB_MUEX
0000DAB4 LAB_MUUF
0000DAC0 LAB_DIVIDE
0000DAF8 AC1gtAC2
0000DB10 LAB_DIVX
0000DB18 LAB_SET1
0000DB1C L_DIVRND
0000DB28 LAB_XDIV
0000DB34 LAB_MAN1
0000DB3A LAB_DIV0
0000DB40 LAB_32_16
0000DB42 LAB_3216
0000DB4E LAB_LT_1
0000DB66 LAB_REMM
0000DB6E L_DDIV
0000DB74 LAB_UFAC
0000DB86 LAB_NB1T
0000DB90 LAB_PFAC
0000DBA8 LAB_2778
0000DBAA LAB_277C
0000DBCE LAB_279B
0000DBDC LAB_27BA
0000DBF8 LAB_27C3
0000DC02 LAB_27C4
0000DC06 RTS_017
0000DC08 LAB_27CA
0000DC10 LAB_27CE
0000DC14 LAB_27D0
0000DC20 LAB_SGN
0000DC22 LAB_27DB
0000DC32 LAB_ABS
0000DC3A LAB_27FA
0000DC5A LAB_2828
0000DC60 LAB_282E
0000DC62 LAB_282F
0000DC66 LAB_2831
0000DC88 LAB_284G
0000DC90 LAB_284L
0000DC9A LAB_284H
0000DC9C LAB_284J
0000DCA2 LAB_INT
0000DCBA LAB_IRTS
0000DCBC LAB_2953
0000DCC8 LAB_295E
0000DCD4 LAB_2967
0000DCDC LAB_2968
0000DCEE LAB_2969
0000DCF8 LAB_296A
0000DD0E LAB_2970
0000DD1E LAB_2978
0000DD2E LAB_2989
0000DD5A LAB_29B9
0000DD82 LAB_299C
0000DDAA LAB_29A7
0000DDC2 LAB_29B7
0000DDD0 LAB_29C0
0000DDE8 LAB_29C3
0000DE02 LAB_29D9
0000DE14 LAB_29E4
0000DE28 LAB_29F7
0000DE2C LAB_29FB
0000DE34 LAB_29FD
0000DE44 LAB_2A18
0000DE46 LAB_2A1A
0000DE4E LAB_2A21
0000DE6E LAB_2A3B
0000DE7C LAB_2A4B
0000DE90 LAB_2A58
0000DEA8 LAB_2A68
0000DEB4 LAB_2A74
0000DED0 LAB_2A89
0000DED4 LAB_2A8C
0000DEDA LAB_2A91
0000DEDE LAB_27F0
0000DEF4 LAB_27F1
0000DEFA LAB_27F2
0000DEFC LAB_27F3
0000DEFE LAB_POON
0000DF0E LAB_POZE
0000DF1A LAB_POWER
0000DF4C LAB_POWP
0000DF7E LAB_GTHAN
0000DF8A RTS_020
0000DF8C LAB_EX1
0000DF9C LAB_EXOU
0000DFB0 LAB_EXOF
0000DFC6 LAB_EXOL
0000DFD0 LAB_EXP
0000DFF6 LAB_EXCM
0000E008 LAB_EXPS
0000E054 LAB_ESML
0000E0AA LAB_EXPL
0000E0B0 LAB_EXNN
0000E0B6 LAB_EXRN
0000E0C4 LAB_EXCC
0000E0DE LAB_EXAD
0000E0EA LAB_RND
0000E0F8 NextPRN
0000E100 Ninc0
0000E106 Ninc1
0000E11C LAB_TAN
0000E13E LAB_COS
0000E156 LAB_SIN
0000E196 LAB_SCZE
0000E1A4 LAB_SCL0
0000E1AE LAB_CORD
0000E1BC LAB_LTPF
0000E1C8 LAB_LTPT
0000E1D8 subloop
0000E1E0 mainloop
0000E1F2 nexta
0000E200 outloop
0000E20A subexit
0000E216 LAB_ATN
0000E234 LAB_ATGO
0000E252 LAB_ATLE
0000E270 LAB_ATNP
0000E276 LAB_ATCD
0000E27C LAB_CATN
0000E2C6 RTS_021
0000E2C8 LAB_BITSET
0000E2D8 LAB_BITCLR
0000E2E8 LAB_BTST
0000E316 LAB_USINGS
0000E340 LAB_U002
0000E396 LAB_U004
0000E3A6 LAB_U005
0000E3A8 LAB_U006
0000E3BC LAB_U008
0000E3DE LAB_U009
0000E3E6 LAB_U00A
0000E3F0 LAB_U00B
0000E404 LAB_U00C
0000E408 LAB_U00D
0000E41A LAB_U00E
0000E426 LAB_U00F
0000E42A LAB_U010
0000E430 LAB_U014
0000E438 LAB_U018
0000E44E LAB_U01C
0000E45A LAB_U020
0000E460 LAB_U022
0000E470 LAB_U026
0000E47A LAB_U02A
0000E492 LAB_U02B
0000E498 LAB_U02C
0000E4AA LAB_U02E
0000E4AE LAB_U030
0000E4C4 LAB_U034
0000E4CA LAB_U036
0000E4D2 LAB_U038
0000E4DA LAB_U03C
0000E4E0 LAB_U03E
0000E4F8 LAB_U040
0000E508 LAB_U044
0000E530 LAB_U046
0000E532 LAB_U048
0000E53C LAB_U04A
0000E56E LAB_U04C
0000E598 LAB_DupFmt
0000E5B0 LAB_D002
0000E5C0 LAB_D00A
0000E5D0 LAB_D00E
0000E5D6 LAB_ProcFo
0000E5EE LAB_P004
0000E604 LAB_P008
0000E60C LAB_P00C
0000E618 LAB_P00E
0000E61C LAB_P010
0000E636 LAB_P018
0000E63A LAB_P01A
0000E642 LAB_P01E
0000E64C LAB_BINS
0000E65C NextB1
0000E66A EndBHS
0000E682 NextB2
0000E690 BinPr
0000E69A GoPr
0000E69E LAB_HEXS
0000E6AE NextH1
0000E6C8 VEC_CC
0000E6E2 LAB_FBA0
0000E6EC RTS_022
0000E6EE INGET
0000E6FE LAB_FB95
0000E70A LAB_MAX
0000E716 LAB_MAXN
0000E720 LAB_MIN
0000E72C LAB_MINN
0000E736 LAB_MMEC
0000E744 LAB_PHFA
0000E77A LAB_WDTH
0000E79A LAB_NSTT
0000E7AC LAB_TBSZ
0000E7CC LAB_SVTB
0000E7D0 WExit
0000E7E0 LAB_WDLP
0000E7F8 RTS_023
0000E7FA LAB_SQR
0000E81E LAB_SQE1
0000E824 LAB_SQE2
0000E836 LAB_SQNS
0000E84C LAB_SQNA
0000E85C LAB_VARPTR
0000E85E LAB_VARCALL
0000E86C LAB_RAM
0000E876 LAB_PI
0000E886 LAB_TWOPI
0000E896 LAB_2887
0000E8C0 LAB_289A
0000E8C6 LAB_289C
0000E8CC LAB_289D
0000E8E8 LAB_28FD
0000E8EE LAB_28FE
0000E8F4 LAB_28FF
0000E902 LAB_2900
0000E908 LAB_2901
0000E920 LAB_2X01
0000E928 LAB_2X02
0000E936 LAB_2X03
0000E93C LAB_2X04
0000E952 LAB_2X05
0000E95A LAB_2902
0000E962 LAB_2903
0000E964 LAB_2904
0000E972 LAB_2Y01
0000E97A LAB_2Y02
0000E986 LAB_2Y03
0000E98C LAB_2Y04
0000E9D2 LAB_ret0
0000E9D4 LAB_rtn0
0000E9E4 LAB_CHEX
0000E9EC LAB_CHXX
0000EA06 LAB_ISHN
0000EA0A LAB_CHX1
0000EA26 LAB_CHX3
0000EA2E LAB_CHX2
0000EA34 LAB_exxf
0000EA44 RTS_024
0000EA46 LAB_CBIN
0000EA4E LAB_CBXN
0000EA60 LAB_CBX1
0000EA74 d1x16
0000EA82 d1x02
0000EA98 d1x10
0000EAA6 RTS_025
0000EAA8 Bin2dec
0000EAD0 LAB_RSED
0000EBB8 LAB_P_10
0000ECA6 TAB_SNCO
0000ED26 TAB_ATNC
0000ED9E LAB_1D96
0000EDA6 TAB_HTHET
0000EE26 LAB_CTBL
0000EE76 LAB_FTPP
0000EEC2 LAB_FTBL
0000EF0E LAB_OPPT
0000EF42 LAB_2A9A
0000EF5E LAB_2A9B
0000EF5E TAB_CHRT
0000EFC8 LAB_KEYT
0000F15C LAB_BAER
0000F18C LAB_NF
0000F19D LAB_SN
0000F1A4 LAB_RG
0000F1B9 LAB_OD
0000F1C5 LAB_FC
0000F1D3 LAB_OV
0000F1DC LAB_OM
0000F1EA LAB_US
0000F1FE LAB_BS
0000F20B LAB_DD
0000F21C LAB_D0
0000F22B LAB_ID
0000F23A LAB_TM
0000F248 LAB_LS
0000F258 LAB_ST
0000F26B LAB_CN
0000F27A LAB_UF
0000F28D LAB_LD
0000F29D LAB_UV
0000F2B0 LAB_UA
0000F2C4 LAB_WD
0000F2D5 LAB_AD
0000F2DD LAB_FO
0000F2E4 LAB_NI
0000F2F4 KEY_MULT
0000F2F4 TAB_STAR
0000F2F6 KEY_PLUS
0000F2F6 TAB_PLUS
0000F2F8 KEY_MINUS
0000F2F8 TAB_MNUS
0000F2FA KEY_DIV
0000F2FA TAB_SLAS
0000F2FC KEY_LSHIFT
0000F2FC TAB_LESS
0000F2FE KEY_LT
0000F300 KEY_EQUAL
0000F300 TAB_EQUL
0000F302 KEY_RSHIFT
0000F302 TAB_MORE
0000F304 KEY_GT
0000F306 TAB_QEST
0000F308 KEY_ABS
0000F308 TAB_ASCA
0000F30C KEY_AND
0000F30F KEY_ASC
0000F313 KEY_ATN
0000F318 KEY_BINS
0000F318 TAB_ASCB
0000F31D KEY_BITCLR
0000F323 KEY_BITSET
0000F329 KEY_BITTST
0000F331 KEY_CALL
0000F331 TAB_ASCC
0000F335 KEY_CHRS
0000F33A KEY_CLEAR
0000F33F KEY_CONT
0000F343 KEY_COS
0000F348 KEY_DATA
0000F348 TAB_ASCD
0000F34C KEY_DEC
0000F34F KEY_DEEK
0000F354 KEY_DEF
0000F357 KEY_DIM
0000F35A KEY_DOKE
0000F35E KEY_DO
0000F361 KEY_ELSE
0000F361 TAB_ASCE
0000F365 KEY_END
0000F368 KEY_EOR
0000F36B KEY_EXP
0000F370 KEY_FOR
0000F370 TAB_ASCF
0000F373 KEY_FN
0000F375 KEY_FRE
0000F37A KEY_GET
0000F37A TAB_ASCG
0000F37D KEY_GOTO
0000F381 KEY_GOSUB
0000F387 KEY_HEXS
0000F387 TAB_ASCH
0000F38D KEY_IF
0000F38D TAB_ASCI
0000F38F KEY_INC
0000F392 KEY_INPUT
0000F397 KEY_INT
0000F39C KEY_LCASES
0000F39C TAB_ASCL
0000F3A3 KEY_LEEK
0000F3A8 KEY_LEFTS
0000F3AE KEY_LEN
0000F3B2 KEY_LET
0000F3B5 KEY_LIST
0000F3B9 KEY_LOAD
0000F3BD KEY_LOG
0000F3C1 KEY_LOKE
0000F3C5 KEY_LOOP
0000F3CA KEY_MAX
0000F3CA TAB_ASCM
0000F3CE KEY_MIDS
0000F3D3 KEY_MIN
0000F3D8 KEY_NEW
0000F3D8 TAB_ASCN
0000F3DB KEY_NEXT
0000F3DF KEY_NOT
0000F3E2 KEY_NULL
0000F3E7 KEY_ON
0000F3E7 TAB_ASCO
0000F3E9 KEY_OR
0000F3EC KEY_PEEK
0000F3EC TAB_ASCP
0000F3F1 KEY_PI
0000F3F3 KEY_POKE
0000F3F7 KEY_POS
0000F3FB KEY_PRINT
0000F401 KEY_RAM
0000F401 TAB_ASCR
0000F408 KEY_READ
0000F40C KEY_REM
0000F40F KEY_RESTORE
0000F416 KEY_RETURN
0000F41C KEY_RIGHTS
0000F423 KEY_RND
0000F427 KEY_RUN
0000F42B KEY_SADD
0000F42B TAB_ASCS
0000F430 KEY_SAVE
0000F434 KEY_SGN
0000F438 KEY_SIN
0000F43C KEY_SPC
0000F440 KEY_SQR
0000F444 KEY_STEP
0000F448 KEY_STOP
0000F44C KEY_STRS
0000F451 KEY_SWAP
0000F456 KEY_TAB
0000F456 TAB_ASCT
0000F45A KEY_TAN
0000F45E KEY_THEN
0000F462 KEY_TO
0000F464 KEY_TWOPI
0000F46A KEY_UCASES
0000F46A TAB_ASCU
0000F471 KEY_UNTIL
0000F476 KEY_USINGS
0000F47D KEY_USR
0000F482 KEY_VAL
0000F482 TAB_ASCV
0000F486 KEY_VPTR
0000F48E KEY_WAIT
0000F48E TAB_ASCW
0000F492 KEY_WHILE
0000F497 KEY_WIDTH
0000F49D KEY_POWER
0000F49D TAB_POWR
0000F49F LAB_BMSG
0000F4A7 LAB_EMSG
0000F4AE LAB_LMSG
0000F4B8 LAB_IMSG
0000F4C8 LAB_REDO
0000F4DA LAB_RMSG
0000F4E4 LAB_SMSG
00010040 ACIA_1
00010041 ACIA_2
26A3D110 KFCTSEED
